/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/***/ (function(module, exports) {

eval("var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n\n\n//# sourceURL=webpack://crity/./node_modules/cross-fetch/dist/browser-ponyfill.js?");

/***/ }),

/***/ "./node_modules/isomorphic-form-data/lib/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/isomorphic-form-data/lib/browser.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("module.exports = window.FormData\n\n\n//# sourceURL=webpack://crity/./node_modules/isomorphic-form-data/lib/browser.js?");

/***/ }),

/***/ "./app/resources/css/text_layer_builder.css":
/*!**************************************************!*\
  !*** ./app/resources/css/text_layer_builder.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://crity/./app/resources/css/text_layer_builder.css?");

/***/ }),

/***/ "./node_modules/pdfjs-dist/build/pdf.js":
/*!**********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * @licstart The following is the entire license notice for the\n * Javascript code in this page\n *\n * Copyright 2022 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * Javascript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\nexports.arrayByteLength = arrayByteLength;\nexports.arraysToBytes = arraysToBytes;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createPromiseCapability = createPromiseCapability;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.escapeString = escapeString;\nexports.getModificationDate = getModificationDate;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isAscii = isAscii;\nexports.isSameOrigin = isSameOrigin;\nexports.objectFromMap = objectFromMap;\nexports.objectSize = objectSize;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF16BEString = stringToUTF16BEString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.unreachable = unreachable;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\n\n__w_pdfjs_require__(2);\n\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100\n};\nexports.RenderingIntentFlag = RenderingIntentFlag;\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nexports.AnnotationMode = AnnotationMode;\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nconst AnnotationStateModelType = {\n  MARKED: \"Marked\",\n  REVIEW: \"Review\"\n};\nexports.AnnotationStateModelType = AnnotationStateModelType;\nconst AnnotationMarkedState = {\n  MARKED: \"Marked\",\n  UNMARKED: \"Unmarked\"\n};\nexports.AnnotationMarkedState = AnnotationMarkedState;\nconst AnnotationReviewState = {\n  ACCEPTED: \"Accepted\",\n  REJECTED: \"Rejected\",\n  CANCELLED: \"Cancelled\",\n  COMPLETED: \"Completed\",\n  NONE: \"None\"\n};\nexports.AnnotationReviewState = AnnotationReviewState;\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nexports.AnnotationActionEventType = AnnotationActionEventType;\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nexports.DocumentActionEventType = DocumentActionEventType;\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nexports.PageActionEventType = PageActionEventType;\nconst StreamType = {\n  UNKNOWN: \"UNKNOWN\",\n  FLATE: \"FLATE\",\n  LZW: \"LZW\",\n  DCT: \"DCT\",\n  JPX: \"JPX\",\n  JBIG: \"JBIG\",\n  A85: \"A85\",\n  AHX: \"AHX\",\n  CCF: \"CCF\",\n  RLX: \"RLX\"\n};\nexports.StreamType = StreamType;\nconst FontType = {\n  UNKNOWN: \"UNKNOWN\",\n  TYPE1: \"TYPE1\",\n  TYPE1STANDARD: \"TYPE1STANDARD\",\n  TYPE1C: \"TYPE1C\",\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n  TRUETYPE: \"TRUETYPE\",\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\n  TYPE3: \"TYPE3\",\n  OPENTYPE: \"OPENTYPE\",\n  TYPE0: \"TYPE0\",\n  MMTYPE1: \"MMTYPE1\"\n};\nexports.FontType = FontType;\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2\n};\nexports.CMapCompressionType = CMapCompressionType;\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nconst UNSUPPORTED_FEATURES = {\n  unknown: \"unknown\",\n  forms: \"forms\",\n  javaScript: \"javaScript\",\n  signatures: \"signatures\",\n  smask: \"smask\",\n  shadingPattern: \"shadingPattern\",\n  font: \"font\",\n  errorTilingPattern: \"errorTilingPattern\",\n  errorExtGState: \"errorExtGState\",\n  errorXObject: \"errorXObject\",\n  errorFontLoadType3: \"errorFontLoadType3\",\n  errorFontState: \"errorFontState\",\n  errorFontMissing: \"errorFontMissing\",\n  errorFontTranslate: \"errorFontTranslate\",\n  errorColorSpace: \"errorColorSpace\",\n  errorOperatorList: \"errorOperatorList\",\n  errorFontToUnicode: \"errorFontToUnicode\",\n  errorFontLoadNative: \"errorFontLoadNative\",\n  errorFontBuildPath: \"errorFontBuildPath\",\n  errorFontGetPath: \"errorFontGetPath\",\n  errorMarkedContent: \"errorMarkedContent\",\n  errorContentSubStream: \"errorContentSubStream\"\n};\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nlet verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\n\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\nfunction isSameOrigin(baseUrl, otherUrl) {\n  let base;\n\n  try {\n    base = new URL(baseUrl);\n\n    if (!base.origin || base.origin === \"null\") {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  const other = new URL(otherUrl, base);\n  return base.origin === other.origin;\n}\n\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n\n  switch (url.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n\n        if (dots && dots.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch (ex) {}\n      }\n    }\n\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {}\n\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: true,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\n\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n\n    this.message = message;\n    this.name = name;\n  }\n\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\n\nexports.BaseException = BaseException;\n\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n\n}\n\nexports.PasswordException = PasswordException;\n\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n\n}\n\nexports.UnknownErrorException = UnknownErrorException;\n\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n\n}\n\nexports.InvalidPDFException = InvalidPDFException;\n\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n\n}\n\nexports.MissingPDFException = MissingPDFException;\n\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n\n}\n\nexports.UnexpectedResponseException = UnexpectedResponseException;\n\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n\n}\n\nexports.FormatError = FormatError;\n\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n\n}\n\nexports.AbortException = AbortException;\n\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes === null || bytes.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  const strBuf = [];\n\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return bytes;\n}\n\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n\n  if (arr.byteLength !== undefined) {\n    return arr.byteLength;\n  }\n\n  unreachable(\"Invalid argument for arrayByteLength\");\n}\n\nfunction arraysToBytes(arr) {\n  const length = arr.length;\n\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n\n  let resultLength = 0;\n\n  for (let i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n\n  let pos = 0;\n  const data = new Uint8Array(resultLength);\n\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === \"string\") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n\n    const itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n\n  return data;\n}\n\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\n\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\n\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\n\nconst IsLittleEndianCached = {\n  get value() {\n    return shadow(this, \"value\", isLittleEndian());\n  }\n\n};\nexports.IsLittleEndianCached = IsLittleEndianCached;\n\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst IsEvalSupportedCached = {\n  get value() {\n    return shadow(this, \"value\", isEvalSupported());\n  }\n\n};\nexports.IsEvalSupportedCached = IsEvalSupportedCached;\nconst hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\n\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = Util.applyTransform(r, m);\n    const p2 = Util.applyTransform(r.slice(2, 4), m);\n    const p3 = Util.applyTransform([r[0], r[3]], m);\n    const p4 = Util.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n\n  static apply3dTransform(m, v) {\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n  }\n\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n\n    return r;\n  }\n\n  static intersect(rect1, rect2) {\n    function compare(a, b) {\n      return a - b;\n    }\n\n    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n    const result = [];\n    rect1 = Util.normalizeRect(rect1);\n    rect2 = Util.normalizeRect(rect2);\n\n    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n      result[0] = orderedX[1];\n      result[2] = orderedX[2];\n    } else {\n      return null;\n    }\n\n    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n      result[1] = orderedY[1];\n      result[3] = orderedY[2];\n    } else {\n      return null;\n    }\n\n    return result;\n  }\n\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const tvalues = [],\n          bounds = [[], []];\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n\n    for (let i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n\n        t = -c / b;\n\n        if (0 < t && t < 1) {\n          tvalues.push(t);\n        }\n\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n\n      if (b2ac < 0) {\n        continue;\n      }\n\n      t1 = (-b + sqrtb2ac) / (2 * a);\n\n      if (0 < t1 && t1 < 1) {\n        tvalues.push(t1);\n      }\n\n      t2 = (-b - sqrtb2ac) / (2 * a);\n\n      if (0 < t2 && t2 < 1) {\n        tvalues.push(t2);\n      }\n    }\n\n    let j = tvalues.length,\n        mt;\n    const jlen = j;\n\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n    }\n\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];\n  }\n\n}\n\nexports.Util = Util;\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\n\nfunction stringToPDFString(str) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        return decoder.decode(buffer);\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n\n  const strBuf = [];\n\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const code = PDFStringTranslateTable[str.charCodeAt(i)];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction escapeString(str) {\n  return str.replace(/([()\\\\\\n\\r])/g, match => {\n    if (match === \"\\n\") {\n      return \"\\\\n\";\n    } else if (match === \"\\r\") {\n      return \"\\\\r\";\n    }\n\n    return `\\\\${match}`;\n  });\n}\n\nfunction isAscii(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\nfunction stringToUTF16BEString(str) {\n  const buf = [\"\\xFE\\xFF\"];\n\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));\n  }\n\n  return buf.join(\"\");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getModificationDate(date = new Date()) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\n\nfunction createPromiseCapability() {\n  const capability = Object.create(null);\n  let isSettled = false;\n  Object.defineProperty(capability, \"settled\", {\n    get() {\n      return isSettled;\n    }\n\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\n\nvar _is_node = __w_pdfjs_require__(3);\n\n;\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isNodeJS = void 0;\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.build = exports.RenderTask = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\nexports.getDocument = getDocument;\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\nexports.version = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(5);\n\nvar _font_loader = __w_pdfjs_require__(7);\n\nvar _node_utils = __w_pdfjs_require__(8);\n\nvar _annotation_storage = __w_pdfjs_require__(9);\n\nvar _canvas = __w_pdfjs_require__(10);\n\nvar _worker_options = __w_pdfjs_require__(12);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nvar _message_handler = __w_pdfjs_require__(13);\n\nvar _metadata = __w_pdfjs_require__(14);\n\nvar _optional_content_config = __w_pdfjs_require__(15);\n\nvar _transport_stream = __w_pdfjs_require__(16);\n\nvar _xfa_text = __w_pdfjs_require__(17);\n\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\nconst DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\nconst DefaultStandardFontDataFactory = _is_node.isNodeJS ? _node_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\nexports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\nlet createPDFNetworkStream;\n\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\nfunction getDocument(src) {\n  const task = new PDFDocumentLoadingTask();\n  let source;\n\n  if (typeof src === \"string\" || src instanceof URL) {\n    source = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    source = {\n      data: src\n    };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = {\n      range: src\n    };\n  } else {\n    if (typeof src !== \"object\") {\n      throw new Error(\"Invalid parameter in getDocument, \" + \"need either string, URL, Uint8Array, or parameter object.\");\n    }\n\n    if (!src.url && !src.data && !src.range) {\n      throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n    }\n\n    source = src;\n  }\n\n  const params = Object.create(null);\n  let rangeTransport = null,\n      worker = null;\n\n  for (const key in source) {\n    const value = source[key];\n\n    switch (key) {\n      case \"url\":\n        if (typeof window !== \"undefined\") {\n          try {\n            params[key] = new URL(value, window.location).href;\n            continue;\n          } catch (ex) {\n            (0, _util.warn)(`Cannot create valid URL: \"${ex}\".`);\n          }\n        } else if (typeof value === \"string\" || value instanceof URL) {\n          params[key] = value.toString();\n          continue;\n        }\n\n        throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n\n      case \"range\":\n        rangeTransport = value;\n        continue;\n\n      case \"worker\":\n        worker = value;\n        continue;\n\n      case \"data\":\n        if (_is_node.isNodeJS && typeof Buffer !== \"undefined\" && value instanceof Buffer) {\n          params[key] = new Uint8Array(value);\n        } else if (value instanceof Uint8Array) {\n          break;\n        } else if (typeof value === \"string\") {\n          params[key] = (0, _util.stringToBytes)(value);\n        } else if (typeof value === \"object\" && value !== null && !isNaN(value.length)) {\n          params[key] = new Uint8Array(value);\n        } else if ((0, _util.isArrayBuffer)(value)) {\n          params[key] = new Uint8Array(value);\n        } else {\n          throw new Error(\"Invalid PDF binary data: either typed array, \" + \"string, or array-like object is expected in the data property.\");\n        }\n\n        continue;\n    }\n\n    params[key] = value;\n  }\n\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n  params.enableXfa = params.enableXfa === true;\n\n  if (typeof params.docBaseUrl !== \"string\" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {\n    params.docBaseUrl = null;\n  }\n\n  if (!Number.isInteger(params.maxImageSize)) {\n    params.maxImageSize = -1;\n  }\n\n  if (typeof params.useWorkerFetch !== \"boolean\") {\n    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;\n  }\n\n  if (typeof params.isEvalSupported !== \"boolean\") {\n    params.isEvalSupported = true;\n  }\n\n  if (typeof params.disableFontFace !== \"boolean\") {\n    params.disableFontFace = _is_node.isNodeJS;\n  }\n\n  if (typeof params.useSystemFonts !== \"boolean\") {\n    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;\n  }\n\n  if (typeof params.ownerDocument === \"undefined\") {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== \"boolean\") {\n    params.disableRange = false;\n  }\n\n  if (typeof params.disableStream !== \"boolean\") {\n    params.disableStream = false;\n  }\n\n  if (typeof params.disableAutoFetch !== \"boolean\") {\n    params.disableAutoFetch = false;\n  }\n\n  (0, _util.setVerbosityLevel)(params.verbosity);\n\n  if (!worker) {\n    const workerParams = {\n      verbosity: params.verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n\n  const docId = task.docId;\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n\n    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n    const networkStreamPromise = new Promise(function (resolve) {\n      let networkStream;\n\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length: params.length,\n          initialData: params.initialData,\n          progressiveDone: params.progressiveDone,\n          contentDispositionFilename: params.contentDispositionFilename,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        }, rangeTransport);\n      } else if (!params.data) {\n        networkStream = createPDFNetworkStream({\n          url: params.url,\n          length: params.length,\n          httpHeaders: params.httpHeaders,\n          withCredentials: params.withCredentials,\n          rangeChunkSize: params.rangeChunkSize,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        });\n      }\n\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, params);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\n\nasync function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;\n  }\n\n  const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n    docId,\n    apiVersion: '2.13.216',\n    source: {\n      data: source.data,\n      url: source.url,\n      password: source.password,\n      disableAutoFetch: source.disableAutoFetch,\n      rangeChunkSize: source.rangeChunkSize,\n      length: source.length\n    },\n    maxImageSize: source.maxImageSize,\n    disableFontFace: source.disableFontFace,\n    docBaseUrl: source.docBaseUrl,\n    ignoreErrors: source.ignoreErrors,\n    isEvalSupported: source.isEvalSupported,\n    fontExtraProperties: source.fontExtraProperties,\n    enableXfa: source.enableXfa,\n    useSystemFonts: source.useSystemFonts,\n    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,\n    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null\n  });\n\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  return workerId;\n}\n\nclass PDFDocumentLoadingTask {\n  static get idCounters() {\n    return (0, _util.shadow)(this, \"idCounters\", {\n      doc: 0\n    });\n  }\n\n  constructor() {\n    this._capability = (0, _util.createPromiseCapability)();\n    this._transport = null;\n    this._worker = null;\n    this.docId = `d${PDFDocumentLoadingTask.idCounters.doc++}`;\n    this.destroyed = false;\n    this.onPassword = null;\n    this.onProgress = null;\n    this.onUnsupportedFeature = null;\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  async destroy() {\n    this.destroyed = true;\n    await this._transport?.destroy();\n    this._transport = null;\n\n    if (this._worker) {\n      this._worker.destroy();\n\n      this._worker = null;\n    }\n  }\n\n}\n\nexports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n\nclass PDFDataRangeTransport {\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = (0, _util.createPromiseCapability)();\n  }\n\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n\n  requestDataRange(begin, end) {\n    (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n\n  abort() {}\n\n}\n\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\n\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n    Object.defineProperty(this, \"fingerprint\", {\n      get() {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.fingerprint`, \" + \"please use `PDFDocumentProxy.fingerprints` instead.\");\n        return this.fingerprints[0];\n      }\n\n    });\n    Object.defineProperty(this, \"getStats\", {\n      value: async () => {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getStats`, \" + \"please use the `PDFDocumentProxy.stats`-getter instead.\");\n        return this.stats || {\n          streamTypes: {},\n          fontTypes: {}\n        };\n      }\n    });\n  }\n\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n\n  get stats() {\n    return this._transport.stats;\n  }\n\n  get isPureXfa() {\n    return !!this._transport._htmlForXfa;\n  }\n\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n\n  getJavaScript() {\n    return this._transport.getJavaScript();\n  }\n\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n\n  getOutline() {\n    return this._transport.getOutline();\n  }\n\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n\n  getData() {\n    return this._transport.getData();\n  }\n\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n\n  saveDocument() {\n    if (this._transport.annotationStorage.size <= 0) {\n      (0, _display_utils.deprecated)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n\n    return this._transport.saveDocument();\n  }\n\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n\n}\n\nexports.PDFDocumentProxy = PDFDocumentProxy;\n\nclass PDFPageProxy {\n  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this._annotationPromises = new Map();\n    this.destroyed = false;\n  }\n\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n\n  get ref() {\n    return this._pageInfo.ref;\n  }\n\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n\n  get view() {\n    return this._pageInfo.view;\n  }\n\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new _display_utils.PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const intentArgs = this._transport.getRenderingIntent(intent);\n\n    let promise = this._annotationPromises.get(intentArgs.cacheKey);\n\n    if (!promise) {\n      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n\n      this._annotationPromises.set(intentArgs.cacheKey, promise);\n\n      promise = promise.then(annotations => {\n        for (const annotation of annotations) {\n          if (annotation.titleObj !== undefined) {\n            Object.defineProperty(annotation, \"title\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`title`-property on annotation, please use `titleObj` instead.\");\n                return annotation.titleObj.str;\n              }\n\n            });\n          }\n\n          if (annotation.contentsObj !== undefined) {\n            Object.defineProperty(annotation, \"contents\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`contents`-property on annotation, please use `contentsObj` instead.\");\n                return annotation.contentsObj.str;\n              }\n\n            });\n          }\n        }\n\n        return annotations;\n      });\n    }\n\n    return promise;\n  }\n\n  getJSActions() {\n    return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);\n  }\n\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n\n  render({\n    canvasContext,\n    viewport,\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    transform = null,\n    imageLayer = null,\n    canvasFactory = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null\n  }) {\n    if (arguments[0]?.renderInteractiveForms !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `renderInteractiveForms`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_FORMS;\n      }\n    }\n\n    if (arguments[0]?.includeAnnotationStorage !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `includeAnnotationStorage`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;\n      }\n    }\n\n    if (this._stats) {\n      this._stats.time(\"Overall\");\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode);\n\n    this.pendingCleanup = false;\n\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n\n    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n      ownerDocument: this._ownerDocument\n    });\n    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n\n      if (this.cleanupAfterRender || intentPrint) {\n        this.pendingCleanup = true;\n      }\n\n      this._tryCleanup();\n\n      if (error) {\n        internalRenderTask.capability.reject(error);\n\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n\n        this._stats.timeEnd(\"Overall\");\n      }\n    };\n\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        imageLayer,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: canvasFactoryInstance,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.pendingCleanup) {\n        complete();\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.time(\"Rendering\");\n      }\n\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    let opListTask;\n\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    return intentState.opListReadCapability.promise;\n  }\n\n  streamTextContent({\n    disableCombineTextItems = false,\n    includeMarkedContent = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      combineTextItems: disableCombineTextItems !== true,\n      includeMarkedContent: includeMarkedContent === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n\n      size(textContent) {\n        return textContent.items.length;\n      }\n\n    });\n  }\n\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => {\n        return _xfa_text.XfaText.textContent(xfa);\n      });\n    }\n\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null)\n      };\n      pump();\n    });\n  }\n\n  getStructTree() {\n    return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);\n  }\n\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n\n    this.objs.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n    this.pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n\n  cleanup(resetStats = false) {\n    this.pendingCleanup = true;\n    return this._tryCleanup(resetStats);\n  }\n\n  _tryCleanup(resetStats = false) {\n    if (!this.pendingCleanup) {\n      return false;\n    }\n\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n\n    this._intentStates.clear();\n\n    this.objs.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n\n    if (resetStats && this._stats) {\n      this._stats = new _display_utils.StatTimer();\n    }\n\n    this.pendingCleanup = false;\n    return true;\n  }\n\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n\n    if (!intentState) {\n      return;\n    }\n\n    if (this._stats) {\n      this._stats.timeEnd(\"Page Request\");\n    }\n\n    if (intentState.displayReadyCapability) {\n      intentState.displayReadyCapability.resolve(transparency);\n    }\n  }\n\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n\n    if (operatorListChunk.lastChunk) {\n      this._tryCleanup();\n    }\n  }\n\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey\n  }) {\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null\n    });\n\n    const reader = readableStream.getReader();\n\n    const intentState = this._intentStates.get(cacheKey);\n\n    intentState.streamReader = reader;\n\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        this._renderPageChunk(value, intentState);\n\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n\n          this._tryCleanup();\n        }\n\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n\n    pump();\n  }\n\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n\n      if (reason instanceof _display_utils.RenderingCancelledException) {\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n\n          intentState.streamReaderCancelTimeout = null;\n        }, RENDERING_CANCELLED_TIMEOUT);\n        return;\n      }\n    }\n\n    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n\n    if (this._transport.destroyed) {\n      return;\n    }\n\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n\n        break;\n      }\n    }\n\n    this.cleanup();\n  }\n\n  get stats() {\n    return this._stats;\n  }\n\n}\n\nexports.PDFPageProxy = PDFPageProxy;\n\nclass LoopbackPort {\n  constructor() {\n    this._listeners = [];\n    this._deferred = Promise.resolve();\n  }\n\n  postMessage(obj, transfers) {\n    const event = {\n      data: structuredClone(obj, transfers)\n    };\n\n    this._deferred.then(() => {\n      for (const listener of this._listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n\n  addEventListener(name, listener) {\n    this._listeners.push(listener);\n  }\n\n  removeEventListener(name, listener) {\n    const i = this._listeners.indexOf(listener);\n\n    this._listeners.splice(i, 1);\n  }\n\n  terminate() {\n    this._listeners.length = 0;\n  }\n\n}\n\nexports.LoopbackPort = LoopbackPort;\nconst PDFWorkerUtil = {\n  isWorkerDisabled: false,\n  fallbackWorkerSrc: null,\n  fakeWorkerId: 0\n};\n{\n  if (_is_node.isNodeJS && \"function\" === \"function\") {\n    PDFWorkerUtil.isWorkerDisabled = true;\n    PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if (typeof document === \"object\") {\n    const pdfjsFilePath = document?.currentScript?.src;\n\n    if (pdfjsFilePath) {\n      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n\n  PDFWorkerUtil.createCDNWrapper = function (url) {\n    const wrapper = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([wrapper]));\n  };\n}\n\nclass PDFWorker {\n  static get _workerPorts() {\n    return (0, _util.shadow)(this, \"_workerPorts\", new WeakMap());\n  }\n\n  constructor({\n    name = null,\n    port = null,\n    verbosity = (0, _util.getVerbosityLevel)()\n  } = {}) {\n    if (port && PDFWorker._workerPorts.has(port)) {\n      throw new Error(\"Cannot use more than one PDFWorker per port.\");\n    }\n\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    this._readyCapability = (0, _util.createPromiseCapability)();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n\n    if (port) {\n      PDFWorker._workerPorts.set(port, this);\n\n      this._initializeFromPort(port);\n\n      return;\n    }\n\n    this._initialize();\n  }\n\n  get promise() {\n    return this._readyCapability.promise;\n  }\n\n  get port() {\n    return this._port;\n  }\n\n  get messageHandler() {\n    return this._messageHandler;\n  }\n\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n\n    this._messageHandler.on(\"ready\", function () {});\n\n    this._readyCapability.resolve();\n  }\n\n  _initialize() {\n    if (typeof Worker !== \"undefined\" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n      let workerSrc = PDFWorker.workerSrc;\n\n      try {\n        if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\n          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n        }\n\n        const worker = new Worker(workerSrc);\n        const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n\n        const terminateEarly = () => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          messageHandler.destroy();\n          worker.terminate();\n\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          } else {\n            this._setupFakeWorker();\n          }\n        };\n\n        const onWorkerError = () => {\n          if (!this._webWorker) {\n            terminateEarly();\n          }\n        };\n\n        worker.addEventListener(\"error\", onWorkerError);\n        messageHandler.on(\"test\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          if (data) {\n            this._messageHandler = messageHandler;\n            this._port = worker;\n            this._webWorker = worker;\n\n            this._readyCapability.resolve();\n\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity\n            });\n          } else {\n            this._setupFakeWorker();\n\n            messageHandler.destroy();\n            worker.terminate();\n          }\n        });\n        messageHandler.on(\"ready\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          try {\n            sendTest();\n          } catch (e) {\n            this._setupFakeWorker();\n          }\n        });\n\n        const sendTest = () => {\n          const testObj = new Uint8Array([255]);\n\n          try {\n            messageHandler.send(\"test\", testObj, [testObj.buffer]);\n          } catch (ex) {\n            (0, _util.warn)(\"Cannot use postMessage transfers.\");\n            testObj[0] = 0;\n            messageHandler.send(\"test\", testObj);\n          }\n        };\n\n        sendTest();\n        return;\n      } catch (e) {\n        (0, _util.info)(\"The worker has been disabled.\");\n      }\n    }\n\n    this._setupFakeWorker();\n  }\n\n  _setupFakeWorker() {\n    if (!PDFWorkerUtil.isWorkerDisabled) {\n      (0, _util.warn)(\"Setting up fake worker.\");\n      PDFWorkerUtil.isWorkerDisabled = true;\n    }\n\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n\n        return;\n      }\n\n      const port = new LoopbackPort();\n      this._port = port;\n      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n      const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n      this._messageHandler = messageHandler;\n\n      this._readyCapability.resolve();\n\n      messageHandler.send(\"configure\", {\n        verbosity: this.verbosity\n      });\n    }).catch(reason => {\n      this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n\n  destroy() {\n    this.destroyed = true;\n\n    if (this._webWorker) {\n      this._webWorker.terminate();\n\n      this._webWorker = null;\n    }\n\n    PDFWorker._workerPorts.delete(this._port);\n\n    this._port = null;\n\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n\n      this._messageHandler = null;\n    }\n  }\n\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n\n    if (this._workerPorts.has(params.port)) {\n      return this._workerPorts.get(params.port);\n    }\n\n    return new PDFWorker(params);\n  }\n\n  static get workerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n\n    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n      if (!_is_node.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n\n      return PDFWorkerUtil.fallbackWorkerSrc;\n    }\n\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n\n  static get _mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch (ex) {\n      return null;\n    }\n  }\n\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n\n      if (mainWorkerMessageHandler) {\n        return mainWorkerMessageHandler;\n      }\n\n      if (_is_node.isNodeJS && \"function\" === \"function\") {\n        const worker = eval(\"require\")(this.workerSrc);\n        return worker.WorkerMessageHandler;\n      }\n\n      await (0, _display_utils.loadScript)(this.workerSrc);\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n\n    return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n\n}\n\nexports.PDFWorker = PDFWorker;\n{\n  PDFWorker.getWorkerSrc = function () {\n    (0, _display_utils.deprecated)(\"`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.\");\n    return this.workerSrc;\n  };\n}\n\nclass WorkerTransport {\n  #docStats = null;\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #metadataPromise = null;\n\n  constructor(messageHandler, loadingTask, networkStream, params) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this._params = params;\n\n    if (!params.useWorkerFetch) {\n      this.CMapReaderFactory = new params.CMapReaderFactory({\n        baseUrl: params.cMapUrl,\n        isCompressed: params.cMapPacked\n      });\n      this.StandardFontDataFactory = new params.StandardFontDataFactory({\n        baseUrl: params.standardFontDataUrl\n      });\n    }\n\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n    this.setupMessageHandler();\n  }\n\n  get annotationStorage() {\n    return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n  }\n\n  get stats() {\n    return this.#docStats;\n  }\n\n  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, isOpList = false) {\n    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n    let lastModified = \"\";\n\n    switch (intent) {\n      case \"any\":\n        renderingIntent = _util.RenderingIntentFlag.ANY;\n        break;\n\n      case \"display\":\n        break;\n\n      case \"print\":\n        renderingIntent = _util.RenderingIntentFlag.PRINT;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n\n    switch (annotationMode) {\n      case _util.AnnotationMode.DISABLE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n\n      case _util.AnnotationMode.ENABLE:\n        break;\n\n      case _util.AnnotationMode.ENABLE_FORMS:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n\n      case _util.AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        lastModified = this.annotationStorage.lastModified;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n\n    if (isOpList) {\n      renderingIntent += _util.RenderingIntentFlag.OPLIST;\n    }\n\n    return {\n      renderingIntent,\n      cacheKey: `${renderingIntent}_${lastModified}`\n    };\n  }\n\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n\n    this.destroyed = true;\n    this.destroyCapability = (0, _util.createPromiseCapability)();\n\n    if (this._passwordCapability) {\n      this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    }\n\n    const waitOn = [];\n\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#metadataPromise = null;\n      this._getFieldObjectsPromise = null;\n      this._hasJSActionsPromise = null;\n\n      if (this._networkStream) {\n        this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", data => {\n      const headersCapability = (0, _util.createPromiseCapability)();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress) {\n            loadingTask.onProgress?.(this._lastProgress);\n          }\n\n          fullReader.onProgress = evt => {\n            loadingTask.onProgress?.({\n              loaded: evt.loaded,\n              total: evt.total\n            });\n          };\n        }\n\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength\n        });\n      }, headersCapability.reject);\n      return headersCapability.promise;\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new _util.PasswordException(ex.message, ex.code);\n          break;\n\n        case \"InvalidPDFException\":\n          reason = new _util.InvalidPDFException(ex.message);\n          break;\n\n        case \"MissingPDFException\":\n          reason = new _util.MissingPDFException(ex.message);\n          break;\n\n        case \"UnexpectedResponseException\":\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n          break;\n\n        case \"UnknownErrorException\":\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\n          break;\n\n        default:\n          (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n      }\n\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this._passwordCapability = (0, _util.createPromiseCapability)();\n\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this._passwordCapability.reject(password);\n          } else {\n            this._passwordCapability.resolve({\n              password\n            });\n          }\n        };\n\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this._passwordCapability.reject(ex);\n        }\n      } else {\n        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n      }\n\n      return this._passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const page = this.#pageCache.get(data.pageIndex);\n\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Font\":\n          const params = this._params;\n\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n\n          let fontRegistry = null;\n\n          if (params.pdfBug && globalThis.FontInspector?.enabled) {\n            fontRegistry = {\n              registerFont(font, url) {\n                globalThis.FontInspector.fontAdded(font, url);\n              }\n\n            };\n          }\n\n          const font = new _font_loader.FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n            fontRegistry\n          });\n          this.fontLoader.bind(font).catch(reason => {\n            return messageHandler.sendWithPromise(\"FontFallback\", {\n              id\n            });\n          }).finally(() => {\n            if (!params.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n\n        case \"FontPath\":\n        case \"Image\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const pageProxy = this.#pageCache.get(pageIndex);\n\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n          const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n          if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {\n            pageProxy.cleanupAfterRender = true;\n          }\n\n          break;\n\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"DocStats\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      this.#docStats = Object.freeze({\n        streamTypes: Object.freeze(data.streamTypes),\n        fontTypes: Object.freeze(data.fontTypes)\n      });\n    });\n    messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n    messageHandler.on(\"FetchBuiltInCMap\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.CMapReaderFactory) {\n        return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.CMapReaderFactory.fetch(data);\n    });\n    messageHandler.on(\"FetchStandardFontData\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.StandardFontDataFactory) {\n        return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.StandardFontDataFactory.fetch(data);\n    });\n  }\n\n  _onUnsupportedFeature({\n    featureId\n  }) {\n    if (this.destroyed) {\n      return;\n    }\n\n    this.loadingTask.onUnsupportedFeature?.(featureId);\n  }\n\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n\n    const pageIndex = pageNumber - 1,\n          cachedPromise = this.#pagePromises.get(pageIndex);\n\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n\n  getPageIndex(ref) {\n    if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n\n  saveDocument() {\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: this.annotationStorage.serializable,\n      filename: this._fullReader?.filename ?? null\n    }).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n\n  getFieldObjects() {\n    return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\n  }\n\n  hasJSActions() {\n    return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(\"HasJSActions\", null);\n  }\n\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n\n  getJavaScript() {\n    return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n  }\n\n  getDocJSActions() {\n    return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n  }\n\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n\n  getOptionalContentConfig() {\n    return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n      return new _optional_content_config.OptionalContentConfig(results);\n    });\n  }\n\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n\n  getMetadata() {\n    return this.#metadataPromise ||= this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => {\n      return {\n        info: results[0],\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n        contentDispositionFilename: this._fullReader?.filename ?? null,\n        contentLength: this._fullReader?.contentLength ?? null\n      };\n    });\n  }\n\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n\n  async startCleanup(keepLoadedFonts = false) {\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n\n    if (this.destroyed) {\n      return;\n    }\n\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n\n    this.commonObjs.clear();\n\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n\n    this.#metadataPromise = null;\n    this._getFieldObjectsPromise = null;\n    this._hasJSActionsPromise = null;\n  }\n\n  get loadingParams() {\n    const params = this._params;\n    return (0, _util.shadow)(this, \"loadingParams\", {\n      disableAutoFetch: params.disableAutoFetch,\n      enableXfa: params.enableXfa\n    });\n  }\n\n}\n\nclass PDFObjects {\n  #objs = Object.create(null);\n\n  #ensureObj(objId) {\n    const obj = this.#objs[objId];\n\n    if (obj) {\n      return obj;\n    }\n\n    return this.#objs[objId] = {\n      capability: (0, _util.createPromiseCapability)(),\n      data: null\n    };\n  }\n\n  get(objId, callback = null) {\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.capability.promise.then(() => callback(obj.data));\n      return null;\n    }\n\n    const obj = this.#objs[objId];\n\n    if (!obj?.capability.settled) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n\n    return obj.data;\n  }\n\n  has(objId) {\n    const obj = this.#objs[objId];\n    return obj?.capability.settled || false;\n  }\n\n  resolve(objId, data = null) {\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.capability.resolve();\n  }\n\n  clear() {\n    this.#objs = Object.create(null);\n  }\n\n}\n\nclass RenderTask {\n  constructor(internalRenderTask) {\n    this._internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n\n  get promise() {\n    return this._internalRenderTask.capability.promise;\n  }\n\n  cancel() {\n    this._internalRenderTask.cancel();\n  }\n\n}\n\nexports.RenderTask = RenderTask;\n\nclass InternalRenderTask {\n  static get canvasInUse() {\n    return (0, _util.shadow)(this, \"canvasInUse\", new WeakSet());\n  }\n\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this._pdfBug = pdfBug;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = (0, _util.createPromiseCapability)();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this._canvas) {\n      if (InternalRenderTask.canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n\n      InternalRenderTask.canvasInUse.add(this._canvas);\n    }\n\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n\n    const {\n      canvasContext,\n      viewport,\n      transform,\n      imageLayer,\n      background\n    } = this.params;\n    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n\n    if (this.graphicsReadyCallback) {\n      this.graphicsReadyCallback();\n    }\n  }\n\n  cancel(error = null) {\n    this.running = false;\n    this.cancelled = true;\n\n    if (this.gfx) {\n      this.gfx.endDrawing();\n    }\n\n    if (this._canvas) {\n      InternalRenderTask.canvasInUse.delete(this._canvas);\n    }\n\n    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\"));\n  }\n\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      if (!this.graphicsReadyCallback) {\n        this.graphicsReadyCallback = this._continueBound;\n      }\n\n      return;\n    }\n\n    if (this.stepper) {\n      this.stepper.updateOperatorList(this.operatorList);\n    }\n\n    if (this.running) {\n      return;\n    }\n\n    this._continue();\n  }\n\n  _continue() {\n    this.running = true;\n\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      window.requestAnimationFrame(() => {\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n\n        if (this._canvas) {\n          InternalRenderTask.canvasInUse.delete(this._canvas);\n        }\n\n        this.callback();\n      }\n    }\n  }\n\n}\n\nconst version = '2.13.216';\nexports.version = version;\nconst build = '399a0ec60';\nexports.build = build;\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;\nexports.deprecated = deprecated;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\nexports.getXfaPageViewport = getXfaPageViewport;\nexports.isDataScheme = isDataScheme;\nexports.isPdfFile = isPdfFile;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\n\nvar _base_factory = __w_pdfjs_require__(6);\n\nvar _util = __w_pdfjs_require__(1);\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\n\nexports.PixelsPerInch = PixelsPerInch;\n\nclass DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document\n  } = {}) {\n    super();\n    this._document = ownerDocument;\n  }\n\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n\n}\n\nexports.DOMCanvasFactory = DOMCanvasFactory;\n\nasync function fetchData(url, asTypedArray = false) {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n\n    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n  }\n\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n\n    if (asTypedArray) {\n      request.responseType = \"arraybuffer\";\n    }\n\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n\n      if (request.status === 200 || request.status === 0) {\n        let data;\n\n        if (asTypedArray && request.response) {\n          data = new Uint8Array(request.response);\n        } else if (!asTypedArray && request.responseText) {\n          data = (0, _util.stringToBytes)(request.responseText);\n        }\n\n        if (data) {\n          resolve(data);\n          return;\n        }\n      }\n\n      reject(new Error(request.statusText));\n    };\n\n    request.send(null);\n  });\n}\n\nclass DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url, this.isCompressed).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n\n}\n\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\nclass DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url, true);\n  }\n\n}\n\nexports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n\nclass DOMSVGFactory extends _base_factory.BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n\n}\n\nexports.DOMSVGFactory = DOMSVGFactory;\n\nclass PageViewport {\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n\n    if (rotation < 0) {\n      rotation += 360;\n    }\n\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  convertToViewportPoint(x, y) {\n    return _util.Util.applyTransform([x, y], this.transform);\n  }\n\n  convertToViewportRectangle(rect) {\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n\n  convertToPdfPoint(x, y) {\n    return _util.Util.applyInverseTransform([x, y], this.transform);\n  }\n\n}\n\nexports.PageViewport = PageViewport;\n\nclass RenderingCancelledException extends _util.BaseException {\n  constructor(msg, type) {\n    super(msg, \"RenderingCancelledException\");\n    this.type = type;\n  }\n\n}\n\nexports.RenderingCancelledException = RenderingCancelledException;\n\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\n\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\n\nfunction getFilenameFromUrl(url) {\n  const anchor = url.indexOf(\"#\");\n  const query = url.indexOf(\"?\");\n  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n}\n\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n\n  if (isDataScheme(url)) {\n    (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch (ex) {}\n    }\n  }\n\n  return suggestedFilename || defaultFilename;\n}\n\nclass StatTimer {\n  constructor() {\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  time(name) {\n    if (name in this.started) {\n      (0, _util.warn)(`Timer is already running for ${name}`);\n    }\n\n    this.started[name] = Date.now();\n  }\n\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      (0, _util.warn)(`Timer has not been started for ${name}`);\n    }\n\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n\n    for (const time of this.times) {\n      const name = time.name;\n\n      if (name.length > longest) {\n        longest = name.length;\n      }\n    }\n\n    for (const time of this.times) {\n      const duration = time.end - time.start;\n      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n    }\n\n    return outBuf.join(\"\");\n  }\n\n}\n\nexports.StatTimer = StatTimer;\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch (ex) {\n    return false;\n  }\n}\n\nfunction loadScript(src, removeScriptElement = false) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = src;\n\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n\n      resolve(evt);\n    };\n\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n\n    (document.head || document.documentElement).appendChild(script);\n  });\n}\n\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\n\nlet pdfDateStringRegex;\n\nclass PDFDateString {\n  static toDateObject(input) {\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n\n    if (!pdfDateStringRegex) {\n      pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    }\n\n    const matches = pdfDateStringRegex.exec(input);\n\n    if (!matches) {\n      return null;\n    }\n\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n\n}\n\nexports.PDFDateString = PDFDateString;\n\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation\n  });\n}\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    const canvas = this._createCanvas(width, height);\n\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\")\n    };\n  }\n\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n\n  _createCanvas(width, height) {\n    (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n  }\n\n}\n\nexports.BaseCanvasFactory = BaseCanvasFactory;\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = false\n  }) {\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n    }\n\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n\n  _fetchData(url, compressionType) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    if (this.constructor === BaseStandardFontDataFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n  }\n\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n    }\n\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetchData(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n\n  _fetchData(url) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n\nclass BaseSVGFactory {\n  constructor() {\n    if (this.constructor === BaseSVGFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n\n    const svg = this._createSVG(\"svg:svg\");\n\n    svg.setAttribute(\"version\", \"1.1\");\n    svg.setAttribute(\"width\", `${width}px`);\n    svg.setAttribute(\"height\", `${height}px`);\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n\n    return this._createSVG(type);\n  }\n\n  _createSVG(type) {\n    (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n  }\n\n}\n\nexports.BaseSVGFactory = BaseSVGFactory;\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FontLoader = exports.FontFaceObject = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass BaseFontLoader {\n  constructor({\n    docId,\n    onUnsupportedFeature,\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    if (this.constructor === BaseFontLoader) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n    }\n\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n    this.nativeFontFaces = [];\n    this.styleElement = null;\n  }\n\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.push(nativeFontFace);\n\n    this._document.fonts.add(nativeFontFace);\n  }\n\n  insertRule(rule) {\n    let styleElement = this.styleElement;\n\n    if (!styleElement) {\n      styleElement = this.styleElement = this._document.createElement(\"style\");\n      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n\n      this._document.documentElement.getElementsByTagName(\"head\")[0].appendChild(styleElement);\n    }\n\n    const styleSheet = styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n\n    this.nativeFontFaces.length = 0;\n\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n\n  async bind(font) {\n    if (font.attached || font.missingFile) {\n      return;\n    }\n\n    font.attached = true;\n\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          this._onUnsupportedFeature({\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n          });\n\n          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n\n      return;\n    }\n\n    const rule = font.createFontFaceRule();\n\n    if (rule) {\n      this.insertRule(rule);\n\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n\n        this._prepareFontLoadEvent([rule], [font], request);\n      });\n    }\n  }\n\n  _queueLoadingCallback(callback) {\n    (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n  }\n\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n\n  get isSyncFontLoadingSupported() {\n    (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n  }\n\n  get _loadTestFont() {\n    (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n  }\n\n  _prepareFontLoadEvent(rules, fontsToLoad, request) {\n    (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n  }\n\n}\n\nlet FontLoader;\nexports.FontLoader = FontLoader;\n{\n  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\n    constructor(params) {\n      super(params);\n      this.loadingContext = {\n        requests: [],\n        nextRequestId: 0\n      };\n      this.loadTestFontId = 0;\n    }\n\n    get isSyncFontLoadingSupported() {\n      let supported = false;\n\n      if (typeof navigator === \"undefined\") {\n        supported = true;\n      } else {\n        const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n        if (m?.[1] >= 14) {\n          supported = true;\n        }\n      }\n\n      return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n    }\n\n    _queueLoadingCallback(callback) {\n      function completeRequest() {\n        (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n        request.done = true;\n\n        while (context.requests.length > 0 && context.requests[0].done) {\n          const otherRequest = context.requests.shift();\n          setTimeout(otherRequest.callback, 0);\n        }\n      }\n\n      const context = this.loadingContext;\n      const request = {\n        id: `pdfjs-font-loading-${context.nextRequestId++}`,\n        done: false,\n        complete: completeRequest,\n        callback\n      };\n      context.requests.push(request);\n      return request;\n    }\n\n    get _loadTestFont() {\n      const getLoadTestFont = function () {\n        return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n      };\n\n      return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n    }\n\n    _prepareFontLoadEvent(rules, fonts, request) {\n      function int32(data, offset) {\n        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n      }\n\n      function spliceString(s, offset, remove, insert) {\n        const chunk1 = s.substring(0, offset);\n        const chunk2 = s.substring(offset + remove);\n        return chunk1 + insert + chunk2;\n      }\n\n      let i, ii;\n\n      const canvas = this._document.createElement(\"canvas\");\n\n      canvas.width = 1;\n      canvas.height = 1;\n      const ctx = canvas.getContext(\"2d\");\n      let called = 0;\n\n      function isFontReady(name, callback) {\n        called++;\n\n        if (called > 30) {\n          (0, _util.warn)(\"Load test font never loaded.\");\n          callback();\n          return;\n        }\n\n        ctx.font = \"30px \" + name;\n        ctx.fillText(\".\", 0, 20);\n        const imageData = ctx.getImageData(0, 0, 1, 1);\n\n        if (imageData.data[3] > 0) {\n          callback();\n          return;\n        }\n\n        setTimeout(isFontReady.bind(null, name, callback));\n      }\n\n      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n      let data = this._loadTestFont;\n      const COMMENT_OFFSET = 976;\n      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n      const CFF_CHECKSUM_OFFSET = 16;\n      const XXXX_VALUE = 0x58585858;\n      let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n      }\n\n      if (i < loadTestFontId.length) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n      }\n\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n      const url = `url(data:font/opentype;base64,${btoa(data)});`;\n      const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n      this.insertRule(rule);\n      const names = [];\n\n      for (const font of fonts) {\n        names.push(font.loadedName);\n      }\n\n      names.push(loadTestFontId);\n\n      const div = this._document.createElement(\"div\");\n\n      div.style.visibility = \"hidden\";\n      div.style.width = div.style.height = \"10px\";\n      div.style.position = \"absolute\";\n      div.style.top = div.style.left = \"0px\";\n\n      for (const name of names) {\n        const span = this._document.createElement(\"span\");\n\n        span.textContent = \"Hi\";\n        span.style.fontFamily = name;\n        div.appendChild(span);\n      }\n\n      this._document.body.appendChild(div);\n\n      isFontReady(loadTestFontId, () => {\n        div.remove();\n        request.complete();\n      });\n    }\n\n  };\n}\n\nclass FontFaceObject {\n  constructor(translatedData, {\n    isEvalSupported = true,\n    disableFontFace = false,\n    ignoreErrors = false,\n    onUnsupportedFeature,\n    fontRegistry = null\n  }) {\n    this.compiledGlyphs = Object.create(null);\n\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    let nativeFontFace;\n\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this);\n    }\n\n    return nativeFontFace;\n  }\n\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    const data = (0, _util.bytesToString)(this.data);\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    let rule;\n\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this, url);\n    }\n\n    return rule;\n  }\n\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n\n    let cmds;\n\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n\n      this._onUnsupportedFeature({\n        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n      });\n\n      (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n\n    if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\n      const jsBuf = [];\n\n      for (const current of cmds) {\n        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n      }\n\n      return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n    }\n\n    return this.compiledGlyphs[character] = function (c, size) {\n      for (const current of cmds) {\n        if (current.cmd === \"scale\") {\n          current.args = [size, -size];\n        }\n\n        c[current.cmd].apply(c, current.args);\n      }\n    };\n  }\n\n}\n\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\n\nvar _base_factory = __w_pdfjs_require__(6);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nvar _util = __w_pdfjs_require__(1);\n\nlet NodeCanvasFactory = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: NodeCanvasFactory\");\n  }\n\n};\nexports.NodeCanvasFactory = NodeCanvasFactory;\nlet NodeCMapReaderFactory = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: NodeCMapReaderFactory\");\n  }\n\n};\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\nlet NodeStandardFontDataFactory = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: NodeStandardFontDataFactory\");\n  }\n\n};\nexports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n\nif (_is_node.isNodeJS) {\n  const fetchData = function (url) {\n    return new Promise((resolve, reject) => {\n      const fs = __webpack_require__(/*! fs */ \"?fe90\");\n\n      fs.readFile(url, (error, data) => {\n        if (error || !data) {\n          reject(new Error(error));\n          return;\n        }\n\n        resolve(new Uint8Array(data));\n      });\n    });\n  };\n\n  exports.NodeCanvasFactory = NodeCanvasFactory = class extends _base_factory.BaseCanvasFactory {\n    _createCanvas(width, height) {\n      const Canvas = __webpack_require__(/*! canvas */ \"?4a14\");\n\n      return Canvas.createCanvas(width, height);\n    }\n\n  };\n  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _base_factory.BaseCMapReaderFactory {\n    _fetchData(url, compressionType) {\n      return fetchData(url).then(data => {\n        return {\n          cMapData: data,\n          compressionType\n        };\n      });\n    }\n\n  };\n  exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory = class extends _base_factory.BaseStandardFontDataFactory {\n    _fetchData(url) {\n      return fetchData(url);\n    }\n\n  };\n}\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationStorage = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass AnnotationStorage {\n  constructor() {\n    this._storage = new Map();\n    this._timeStamp = Date.now();\n    this._modified = false;\n    this.onSetModified = null;\n    this.onResetModified = null;\n  }\n\n  getValue(key, defaultValue) {\n    const value = this._storage.get(key);\n\n    if (value === undefined) {\n      return defaultValue;\n    }\n\n    return Object.assign(defaultValue, value);\n  }\n\n  setValue(key, value) {\n    const obj = this._storage.get(key);\n\n    let modified = false;\n\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n\n      this._storage.set(key, value);\n    }\n\n    if (modified) {\n      this._timeStamp = Date.now();\n\n      this._setModified();\n    }\n  }\n\n  getAll() {\n    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;\n  }\n\n  get size() {\n    return this._storage.size;\n  }\n\n  _setModified() {\n    if (!this._modified) {\n      this._modified = true;\n\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n\n  resetModified() {\n    if (this._modified) {\n      this._modified = false;\n\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n\n  get serializable() {\n    return this._storage.size > 0 ? this._storage : null;\n  }\n\n  get lastModified() {\n    return this._timeStamp.toString();\n  }\n\n}\n\nexports.AnnotationStorage = AnnotationStorage;\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanvasGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _pattern_helper = __w_pdfjs_require__(11);\n\nvar _display_utils = __w_pdfjs_require__(5);\n\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst MAX_GROUP_SIZE = 4096;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst COMPILE_TYPE3_GLYPHS = true;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nconst LINEWIDTH_SCALE_FACTOR = 1.000001;\n\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n\n  ctx.save = function ctxSave() {\n    destCtx.save();\n\n    this.__originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n\n    this.__originalRestore();\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n\n    this.__originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n\n    this.__originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n\n    this.__originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n\n    this.__originalRotate(angle);\n  };\n\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n\n    this.__originalClip(rule);\n  };\n\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n\n    this.__originalMoveTo(x, y);\n  };\n\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n\n    this.__originalLineTo(x, y);\n  };\n\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n\n    this.__originalRect(x, y, width, height);\n  };\n\n  ctx.closePath = function () {\n    destCtx.closePath();\n\n    this.__originalClosePath();\n  };\n\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n\n    this.__originalBeginPath();\n  };\n}\n\nfunction addContextCurrentTransform(ctx) {\n  if (ctx._transformStack) {\n    ctx._transformStack = [];\n  }\n\n  if (ctx.mozCurrentTransform) {\n    return;\n  }\n\n  ctx._originalSave = ctx.save;\n  ctx._originalRestore = ctx.restore;\n  ctx._originalRotate = ctx.rotate;\n  ctx._originalScale = ctx.scale;\n  ctx._originalTranslate = ctx.translate;\n  ctx._originalTransform = ctx.transform;\n  ctx._originalSetTransform = ctx.setTransform;\n  ctx._originalResetTransform = ctx.resetTransform;\n  ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n  ctx._transformStack = [];\n\n  try {\n    const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), \"lineWidth\");\n    ctx._setLineWidth = desc.set;\n    ctx._getLineWidth = desc.get;\n    Object.defineProperty(ctx, \"lineWidth\", {\n      set: function setLineWidth(width) {\n        this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);\n      },\n      get: function getLineWidth() {\n        return this._getLineWidth();\n      }\n    });\n  } catch (_) {}\n\n  Object.defineProperty(ctx, \"mozCurrentTransform\", {\n    get: function getCurrentTransform() {\n      return this._transformMatrix;\n    }\n  });\n  Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\n    get: function getCurrentTransformInverse() {\n      const [a, b, c, d, e, f] = this._transformMatrix;\n      const ad_bc = a * d - b * c;\n      const bc_ad = b * c - a * d;\n      return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n    }\n  });\n\n  ctx.save = function ctxSave() {\n    const old = this._transformMatrix;\n\n    this._transformStack.push(old);\n\n    this._transformMatrix = old.slice(0, 6);\n\n    this._originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    if (this._transformStack.length === 0) {\n      (0, _util.warn)(\"Tried to restore a ctx when the stack was already empty.\");\n    }\n\n    const prev = this._transformStack.pop();\n\n    if (prev) {\n      this._transformMatrix = prev;\n\n      this._originalRestore();\n    }\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    const m = this._transformMatrix;\n    m[4] = m[0] * x + m[2] * y + m[4];\n    m[5] = m[1] * x + m[3] * y + m[5];\n\n    this._originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    const m = this._transformMatrix;\n    m[0] *= x;\n    m[1] *= x;\n    m[2] *= y;\n    m[3] *= y;\n\n    this._originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    const m = this._transformMatrix;\n    this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n\n    ctx._originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    this._transformMatrix = [a, b, c, d, e, f];\n\n    ctx._originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    this._transformMatrix = [1, 0, 0, 1, 0, 0];\n\n    ctx._originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    const cosValue = Math.cos(angle);\n    const sinValue = Math.sin(angle);\n    const m = this._transformMatrix;\n    this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n\n    this._originalRotate(angle);\n  };\n}\n\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  getCanvas(id, width, height, trackTransform) {\n    let canvasEntry;\n\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n\n    if (trackTransform) {\n      addContextCurrentTransform(canvasEntry.context);\n    }\n\n    return canvasEntry;\n  }\n\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n\n}\n\nfunction compileType3Glyph(imgData) {\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  const width = imgData.width,\n        height = imgData.height,\n        width1 = width + 1;\n  let i, ii, j, j0;\n  const points = new Uint8Array(width1 * (height + 1));\n  const lineSize = width + 7 & ~7,\n        data0 = imgData.data;\n  const data = new Uint8Array(lineSize * height);\n  let pos = 0;\n\n  for (i = 0, ii = data0.length; i < ii; i++) {\n    const elem = data0[i];\n    let mask = 128;\n\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  let count = 0;\n  pos = 0;\n\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const outlines = [];\n\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n\n    while (p < end && !points[p]) {\n      p++;\n    }\n\n    if (p === end) {\n      continue;\n    }\n\n    const coords = [p % width1, i];\n    const p0 = p;\n    let type = points[p];\n\n    do {\n      const step = steps[type];\n\n      do {\n        p += step;\n      } while (!points[p]);\n\n      const pp = points[p];\n\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n\n      coords.push(p % width1, p / width1 | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n\n    outlines.push(coords);\n    --i;\n  }\n\n  const drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.beginPath();\n\n    for (let k = 0, kk = outlines.length; k < kk; k++) {\n      const o = outlines[k];\n      c.moveTo(o[0], o[1]);\n\n      for (let l = 2, ll = o.length; l < ll; l += 2) {\n        c.lineTo(o[l], o[l + 1]);\n      }\n    }\n\n    c.fill();\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nclass CanvasExtraState {\n  constructor(width, height) {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = null;\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  updatePathMinMax(transform, x, y) {\n    [x, y] = _util.Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3) {\n    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n\n    this.updatePathMinMax(transform, box[0], box[1]);\n    this.updatePathMinMax(transform, box[2], box[3]);\n  }\n\n  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n\n    if (pathType === _pattern_helper.PathType.STROKE) {\n      if (!transform) {\n        (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n      }\n\n      const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n      const xStrokePad = scale[0] * this.lineWidth / 2;\n      const yStrokePad = scale[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n\n    return box;\n  }\n\n  updateClipFromPath() {\n    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n\n  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n\n}\n\nfunction putBinaryImageData(ctx, imgData, transferMaps = null) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n      destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n  if (transferMaps) {\n    switch (transferMaps.length) {\n      case 1:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[0];\n        transferMapBlue = transferMaps[0];\n        transferMapGray = transferMaps[0];\n        break;\n\n      case 4:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[1];\n        transferMapBlue = transferMaps[2];\n        transferMapGray = transferMaps[3];\n        break;\n    }\n  }\n\n  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    let white = 0xffffffff;\n    let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n\n    if (transferMapGray) {\n      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n        [white, black] = [black, white];\n      }\n    }\n\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n\n      destPos = 0;\n\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < destPos; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\n\nfunction putBinaryImageMask(ctx, imgData) {\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    let destPos = 3;\n\n    for (let j = 0; j < thisChunkHeight; j++) {\n      let elem,\n          mask = 0;\n\n      for (let k = 0; k < width; k++) {\n        if (!mask) {\n          elem = src[srcPos++];\n          mask = 128;\n        }\n\n        dest[destPos] = elem & mask ? 0 : 255;\n        destPos += 4;\n        mask >>= 1;\n      }\n    }\n\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\n\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n\n  for (let i = 0, ii = properties.length; i < ii; i++) {\n    const property = properties[i];\n\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\n\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = \"#000000\";\n  ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n}\n\nfunction composeSMaskBackdrop(bytes, r0, g0, b0) {\n  const length = bytes.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = bytes[i];\n\n    if (alpha === 0) {\n      bytes[i - 3] = r0;\n      bytes[i - 2] = g0;\n      bytes[i - 1] = b0;\n    } else if (alpha < 255) {\n      const alpha_ = 255 - alpha;\n      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n    }\n  }\n}\n\nfunction composeSMaskAlpha(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  const scale = 1 / 255;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n    layerData[i] = layerData[i] * alpha * scale | 0;\n  }\n}\n\nfunction composeSMaskLuminosity(maskData, layerData, transferMap) {\n  const length = maskData.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n  }\n}\n\nfunction genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n  const hasBackdrop = !!backdrop;\n  const r0 = hasBackdrop ? backdrop[0] : 0;\n  const g0 = hasBackdrop ? backdrop[1] : 0;\n  const b0 = hasBackdrop ? backdrop[2] : 0;\n  let composeFn;\n\n  if (subtype === \"Luminosity\") {\n    composeFn = composeSMaskLuminosity;\n  } else {\n    composeFn = composeSMaskAlpha;\n  }\n\n  const PIXELS_TO_PROCESS = 1048576;\n  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n  for (let row = 0; row < height; row += chunkSize) {\n    const chunkHeight = Math.min(chunkSize, height - row);\n    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n\n    if (hasBackdrop) {\n      composeSMaskBackdrop(maskData.data, r0, g0, b0);\n    }\n\n    composeFn(maskData.data, layerData.data, transferMap);\n    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n  }\n}\n\nfunction composeSMask(ctx, smask, layerCtx, layerBox) {\n  const layerOffsetX = layerBox[0];\n  const layerOffsetY = layerBox[1];\n  const layerWidth = layerBox[2] - layerOffsetX;\n  const layerHeight = layerBox[3] - layerOffsetY;\n\n  if (layerWidth === 0 || layerHeight === 0) {\n    return;\n  }\n\n  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n  ctx.save();\n  ctx.globalAlpha = 1;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.drawImage(layerCtx.canvas, 0, 0);\n  ctx.restore();\n}\n\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n\n  if (interpolate !== undefined) {\n    return interpolate;\n  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n    return true;\n  }\n\n  return false;\n}\n\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\n\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n\n    if (canvasCtx) {\n      addContextCurrentTransform(canvasCtx);\n    }\n\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    this.ctx.save();\n    this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.restore();\n\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height, true);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n    }\n\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n\n    if (transform) {\n      this.ctx.transform.apply(this.ctx, transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n\n    this.ctx.transform.apply(this.ctx, viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = this.ctx.mozCurrentTransform.slice();\n    this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);\n\n    if (this.imageLayer) {\n      this.imageLayer.beginLayout();\n    }\n  }\n\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n\n    if (argsArrayLen === i) {\n      return i;\n    }\n\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n\n      fnId = fnArray[i];\n\n      if (fnId !== _util.OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n\n      i++;\n\n      if (i === argsArrayLen) {\n        return i;\n      }\n\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n\n        steps = 0;\n      }\n    }\n  }\n\n  endDrawing() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n\n    this.ctx.restore();\n\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n\n    if (this.imageLayer) {\n      this.imageLayer.endLayout();\n    }\n  }\n\n  _scaleImage(img, inverseTransform) {\n    const width = img.width;\n    const height = img.height;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n        paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n          newHeight = paintHeight;\n\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = Math.ceil(paintHeight / 2);\n        heightScale /= paintHeight / newHeight;\n      }\n\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const width = img.width,\n          height = img.height;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n    const maskCtx = maskCanvas.context;\n    putBinaryImageMask(maskCtx, img);\n    const objToCanvas = ctx.mozCurrentTransform;\n\n    let maskToCanvas = _util.Util.transform(objToCanvas, [1 / width, 0, 0, -1 / height, 0, 0]);\n\n    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n\n    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n\n    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n\n    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n\n    const drawnWidth = Math.ceil(rect[2] - rect[0]);\n    const drawnHeight = Math.ceil(rect[3] - rect[1]);\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight, true);\n    const fillCtx = fillCanvas.context;\n    const offsetX = Math.min(cord1[0], cord2[0]);\n    const offsetY = Math.min(cord1[1], cord2[1]);\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform.apply(fillCtx, maskToCanvas);\n\n    const scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);\n\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);\n    fillCtx.drawImage(scaled.img, 0, 0, scaled.img.width, scaled.img.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n\n    const inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);\n\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n\n  setLineWidth(width) {\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n\n  setRenderingIntent(intent) {}\n\n  setFlatness(flatness) {}\n\n  setGState(states) {\n    for (let i = 0, ii = states.length; i < ii; i++) {\n      const state = states[i];\n      const key = state[0];\n      const value = state[1];\n\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n\n        case \"CA\":\n          this.current.strokeAlpha = state[1];\n          break;\n\n        case \"ca\":\n          this.current.fillAlpha = state[1];\n          this.ctx.globalAlpha = state[1];\n          break;\n\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n\n        case \"TR\":\n          this.current.transferMaps = value;\n      }\n    }\n  }\n\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n\n  beginSMaskMode() {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n  }\n\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n\n    this.ctx._removeMirroring();\n\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n\n  save() {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n      this.suspendedCtx.save();\n    } else {\n      this.ctx.save();\n    }\n\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n\n  restore() {\n    if (this.stateStack.length === 0 && this.inSMaskMode) {\n      this.endSMaskMode();\n    }\n\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n\n      if (this.inSMaskMode) {\n        this.suspendedCtx.restore();\n        copyCtxState(this.suspendedCtx, this.ctx);\n      } else {\n        this.ctx.restore();\n      }\n\n      this.checkSMaskState();\n      this.pendingClip = null;\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  constructPath(ops, args) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n        y = current.y;\n    let startX, startY;\n\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, xw, yh);\n          ctx.closePath();\n          break;\n\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          break;\n\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          break;\n\n        case _util.OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          j += 6;\n          break;\n\n        case _util.OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n\n        case _util.OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], x, y, x, y);\n          j += 4;\n          break;\n\n        case _util.OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n\n    current.setCurrentPoint(x, y);\n  }\n\n  closePath() {\n    this.ctx.closePath();\n  }\n\n  stroke(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        const lineWidth = this.getSinglePixelWidth();\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);\n        ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n        ctx.stroke();\n        ctx.restore();\n      } else {\n        const lineWidth = this.getSinglePixelWidth();\n\n        if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {\n          ctx.save();\n          ctx.resetTransform();\n          ctx.lineWidth = Math.floor(this._combinedScaleFactor);\n          ctx.stroke();\n          ctx.restore();\n        } else {\n          ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n          ctx.stroke();\n        }\n      }\n    }\n\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n\n  fill(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);\n      needRestore = true;\n    }\n\n    const intersect = this.current.getClippedPathBoundingBox();\n\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n\n    if (needRestore) {\n      ctx.restore();\n    }\n\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n    this.consumePath();\n  }\n\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n\n  endPath() {\n    this.consumePath();\n  }\n\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n\n  beginText() {\n    this.current.textMatrix = _util.IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n\n    ctx.save();\n    ctx.beginPath();\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      ctx.setTransform.apply(ctx, path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n    }\n\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n\n    if (fontObj.isType3Font) {\n      return;\n    }\n\n    const name = fontObj.loadedName || \"sans-serif\";\n    let bold = \"normal\";\n\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    const typeface = `\"${name}\", ${fontObj.fallbackName}`;\n    let browserFontSize = size;\n\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n\n  paintChar(character, x, y, patternTransform, resetLineWidthToOne) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    let addToPath;\n\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n\n      if (patternTransform) {\n        ctx.setTransform.apply(ctx, patternTransform);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fill();\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (resetLineWidthToOne) {\n          ctx.resetTransform();\n          ctx.lineWidth = Math.floor(this._combinedScaleFactor);\n        }\n\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (resetLineWidthToOne) {\n          ctx.save();\n          ctx.moveTo(x, y);\n          ctx.resetTransform();\n          ctx.lineWidth = Math.floor(this._combinedScaleFactor);\n          ctx.strokeText(character, 0, 0);\n          ctx.restore();\n        } else {\n          ctx.strokeText(character, x, y);\n        }\n      }\n    }\n\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n      paths.push({\n        transform: ctx.mozCurrentTransform,\n        x,\n        y,\n        fontSize,\n        addToPath\n      });\n    }\n  }\n\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n\n    return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n\n    const fontSize = current.fontSize;\n\n    if (fontSize === 0) {\n      return undefined;\n    }\n\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    ctx.transform.apply(ctx, current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n\n    let patternTransform;\n\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);\n      patternTransform = ctx.mozCurrentTransform;\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n\n    let lineWidth = current.lineWidth;\n    let resetLineWidthToOne = false;\n    const scale = current.textMatrixScale;\n\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        this._cachedGetSinglePixelWidth = null;\n        lineWidth = this.getSinglePixelWidth();\n        resetLineWidthToOne = lineWidth < 0;\n      }\n    } else {\n      lineWidth /= scale;\n    }\n\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n\n    ctx.lineWidth = lineWidth;\n    let x = 0,\n        i;\n\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n\n      if (font.remeasure && width > 0) {\n        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);\n\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);\n          }\n        }\n      }\n\n      let charWidth;\n\n      if (vertical) {\n        charWidth = width * widthAdvanceScale - spacing * fontDirection;\n      } else {\n        charWidth = width * widthAdvanceScale + spacing * fontDirection;\n      }\n\n      x += charWidth;\n\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n\n  showType3Text(glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    ctx.transform.apply(ctx, current.textMatrix);\n    ctx.translate(current.x, current.y);\n    ctx.scale(textHScale, fontDirection);\n\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n      if (!operatorList) {\n        (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform.apply(ctx, fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n\n      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n      width = transformed[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n\n    ctx.restore();\n    this.processingType3 = null;\n  }\n\n  setCharWidth(xWidth, yWidth) {}\n\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.clip();\n    this.endPath();\n  }\n\n  getColorN_Pattern(IR) {\n    let pattern;\n\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => {\n          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);\n        }\n      };\n      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n\n    return pattern;\n  }\n\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n\n  setStrokeRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.strokeStyle = color;\n    this.current.strokeColor = color;\n  }\n\n  setFillRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.fillStyle = color;\n    this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n\n  _getPattern(objId, matrix = null) {\n    let pattern;\n\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n\n    return pattern;\n  }\n\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    this.save();\n\n    const pattern = this._getPattern(objId);\n\n    ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);\n    const inv = ctx.mozCurrentTransformInverse;\n\n    if (inv) {\n      const canvas = ctx.canvas;\n      const width = canvas.width;\n      const height = canvas.height;\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n\n  beginInlineImage() {\n    (0, _util.unreachable)(\"Should not call beginInlineImage\");\n  }\n\n  beginImageData() {\n    (0, _util.unreachable)(\"Should not call beginImageData\");\n  }\n\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform.apply(this, matrix);\n    }\n\n    this.baseTransform = this.ctx.mozCurrentTransform;\n\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[0], bbox[1]);\n      this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[2], bbox[3]);\n      this.clip();\n      this.endPath();\n    }\n  }\n\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n\n    const currentCtx = this.ctx;\n\n    if (!group.isolated) {\n      (0, _util.info)(\"TODO: Support non-isolated groups.\");\n    }\n\n    if (group.knockout) {\n      (0, _util.warn)(\"Knockout groups not supported.\");\n    }\n\n    const currentTransform = currentCtx.mozCurrentTransform;\n\n    if (group.matrix) {\n      currentCtx.transform.apply(currentCtx, group.matrix);\n    }\n\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n\n    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    let scaleX = 1,\n        scaleY = 1;\n\n    if (drawnWidth > MAX_GROUP_SIZE) {\n      scaleX = drawnWidth / MAX_GROUP_SIZE;\n      drawnWidth = MAX_GROUP_SIZE;\n    }\n\n    if (drawnHeight > MAX_GROUP_SIZE) {\n      scaleY = drawnHeight / MAX_GROUP_SIZE;\n      drawnHeight = MAX_GROUP_SIZE;\n    }\n\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.scale(1 / scaleX, 1 / scaleY);\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform.apply(groupCtx, currentTransform);\n\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        scaleX,\n        scaleY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    } else {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.scale(scaleX, scaleY);\n      currentCtx.save();\n    }\n\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = this.ctx.mozCurrentTransform;\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform.apply(this.ctx, currentMtx);\n\n      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n\n  beginAnnotations() {\n    this.save();\n\n    if (this.baseTransform) {\n      this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n    }\n  }\n\n  endAnnotations() {\n    this.restore();\n  }\n\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.save();\n\n    if (Array.isArray(rect) && rect.length === 4) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n\n        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform);\n\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        canvas.style.width = `calc(${width}px * var(--viewport-scale-factor))`;\n        canvas.style.height = `calc(${height}px * var(--viewport-scale-factor))`;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        addContextCurrentTransform(this.ctx);\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n    }\n\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform.apply(this, transform);\n    this.transform.apply(this, matrix);\n  }\n\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n\n    this.restore();\n  }\n\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const width = img.width,\n          height = img.height;\n    const glyph = this.processingType3;\n\n    if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n      if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n        glyph.compiled = compileType3Glyph({\n          data: img.data,\n          width,\n          height\n        });\n      } else {\n        glyph.compiled = null;\n      }\n    }\n\n    if (glyph?.compiled) {\n      glyph.compiled(ctx);\n      return;\n    }\n\n    const mask = this._createMaskCanvas(img);\n\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = ctx.mozCurrentTransform;\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n\n    const mask = this._createMaskCanvas(imgData);\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n\n      const [x, y] = _util.Util.applyTransform([0, 0], trans);\n\n      ctx.drawImage(mask.canvas, x, y);\n    }\n\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n\n    for (let i = 0, ii = images.length; i < ii; i++) {\n      const image = images[i];\n      const width = image.width,\n            height = image.height;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, image);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform.apply(ctx, image.transform);\n      ctx.scale(1, -1);\n      ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    this.paintInlineImageXObject(imgData);\n  }\n\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save();\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n\n    if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n      imgToPaint = tmpCanvas.canvas;\n    }\n\n    const scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);\n\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);\n    ctx.drawImage(scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n\n    if (this.imageLayer) {\n      const position = this.getCanvasPosition(0, -height);\n      this.imageLayer.appendImage({\n        imgData,\n        left: position[0],\n        top: position[1],\n        width: width / ctx.mozCurrentTransformInverse[0],\n        height: height / ctx.mozCurrentTransformInverse[3]\n      });\n    }\n\n    this.compose();\n    this.restore();\n  }\n\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const w = imgData.width;\n    const h = imgData.height;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n    const tmpCtx = tmpCanvas.context;\n    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n    for (let i = 0, ii = map.length; i < ii; i++) {\n      const entry = map[i];\n      ctx.save();\n      ctx.transform.apply(ctx, entry.transform);\n      ctx.scale(1, -1);\n      ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n      if (this.imageLayer) {\n        const position = this.getCanvasPosition(entry.x, entry.y);\n        this.imageLayer.appendImage({\n          imgData,\n          left: position[0],\n          top: position[1],\n          width: w,\n          height: h\n        });\n      }\n\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n\n  markPoint(tag) {}\n\n  markPointProps(tag, properties) {}\n\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n\n    this.contentVisible = this.isContentVisible();\n  }\n\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n\n  beginCompat() {}\n\n  endCompat() {}\n\n  consumePath(clipBox) {\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n\n    const ctx = this.ctx;\n\n    if (this.pendingClip) {\n      if (this.pendingClip === EO_CLIP) {\n        ctx.clip(\"evenodd\");\n      } else {\n        ctx.clip();\n      }\n\n      this.pendingClip = null;\n    }\n\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n\n  getSinglePixelWidth() {\n    if (this._cachedGetSinglePixelWidth === null) {\n      const m = this.ctx.mozCurrentTransform;\n      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n      const sqNorm1 = m[0] ** 2 + m[2] ** 2;\n      const sqNorm2 = m[1] ** 2 + m[3] ** 2;\n      const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;\n\n      if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {\n        this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);\n      } else if (absDet > Number.EPSILON) {\n        this._cachedGetSinglePixelWidth = pixelHeight;\n      } else {\n        this._cachedGetSinglePixelWidth = 1;\n      }\n    }\n\n    return this._cachedGetSinglePixelWidth;\n  }\n\n  getCanvasPosition(x, y) {\n    const transform = this.ctx.mozCurrentTransform;\n    return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n  }\n\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.CanvasGraphics = CanvasGraphics;\n\nfor (const op in _util.OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TilingPattern = exports.PathType = void 0;\nexports.getShadingPattern = getShadingPattern;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nexports.PathType = PathType;\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || typeof Path2D === \"undefined\") {\n    return;\n  }\n\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nclass BaseShadingPattern {\n  constructor() {\n    if (this.constructor === BaseShadingPattern) {\n      (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n    }\n  }\n\n  getPattern() {\n    (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n  }\n\n}\n\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n\n  _createGradient(ctx) {\n    let grad;\n\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n\n    return grad;\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform.apply(tmpCtx, owner.baseTransform);\n\n      if (this.matrix) {\n        tmpCtx.transform.apply(tmpCtx, this.matrix);\n      }\n\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n\n      try {\n        pattern.setTransform(domMatrix);\n      } catch (ex) {\n        (0, _util.warn)(`RadialAxialShadingPattern.getPattern: \"${ex?.message}\".`);\n      }\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n\n    return pattern;\n  }\n\n}\n\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n        colors = context.colors;\n  const bytes = data.data,\n        rowSize = data.width * 4;\n  let tmp;\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n  if (y1 >= y3) {\n    return;\n  }\n\n  const c1r = colors[c1],\n        c1g = colors[c1 + 1],\n        c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n        c2g = colors[c2 + 1],\n        c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n        c3g = colors[c3 + 1],\n        c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n        maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      let k;\n\n      if (y < y1) {\n        k = 0;\n      } else {\n        k = (y1 - y) / (y1 - y2);\n      }\n\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n\n    let k;\n\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\n\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n\n      break;\n\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\n\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n\n    if (backgroundColor) {\n      const bytes = data.data;\n\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n\n    if (pathType === PathType.SHADING) {\n      scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n    } else {\n      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n      if (this.matrix) {\n        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform.apply(ctx, owner.baseTransform);\n\n      if (this.matrix) {\n        ctx.transform.apply(ctx, this.matrix);\n      }\n    }\n\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n\n}\n\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n\n}\n\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\n\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\n\nclass TilingPattern {\n  static get MAX_PATTERN_SIZE() {\n    return (0, _util.shadow)(this, \"MAX_PATTERN_SIZE\", 3000);\n  }\n\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n\n  createPatternCanvas(owner) {\n    const operatorList = this.operatorList;\n    const bbox = this.bbox;\n    const xstep = this.xstep;\n    const ystep = this.ystep;\n    const paintType = this.paintType;\n    const tilingType = this.tilingType;\n    const color = this.color;\n    const canvasGraphicsFactory = this.canvasGraphicsFactory;\n    (0, _util.info)(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n          y0 = bbox[1],\n          x1 = bbox[2],\n          y1 = bbox[3];\n\n    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    let adjustedX0 = x0;\n    let adjustedY0 = y0;\n    let adjustedX1 = x1;\n    let adjustedY1 = y1;\n\n    if (x0 < 0) {\n      adjustedX0 = 0;\n      adjustedX1 += Math.abs(x0);\n    }\n\n    if (y0 < 0) {\n      adjustedY0 = 0;\n      adjustedY1 += Math.abs(y0);\n    }\n\n    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n    graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: adjustedX0,\n      offsetY: adjustedY0\n    };\n  }\n\n  getSizeAndScale(step, realOutputSize, scale) {\n    step = Math.abs(step);\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n\n    return {\n      scale,\n      size\n    };\n  }\n\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.clip();\n    graphics.endPath();\n  }\n\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n          current = graphics.current;\n\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n\n      case PaintType.UNCOLORED:\n        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n\n      default:\n        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n\n    if (pathType !== PathType.SHADING) {\n      matrix = _util.Util.transform(matrix, owner.baseTransform);\n\n      if (this.matrix) {\n        matrix = _util.Util.transform(matrix, this.matrix);\n      }\n    }\n\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n\n    try {\n      pattern.setTransform(domMatrix);\n    } catch (ex) {\n      (0, _util.warn)(`TilingPattern.getPattern: \"${ex?.message}\".`);\n    }\n\n    return pattern;\n  }\n\n}\n\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GlobalWorkerOptions = void 0;\nconst GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MessageHandler = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\n\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n\n    case \"PasswordException\":\n      return new _util.PasswordException(reason.message, reason.code);\n\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n\n      if (data.stream) {\n        this._processStreamMessage(data);\n\n        return;\n      }\n\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n\n        delete this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n\n        return;\n      }\n\n      const action = this.actionHandler[data.action];\n\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n\n      if (data.streamId) {\n        this._createStreamSink(data);\n\n        return;\n      }\n\n      action(data.data);\n    };\n\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n\n    ah[actionName] = handler;\n  }\n\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = (0, _util.createPromiseCapability)();\n    this.callbackCapabilities[callbackId] = capability;\n\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n\n    return capability.promise;\n  }\n\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n          sourceName = this.sourceName,\n          targetName = this.targetName,\n          comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n\n  _createStreamSink(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const self = this,\n          action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = (0, _util.createPromiseCapability)();\n          this.ready = this.sinkCapability.promise;\n        }\n\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n\n      error(reason) {\n        (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n\n      sinkCapability: (0, _util.createPromiseCapability)(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n\n  _processStreamMessage(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n          streamSink = this.streamSinks[streamId];\n\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull && streamSink.onPull());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n\n      case StreamKind.ENQUEUE:\n        (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.controller.enqueue(data.chunk);\n        break;\n\n      case StreamKind.CLOSE:\n        (0, _util.assert)(streamController, \"close should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.isClosed = true;\n        streamController.controller.close();\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.ERROR:\n        (0, _util.assert)(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n\n  async _deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);\n    delete this.streamControllers[streamId];\n  }\n\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n}\n\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Metadata = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass Metadata {\n  #metadataMap;\n  #data;\n\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n\n  getRaw() {\n    return this.#data;\n  }\n\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n\n  getAll() {\n    return (0, _util.objectFromMap)(this.#metadataMap);\n  }\n\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n\n}\n\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.OptionalContentConfig = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass OptionalContentGroup {\n  constructor(name, intent) {\n    this.visible = true;\n    this.name = name;\n    this.intent = intent;\n  }\n\n}\n\nclass OptionalContentConfig {\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n    this._order = null;\n    this._groups = new Map();\n\n    if (data === null) {\n      return;\n    }\n\n    this.name = data.name;\n    this.creator = data.creator;\n    this._order = data.order;\n\n    for (const group of data.groups) {\n      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n    }\n\n    if (data.baseState === \"OFF\") {\n      for (const group of this._groups) {\n        group.visible = false;\n      }\n    }\n\n    for (const on of data.on) {\n      this._groups.get(on).visible = true;\n    }\n\n    for (const off of data.off) {\n      this._groups.get(off).visible = false;\n    }\n  }\n\n  _evaluateVisibilityExpression(array) {\n    const length = array.length;\n\n    if (length < 2) {\n      return true;\n    }\n\n    const operator = array[0];\n\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n\n      if (Array.isArray(element)) {\n        state = this._evaluateVisibilityExpression(element);\n      } else if (this._groups.has(element)) {\n        state = this._groups.get(element).visible;\n      } else {\n        (0, _util.warn)(`Optional content group not found: ${element}`);\n        return true;\n      }\n\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n\n          break;\n\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n\n          break;\n\n        case \"Not\":\n          return !state;\n\n        default:\n          return true;\n      }\n    }\n\n    return operator === \"And\";\n  }\n\n  isVisible(group) {\n    if (this._groups.size === 0) {\n      return true;\n    }\n\n    if (!group) {\n      (0, _util.warn)(\"Optional content group not defined.\");\n      return true;\n    }\n\n    if (group.type === \"OCG\") {\n      if (!this._groups.has(group.id)) {\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n\n      return this._groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this._evaluateVisibilityExpression(group.expression);\n      }\n\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this._groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this._groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this._groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this._groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\n    return true;\n  }\n\n  setVisibility(id, visible = true) {\n    if (!this._groups.has(id)) {\n      (0, _util.warn)(`Optional content group not found: ${id}`);\n      return;\n    }\n\n    this._groups.get(id).visible = !!visible;\n  }\n\n  getOrder() {\n    if (!this._groups.size) {\n      return null;\n    }\n\n    if (this._order) {\n      return this._order.slice();\n    }\n\n    return Array.from(this._groups.keys());\n  }\n\n  getGroups() {\n    return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;\n  }\n\n  getGroup(id) {\n    return this._groups.get(id) || null;\n  }\n\n}\n\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFDataTransportStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(5);\n\nclass PDFDataTransportStream {\n  constructor(params, pdfDataRangeTransport) {\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    this._contentDispositionFilename = params.contentDispositionFilename || null;\n    const initialData = params.initialData;\n\n    if (initialData?.length > 0) {\n      const buffer = new Uint8Array(initialData).buffer;\n\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _onReceiveData(args) {\n    const buffer = new Uint8Array(args.chunk).buffer;\n\n    if (args.begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== args.begin) {\n          return false;\n        }\n\n        rangeReader._enqueue(buffer);\n\n        return true;\n      });\n\n      (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      const firstReader = this._rangeReaders[0];\n\n      if (firstReader?.onProgress) {\n        firstReader.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    } else {\n      const fullReader = this._fullRequestReader;\n\n      if (fullReader?.onProgress) {\n        fullReader.onProgress({\n          loaded: evt.loaded,\n          total: evt.total\n        });\n      }\n    }\n  }\n\n  _onProgressiveDone() {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.progressiveDone();\n    }\n\n    this._progressiveDone = true;\n  }\n\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n    this._rangeReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n\n    this._pdfDataRangeTransport.abort();\n  }\n\n}\n\nexports.PDFDataTransportStream = PDFDataTransportStream;\n\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n\n    this._loaded += chunk.byteLength;\n  }\n\n  get headersReady() {\n    return this._headersReady;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n\n    this._done = true;\n  }\n\n}\n\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n\n      this._requests.length = 0;\n    }\n\n    this._done = true;\n\n    this._stream._removeRangeReader(this);\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._stream._removeRangeReader(this);\n  }\n\n}\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaText = void 0;\n\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n\n      let str = null;\n      const name = node.name;\n\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n\n      if (!node.children) {\n        return;\n      }\n\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n\n    walk(xfa);\n    return output;\n  }\n\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n\n}\n\nexports.XfaText = XfaText;\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationLayer = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(5);\n\nvar _annotation_storage = __w_pdfjs_require__(9);\n\nvar _scripting_utils = __w_pdfjs_require__(19);\n\nvar _xfa_layer = __w_pdfjs_require__(20);\n\nconst DEFAULT_TAB_INDEX = 1000;\nconst GetElementsByNameSet = new WeakSet();\n\nfunction getRectDims(rect) {\n  return {\n    width: rect[2] - rect[0],\n    height: rect[3] - rect[1]\n  };\n}\n\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n\n    switch (subtype) {\n      case _util.AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n\n      case _util.AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n\n      case _util.AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n\n            return new PushButtonWidgetAnnotationElement(parameters);\n\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n        }\n\n        return new WidgetAnnotationElement(parameters);\n\n      case _util.AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n\n      case _util.AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n\n      case _util.AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n\n      case _util.AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n\n      case _util.AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n\n      case _util.AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n\n      case _util.AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n\n      case _util.AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n\n      case _util.AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n\n      case _util.AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n\n      case _util.AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n\n}\n\nclass AnnotationElement {\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this._mouseState = parameters.mouseState;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n\n    if (createQuadrilaterals) {\n      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n    }\n  }\n\n  _createContainer(ignoreBorder = false) {\n    const data = this.data,\n          page = this.page,\n          viewport = this.viewport;\n    const container = document.createElement(\"section\");\n    let {\n      width,\n      height\n    } = getRectDims(data.rect);\n    container.setAttribute(\"data-annotation-id\", data.id);\n\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n    if (data.hasOwnCanvas) {\n      const transform = viewport.transform.slice();\n\n      const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(transform);\n\n      width = Math.ceil(width * scaleX);\n      height = Math.ceil(height * scaleY);\n      rect[0] *= scaleX;\n      rect[1] *= scaleY;\n\n      for (let i = 0; i < 4; i++) {\n        transform[i] = Math.sign(transform[i]);\n      }\n\n      container.style.transform = `matrix(${transform.join(\",\")})`;\n    } else {\n      container.style.transform = `matrix(${viewport.transform.join(\",\")})`;\n    }\n\n    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;\n\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n\n      if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\n        width -= 2 * data.borderStyle.width;\n        height -= 2 * data.borderStyle.width;\n      }\n\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `${horizontalRadius}px / ${verticalRadius}px`;\n        container.style.borderRadius = radius;\n      }\n\n      switch (data.borderStyle.style) {\n        case _util.AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = \"solid\";\n          break;\n\n        case _util.AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = \"dashed\";\n          break;\n\n        case _util.AnnotationBorderStyleType.BEVELED:\n          (0, _util.warn)(\"Unimplemented border style: beveled\");\n          break;\n\n        case _util.AnnotationBorderStyleType.INSET:\n          (0, _util.warn)(\"Unimplemented border style: inset\");\n          break;\n\n        case _util.AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = \"solid\";\n          break;\n\n        default:\n          break;\n      }\n\n      const borderColor = data.borderColor || data.color || null;\n\n      if (borderColor) {\n        container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n      } else {\n        container.style.borderWidth = 0;\n      }\n    }\n\n    container.style.left = `${rect[0]}px`;\n    container.style.top = `${rect[1]}px`;\n\n    if (data.hasOwnCanvas) {\n      container.style.width = container.style.height = \"auto\";\n    } else {\n      container.style.width = `${width}px`;\n      container.style.height = `${height}px`;\n    }\n\n    return container;\n  }\n\n  _createQuadrilaterals(ignoreBorder = false) {\n    if (!this.data.quadPoints) {\n      return null;\n    }\n\n    const quadrilaterals = [];\n    const savedRect = this.data.rect;\n\n    for (const quadPoint of this.data.quadPoints) {\n      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n      quadrilaterals.push(this._createContainer(ignoreBorder));\n    }\n\n    this.data.rect = savedRect;\n    return quadrilaterals;\n  }\n\n  _createPopup(trigger, data) {\n    let container = this.container;\n\n    if (this.quadrilaterals) {\n      trigger = trigger || this.quadrilaterals;\n      container = this.quadrilaterals[0];\n    }\n\n    if (!trigger) {\n      trigger = document.createElement(\"div\");\n      trigger.style.height = container.style.height;\n      trigger.style.width = container.style.width;\n      container.appendChild(trigger);\n    }\n\n    const popupElement = new PopupElement({\n      container,\n      trigger,\n      color: data.color,\n      titleObj: data.titleObj,\n      modificationDate: data.modificationDate,\n      contentsObj: data.contentsObj,\n      richText: data.richText,\n      hideWrapper: true\n    });\n    const popup = popupElement.render();\n    popup.style.left = container.style.width;\n    container.appendChild(popup);\n  }\n\n  _renderQuadrilaterals(className) {\n    for (const quadrilateral of this.quadrilaterals) {\n      quadrilateral.className = className;\n    }\n\n    return this.quadrilaterals;\n  }\n\n  render() {\n    (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n  }\n\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n\n          if (id === skipId) {\n            continue;\n          }\n\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.getElementById(id);\n\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n\n      return fields;\n    }\n\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        id,\n        exportValue\n      } = domElement;\n\n      if (id === skipId) {\n        continue;\n      }\n\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n\n    return fields;\n  }\n\n  static get platform() {\n    const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n    return (0, _util.shadow)(this, \"platform\", {\n      isWin: platform.includes(\"Win\"),\n      isMac: platform.includes(\"Mac\")\n    });\n  }\n\n}\n\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions[\"Mouse Up\"] || parameters.data.actions[\"Mouse Down\"]));\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n\n    if (data.url) {\n      if (!linkService.addLinkAttributes) {\n        (0, _util.warn)(\"LinkAnnotationElement.render - missing `addLinkAttributes`-method on the `linkService`-instance.\");\n      }\n\n      linkService.addLinkAttributes?.(link, data.url, data.newWindow);\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n    } else {\n      let hasClickAction = false;\n\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        hasClickAction = true;\n\n        this._bindJSAction(link, data);\n      }\n\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n      } else if (!hasClickAction) {\n        this._bindLink(link, \"\");\n      }\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => {\n        const linkElement = index === 0 ? link : link.cloneNode();\n        quadrilateral.appendChild(linkElement);\n        return quadrilateral;\n      });\n    }\n\n    this.container.className = \"linkAnnotation\";\n    this.container.appendChild(link);\n    return this.container;\n  }\n\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n\n      return false;\n    };\n\n    if (destination || destination === \"\") {\n      link.className = \"internalLink\";\n    }\n  }\n\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n\n    link.className = \"internalLink\";\n  }\n\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n\n      if (!jsName) {\n        continue;\n      }\n\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n\n    link.className = \"internalLink\";\n  }\n\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n\n    link.className = \"internalLink\";\n\n    if (!this._fieldObjects) {\n      (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n\n      return;\n    }\n\n    link.onclick = () => {\n      if (otherClickAction) {\n        otherClickAction();\n      }\n\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n\n      const storage = this.annotationStorage;\n      const allIds = [];\n\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value,\n                valueAsString: value\n              });\n              break;\n            }\n\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          default:\n            continue;\n        }\n\n        const domElement = document.getElementById(id);\n\n        if (!domElement || !GetElementsByNameSet.has(domElement)) {\n          continue;\n        }\n\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n\n      return false;\n    };\n  }\n\n}\n\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    this.container.className = \"textAnnotation\";\n    const image = document.createElement(\"img\");\n    image.style.height = this.container.style.height;\n    image.style.width = this.container.style.width;\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.alt = \"[{{type}} Annotation]\";\n    image.dataset.l10nId = \"text_annotation_type\";\n    image.dataset.l10nArgs = JSON.stringify({\n      type: this.data.name\n    });\n\n    if (!this.data.hasPopup) {\n      this._createPopup(image, this.data);\n    }\n\n    this.container.appendChild(image);\n    return this.container;\n  }\n\n}\n\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    if (this.data.alternativeText) {\n      this.container.title = this.data.alternativeText;\n    }\n\n    return this.container;\n  }\n\n  _getKeyModifier(event) {\n    const {\n      isWin,\n      isMac\n    } = AnnotationElement.platform;\n    return isWin && event.ctrlKey || isMac && event.metaKey;\n  }\n\n  _setEventListener(element, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n\n  _setEventListeners(element, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        this._setEventListener(element, baseName, eventName, getter);\n      }\n    }\n  }\n\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n  }\n\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));\n    };\n\n    const commonActions = {\n      display: event => {\n        const hidden = event.detail.display % 2 === 1;\n        event.target.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden,\n          print: event.detail.display === 0 || event.detail.display === 3\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          print: event.detail.print\n        });\n      },\n      hidden: event => {\n        event.target.style.visibility = event.detail.hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden: event.detail.hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        if (event.detail.readonly) {\n          event.target.setAttribute(\"readonly\", \"\");\n        } else {\n          event.target.removeAttribute(\"readonly\");\n        }\n      },\n      required: event => {\n        if (event.detail.required) {\n          event.target.setAttribute(\"required\", \"\");\n        } else {\n          event.target.removeAttribute(\"required\");\n        }\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      }\n    };\n\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n\n      if (action) {\n        action(jsEvent);\n      }\n    }\n  }\n\n}\n\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.className = \"textWidgetAnnotation\";\n    let element = null;\n\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue,\n        valueAsString: this.data.fieldValue\n      });\n      const textContent = storedData.valueAsString || storedData.value || \"\";\n      const elementData = {\n        userValue: null,\n        formattedValue: null\n      };\n\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = textContent;\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", textContent);\n      }\n\n      GetElementsByNameSet.add(element);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n      elementData.userValue = textContent;\n      element.setAttribute(\"id\", id);\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue || \"\";\n        element.value = elementData.userValue = defaultValue;\n        delete elementData.formattedValue;\n      });\n\n      let blurListener = event => {\n        if (elementData.formattedValue) {\n          event.target.value = elementData.formattedValue;\n        }\n\n        event.target.scrollLeft = 0;\n      };\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.userValue) {\n            event.target.value = elementData.userValue;\n          }\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value || \"\";\n              storage.setValue(id, {\n                value: elementData.userValue.toString()\n              });\n\n              if (!elementData.formattedValue) {\n                event.target.value = elementData.userValue;\n              }\n            },\n\n            valueAsString(event) {\n              elementData.formattedValue = event.detail.valueAsString || \"\";\n\n              if (event.target !== document.activeElement) {\n                event.target.value = elementData.formattedValue;\n              }\n\n              storage.setValue(id, {\n                formattedValue: elementData.formattedValue\n              });\n            },\n\n            selRange(event) {\n              const [selStart, selEnd] = event.detail.selRange;\n\n              if (selStart >= 0 && selEnd < event.target.value.length) {\n                event.target.setSelectionRange(selStart, selEnd);\n              }\n            }\n\n          };\n\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          let commitKey = -1;\n\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\") {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            commitKey = 3;\n          }\n\n          if (commitKey === -1) {\n            return;\n          }\n\n          elementData.userValue = event.target.value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value: event.target.value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          elementData.userValue = event.target.value;\n\n          if (this._mouseState.isDown) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value: event.target.value,\n                willCommit: true,\n                commitKey: 1,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n\n          _blurListener(event);\n        });\n\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            elementData.formattedValue = \"\";\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data,\n                willCommit: false,\n                selStart: selectionStart,\n                selEnd: selectionEnd\n              }\n            });\n          });\n        }\n\n        this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n\n      if (this.data.maxLen !== null) {\n        element.maxLength = this.data.maxLen;\n      }\n\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / this.data.maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n    }\n\n    this._setTextStyle(element);\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontSize,\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const style = element.style;\n\n    if (fontSize) {\n      style.fontSize = `${fontSize}px`;\n    }\n\n    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n\n}\n\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    this.container.className = \"buttonWidgetAnnotation checkBox\";\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.disabled = data.readOnly;\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.setAttribute(\"id\", id);\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n}\n\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"buttonWidgetAnnotation radioButton\";\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.disabled = data.readOnly;\n    element.type = \"radio\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.setAttribute(\"id\", id);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n}\n\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n\n  render() {\n    const container = super.render();\n    container.className = \"buttonWidgetAnnotation pushButton\";\n\n    if (this.data.alternativeText) {\n      container.title = this.data.alternativeText;\n    }\n\n    return container;\n  }\n\n}\n\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"choiceWidgetAnnotation\";\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    storage.getValue(id, {\n      value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined\n    });\n    let {\n      fontSize\n    } = this.data.defaultAppearanceData;\n\n    if (!fontSize) {\n      fontSize = 9;\n    }\n\n    const fontSizeStyle = `calc(${fontSize}px * var(--zoom-factor))`;\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.disabled = this.data.readOnly;\n    selectElement.name = this.data.fieldName;\n    selectElement.setAttribute(\"id\", id);\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n    selectElement.style.fontSize = `${fontSize}px`;\n\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n\n      if (this.data.combo) {\n        optionElement.style.fontSize = fontSizeStyle;\n      }\n\n      if (this.data.fieldValue.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n      }\n\n      selectElement.appendChild(optionElement);\n    }\n\n    const getValue = (event, isExport) => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const options = event.target.options;\n\n      if (!event.target.multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => {\n        return {\n          displayValue: option.textContent,\n          exportValue: option.value\n        };\n      });\n    };\n\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n          },\n\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            selectElement.insertBefore(optionElement, selectElement.children[index]);\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          items(event) {\n            const {\n              items\n            } = event.detail;\n\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.appendChild(optionElement);\n            }\n\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(event, true);\n        const value = getValue(event, false);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value,\n            changeEx: exportValue,\n            willCommit: true,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n\n      this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"]], event => event.target.checked);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(event)\n        });\n      });\n    }\n\n    this._setBackgroundColor(selectElement);\n\n    this.container.appendChild(selectElement);\n    return this.container;\n  }\n\n}\n\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    const IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n    this.container.className = \"popupAnnotation\";\n\n    if (IGNORE_TYPES.includes(this.data.parentType)) {\n      return this.container;\n    }\n\n    const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\n    const parentElements = this.layer.querySelectorAll(selector);\n\n    if (parentElements.length === 0) {\n      return this.container;\n    }\n\n    const popup = new PopupElement({\n      container: this.container,\n      trigger: Array.from(parentElements),\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText\n    });\n    const page = this.page;\n\n    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n\n    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n    const popupTop = rect[1];\n    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;\n    this.container.style.left = `${popupLeft}px`;\n    this.container.style.top = `${popupTop}px`;\n    this.container.appendChild(popup.render());\n    return this.container;\n  }\n\n}\n\nclass PopupElement {\n  constructor(parameters) {\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.titleObj = parameters.titleObj;\n    this.modificationDate = parameters.modificationDate;\n    this.contentsObj = parameters.contentsObj;\n    this.richText = parameters.richText;\n    this.hideWrapper = parameters.hideWrapper || false;\n    this.pinned = false;\n  }\n\n  render() {\n    const BACKGROUND_ENLIGHT = 0.7;\n    const wrapper = document.createElement(\"div\");\n    wrapper.className = \"popupWrapper\";\n    this.hideElement = this.hideWrapper ? wrapper : this.container;\n    this.hideElement.hidden = true;\n    const popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    const color = this.color;\n\n    if (color) {\n      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n    }\n\n    const title = document.createElement(\"h1\");\n    title.dir = this.titleObj.dir;\n    title.textContent = this.titleObj.str;\n    popup.appendChild(title);\n\n    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n    if (dateObject) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.className = \"popupDate\";\n      modificationDate.textContent = \"{{date}}, {{time}}\";\n      modificationDate.dataset.l10nId = \"annotation_date_string\";\n      modificationDate.dataset.l10nArgs = JSON.stringify({\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString()\n      });\n      popup.appendChild(modificationDate);\n    }\n\n    if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {\n      _xfa_layer.XfaLayer.render({\n        xfaHtml: this.richText.html,\n        intent: \"richText\",\n        div: popup\n      });\n\n      popup.lastChild.className = \"richText popupContent\";\n    } else {\n      const contents = this._formatContents(this.contentsObj);\n\n      popup.appendChild(contents);\n    }\n\n    if (!Array.isArray(this.trigger)) {\n      this.trigger = [this.trigger];\n    }\n\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this._toggle.bind(this));\n      element.addEventListener(\"mouseover\", this._show.bind(this, false));\n      element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n    }\n\n    popup.addEventListener(\"click\", this._hide.bind(this, true));\n    wrapper.appendChild(popup);\n    return wrapper;\n  }\n\n  _formatContents({\n    str,\n    dir\n  }) {\n    const p = document.createElement(\"p\");\n    p.className = \"popupContent\";\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.appendChild(document.createTextNode(line));\n\n      if (i < ii - 1) {\n        p.appendChild(document.createElement(\"br\"));\n      }\n    }\n\n    return p;\n  }\n\n  _toggle() {\n    if (this.pinned) {\n      this._hide(true);\n    } else {\n      this._show(true);\n    }\n  }\n\n  _show(pin = false) {\n    if (pin) {\n      this.pinned = true;\n    }\n\n    if (this.hideElement.hidden) {\n      this.hideElement.hidden = false;\n      this.container.style.zIndex += 1;\n    }\n  }\n\n  _hide(unpin = true) {\n    if (unpin) {\n      this.pinned = false;\n    }\n\n    if (!this.hideElement.hidden && !this.pinned) {\n      this.hideElement.hidden = true;\n      this.container.style.zIndex -= 1;\n    }\n  }\n\n}\n\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"freeTextAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass LineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"lineAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height);\n    const line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(line);\n    this.container.append(svg);\n\n    this._createPopup(line, data);\n\n    return this.container;\n  }\n\n}\n\nclass SquareAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"squareAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height);\n    const borderWidth = data.borderStyle.width;\n    const square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(square);\n    this.container.append(svg);\n\n    this._createPopup(square, data);\n\n    return this.container;\n  }\n\n}\n\nclass CircleAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"circleAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(circle);\n    this.container.append(svg);\n\n    this._createPopup(circle, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolylineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height);\n    let points = [];\n\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + \",\" + y);\n    }\n\n    points = points.join(\" \");\n    const polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(polyline);\n    this.container.append(svg);\n\n    this._createPopup(polyline, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n\n}\n\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"caretAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass InkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height);\n\n    for (const inkList of data.inkLists) {\n      let points = [];\n\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n\n      this._createPopup(polyline, data);\n\n      svg.appendChild(polyline);\n    }\n\n    this.container.append(svg);\n    return this.container;\n  }\n\n}\n\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"highlightAnnotation\");\n    }\n\n    this.container.className = \"highlightAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"underlineAnnotation\");\n    }\n\n    this.container.className = \"underlineAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"squigglyAnnotation\");\n    }\n\n    this.container.className = \"squigglyAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n    }\n\n    this.container.className = \"strikeoutAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"stampAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      filename,\n      content\n    } = this.data.file;\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n    this.content = content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      id: (0, _util.stringToPDFString)(filename),\n      filename,\n      content\n    });\n  }\n\n  render() {\n    this.container.className = \"fileAttachmentAnnotation\";\n    const trigger = document.createElement(\"div\");\n    trigger.style.height = this.container.style.height;\n    trigger.style.width = this.container.style.width;\n    trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n    if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {\n      this._createPopup(trigger, this.data);\n    }\n\n    this.container.appendChild(trigger);\n    return this.container;\n  }\n\n  _download() {\n    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n  }\n\n}\n\nclass AnnotationLayer {\n  static render(parameters) {\n    const sortedAnnotations = [],\n          popupAnnotations = [];\n\n    for (const data of parameters.annotations) {\n      if (!data) {\n        continue;\n      }\n\n      const {\n        width,\n        height\n      } = getRectDims(data.rect);\n\n      if (width <= 0 || height <= 0) {\n        continue;\n      }\n\n      if (data.annotationType === _util.AnnotationType.POPUP) {\n        popupAnnotations.push(data);\n        continue;\n      }\n\n      sortedAnnotations.push(data);\n    }\n\n    if (popupAnnotations.length) {\n      sortedAnnotations.push(...popupAnnotations);\n    }\n\n    const div = parameters.div;\n\n    for (const data of sortedAnnotations) {\n      const element = AnnotationElementFactory.create({\n        data,\n        layer: div,\n        page: parameters.page,\n        viewport: parameters.viewport,\n        linkService: parameters.linkService,\n        downloadManager: parameters.downloadManager,\n        imageResourcesPath: parameters.imageResourcesPath || \"\",\n        renderForms: parameters.renderForms !== false,\n        svgFactory: new _display_utils.DOMSVGFactory(),\n        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\n        enableScripting: parameters.enableScripting,\n        hasJSActions: parameters.hasJSActions,\n        fieldObjects: parameters.fieldObjects,\n        mouseState: parameters.mouseState || {\n          isDown: false\n        }\n      });\n\n      if (element.isRenderable) {\n        const rendered = element.render();\n\n        if (data.hidden) {\n          rendered.style.visibility = \"hidden\";\n        }\n\n        if (Array.isArray(rendered)) {\n          for (const renderedElement of rendered) {\n            div.appendChild(renderedElement);\n          }\n        } else {\n          if (element instanceof PopupAnnotationElement) {\n            div.prepend(rendered);\n          } else {\n            div.appendChild(rendered);\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);\n  }\n\n  static update(parameters) {\n    const {\n      page,\n      viewport,\n      annotations,\n      annotationCanvasMap,\n      div\n    } = parameters;\n    const transform = viewport.transform;\n    const matrix = `matrix(${transform.join(\",\")})`;\n    let scale, ownMatrix;\n\n    for (const data of annotations) {\n      const elements = div.querySelectorAll(`[data-annotation-id=\"${data.id}\"]`);\n\n      if (elements) {\n        for (const element of elements) {\n          if (data.hasOwnCanvas) {\n            const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n            if (!ownMatrix) {\n              scale = Math.abs(transform[0] || transform[1]);\n              const ownTransform = transform.slice();\n\n              for (let i = 0; i < 4; i++) {\n                ownTransform[i] = Math.sign(ownTransform[i]);\n              }\n\n              ownMatrix = `matrix(${ownTransform.join(\",\")})`;\n            }\n\n            const left = rect[0] * scale;\n            const top = rect[1] * scale;\n            element.style.left = `${left}px`;\n            element.style.top = `${top}px`;\n            element.style.transformOrigin = `${-left}px ${-top}px`;\n            element.style.transform = ownMatrix;\n          } else {\n            element.style.transform = matrix;\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, annotationCanvasMap);\n    div.hidden = false;\n  }\n\n  static #setAnnotationCanvasMap(div, annotationCanvasMap) {\n    if (!annotationCanvasMap) {\n      return;\n    }\n\n    for (const [id, canvas] of annotationCanvasMap) {\n      const element = div.querySelector(`[data-annotation-id=\"${id}\"]`);\n\n      if (!element) {\n        continue;\n      }\n\n      const {\n        firstChild\n      } = element;\n\n      if (firstChild.nodeName === \"CANVAS\") {\n        element.replaceChild(canvas, firstChild);\n      } else {\n        element.insertBefore(canvas, firstChild);\n      }\n    }\n\n    annotationCanvasMap.clear();\n  }\n\n}\n\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\n\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\n\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n\n  static RGB_HTML([r, g, b]) {\n    const R = makeColorComp(r);\n    const G = makeColorComp(g);\n    const B = makeColorComp(b);\n    return `#${R}${G}${B}`;\n  }\n\n  static T_HTML() {\n    return \"#00000000\";\n  }\n\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n\n  static CMYK_HTML(components) {\n    return this.RGB_HTML(this.CMYK_RGB(components));\n  }\n\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n\n}\n\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 20 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaLayer = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _xfa_text = __w_pdfjs_require__(17);\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n\n        if (intent === \"print\") {\n          break;\n        }\n\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n\n        break;\n\n      case \"select\":\n        if (storedData.value !== null) {\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            }\n          }\n        }\n\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined || key === \"dataId\") {\n        continue;\n      }\n\n      if (key !== \"style\") {\n        if (key === \"textContent\") {\n          html.textContent = value;\n        } else if (key === \"class\") {\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n        } else {\n          if (isHTMLAnchorElement && (key === \"href\" || key === \"newWindow\")) {\n            continue;\n          }\n\n          html.setAttribute(key, value);\n        }\n      } else {\n        Object.assign(html.style, value);\n      }\n    }\n\n    if (isHTMLAnchorElement) {\n      if (!linkService.addLinkAttributes) {\n        (0, _util.warn)(\"XfaLayer.setAttribute - missing `addLinkAttributes`-method on the `linkService`-instance.\");\n      }\n\n      linkService.addLinkAttributes?.(html, attributes.href, attributes.newWindow);\n    }\n\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n\n    const stack = [[root, -1, rootHtml]];\n    const rootDiv = parameters.div;\n    rootDiv.appendChild(rootHtml);\n\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n\n    if (intent !== \"richText\") {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n\n    const textDivs = [];\n\n    while (stack.length > 0) {\n      const [parent, i, html] = stack[stack.length - 1];\n\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n\n      const child = parent.children[++stack[stack.length - 1][1]];\n\n      if (child === null) {\n        continue;\n      }\n\n      const {\n        name\n      } = child;\n\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.appendChild(node);\n        continue;\n      }\n\n      let childHtml;\n\n      if (child?.attributes?.xmlns) {\n        childHtml = document.createElementNS(child.attributes.xmlns, name);\n      } else {\n        childHtml = document.createElement(name);\n      }\n\n      html.appendChild(childHtml);\n\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n\n      if (child.children && child.children.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n\n        if (_xfa_text.XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n\n        childHtml.appendChild(node);\n      }\n    }\n\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n\n    return {\n      textDivs\n    };\n  }\n\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n\n}\n\nexports.XfaLayer = XfaLayer;\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.renderTextLayer = renderTextLayer;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nconst ascentCache = new Map();\nconst AllWhitespaceRegexp = /^\\s+$/g;\n\nfunction getAscent(fontFamily, ctx) {\n  const cachedAscent = ascentCache.get(fontFamily);\n\n  if (cachedAscent) {\n    return cachedAscent;\n  }\n\n  ctx.save();\n  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n  const metrics = ctx.measureText(\"\");\n  let ascent = metrics.fontBoundingBoxAscent;\n  let descent = Math.abs(metrics.fontBoundingBoxDescent);\n\n  if (ascent) {\n    ctx.restore();\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ctx.strokeStyle = \"red\";\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"g\", 0, 0);\n  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  descent = 0;\n\n  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n    if (pixels[i] > 0) {\n      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  ascent = 0;\n\n  for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n    if (pixels[i] > 0) {\n      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.restore();\n\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n  return DEFAULT_FONT_ASCENT;\n}\n\nfunction appendText(task, geom, styles, ctx) {\n  const textDiv = document.createElement(\"span\");\n  const textDivProperties = task._enhanceTextSelection ? {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    originalTransform: null,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    paddingRight: 0,\n    paddingTop: 0,\n    scale: 1\n  } : {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL\n  };\n\n  task._textDivs.push(textDiv);\n\n  const tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n  let angle = Math.atan2(tx[1], tx[0]);\n  const style = styles[geom.fontName];\n\n  if (style.vertical) {\n    angle += Math.PI / 2;\n  }\n\n  const fontHeight = Math.hypot(tx[2], tx[3]);\n  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);\n  let left, top;\n\n  if (angle === 0) {\n    left = tx[4];\n    top = tx[5] - fontAscent;\n  } else {\n    left = tx[4] + fontAscent * Math.sin(angle);\n    top = tx[5] - fontAscent * Math.cos(angle);\n  }\n\n  textDiv.style.left = `${left}px`;\n  textDiv.style.top = `${top}px`;\n  textDiv.style.fontSize = `${fontHeight}px`;\n  textDiv.style.fontFamily = style.fontFamily;\n  textDiv.setAttribute(\"role\", \"presentation\");\n  textDiv.textContent = geom.str;\n  textDiv.dir = geom.dir;\n\n  if (task._fontInspectorEnabled) {\n    textDiv.dataset.fontName = geom.fontName;\n  }\n\n  if (angle !== 0) {\n    textDivProperties.angle = angle * (180 / Math.PI);\n  }\n\n  let shouldScaleText = false;\n\n  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {\n    shouldScaleText = true;\n  } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n    const absScaleX = Math.abs(geom.transform[0]),\n          absScaleY = Math.abs(geom.transform[3]);\n\n    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n      shouldScaleText = true;\n    }\n  }\n\n  if (shouldScaleText) {\n    if (style.vertical) {\n      textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n    } else {\n      textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n    }\n  }\n\n  task._textDivProperties.set(textDiv, textDivProperties);\n\n  if (task._textContentStream) {\n    task._layoutText(textDiv);\n  }\n\n  if (task._enhanceTextSelection && textDivProperties.hasText) {\n    let angleCos = 1,\n        angleSin = 0;\n\n    if (angle !== 0) {\n      angleCos = Math.cos(angle);\n      angleSin = Math.sin(angle);\n    }\n\n    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n    const divHeight = fontHeight;\n    let m, b;\n\n    if (angle !== 0) {\n      m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n    } else {\n      b = [left, top, left + divWidth, top + divHeight];\n    }\n\n    task._bounds.push({\n      left: b[0],\n      top: b[1],\n      right: b[2],\n      bottom: b[3],\n      div: textDiv,\n      size: [divWidth, divHeight],\n      m\n    });\n  }\n}\n\nfunction render(task) {\n  if (task._canceled) {\n    return;\n  }\n\n  const textDivs = task._textDivs;\n  const capability = task._capability;\n  const textDivsLength = textDivs.length;\n\n  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n    task._renderingDone = true;\n    capability.resolve();\n    return;\n  }\n\n  if (!task._textContentStream) {\n    for (let i = 0; i < textDivsLength; i++) {\n      task._layoutText(textDivs[i]);\n    }\n  }\n\n  task._renderingDone = true;\n  capability.resolve();\n}\n\nfunction findPositiveMin(ts, offset, count) {\n  let result = 0;\n\n  for (let i = 0; i < count; i++) {\n    const t = ts[offset++];\n\n    if (t > 0) {\n      result = result ? Math.min(t, result) : t;\n    }\n  }\n\n  return result;\n}\n\nfunction expand(task) {\n  const bounds = task._bounds;\n  const viewport = task._viewport;\n  const expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n  for (let i = 0; i < expanded.length; i++) {\n    const div = bounds[i].div;\n\n    const divProperties = task._textDivProperties.get(div);\n\n    if (divProperties.angle === 0) {\n      divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n      divProperties.paddingTop = bounds[i].top - expanded[i].top;\n      divProperties.paddingRight = expanded[i].right - bounds[i].right;\n      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n      task._textDivProperties.set(div, divProperties);\n\n      continue;\n    }\n\n    const e = expanded[i],\n          b = bounds[i];\n    const m = b.m,\n          c = m[0],\n          s = m[1];\n    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n    const ts = new Float64Array(64);\n\n    for (let j = 0, jj = points.length; j < jj; j++) {\n      const t = _util.Util.applyTransform(points[j], m);\n\n      ts[j + 0] = c && (e.left - t[0]) / c;\n      ts[j + 4] = s && (e.top - t[1]) / s;\n      ts[j + 8] = c && (e.right - t[0]) / c;\n      ts[j + 12] = s && (e.bottom - t[1]) / s;\n      ts[j + 16] = s && (e.left - t[0]) / -s;\n      ts[j + 20] = c && (e.top - t[1]) / c;\n      ts[j + 24] = s && (e.right - t[0]) / -s;\n      ts[j + 28] = c && (e.bottom - t[1]) / c;\n      ts[j + 32] = c && (e.left - t[0]) / -c;\n      ts[j + 36] = s && (e.top - t[1]) / -s;\n      ts[j + 40] = c && (e.right - t[0]) / -c;\n      ts[j + 44] = s && (e.bottom - t[1]) / -s;\n      ts[j + 48] = s && (e.left - t[0]) / s;\n      ts[j + 52] = c && (e.top - t[1]) / -c;\n      ts[j + 56] = s && (e.right - t[0]) / s;\n      ts[j + 60] = c && (e.bottom - t[1]) / -c;\n    }\n\n    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n    task._textDivProperties.set(div, divProperties);\n  }\n}\n\nfunction expandBounds(width, height, boxes) {\n  const bounds = boxes.map(function (box, i) {\n    return {\n      x1: box.left,\n      y1: box.top,\n      x2: box.right,\n      y2: box.bottom,\n      index: i,\n      x1New: undefined,\n      x2New: undefined\n    };\n  });\n  expandBoundsLTR(width, bounds);\n  const expanded = new Array(boxes.length);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i] = {\n      left: b.x1New,\n      top: 0,\n      right: b.x2New,\n      bottom: 0\n    };\n  }\n\n  boxes.map(function (box, i) {\n    const e = expanded[i],\n          b = bounds[i];\n    b.x1 = box.top;\n    b.y1 = width - e.right;\n    b.x2 = box.bottom;\n    b.y2 = width - e.left;\n    b.index = i;\n    b.x1New = undefined;\n    b.x2New = undefined;\n  });\n  expandBoundsLTR(height, bounds);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i].top = b.x1New;\n    expanded[i].bottom = b.x2New;\n  }\n\n  return expanded;\n}\n\nfunction expandBoundsLTR(width, bounds) {\n  bounds.sort(function (a, b) {\n    return a.x1 - b.x1 || a.index - b.index;\n  });\n  const fakeBoundary = {\n    x1: -Infinity,\n    y1: -Infinity,\n    x2: 0,\n    y2: Infinity,\n    index: -1,\n    x1New: 0,\n    x2New: 0\n  };\n  const horizon = [{\n    start: -Infinity,\n    end: Infinity,\n    boundary: fakeBoundary\n  }];\n\n  for (const boundary of bounds) {\n    let i = 0;\n\n    while (i < horizon.length && horizon[i].end <= boundary.y1) {\n      i++;\n    }\n\n    let j = horizon.length - 1;\n\n    while (j >= 0 && horizon[j].start >= boundary.y2) {\n      j--;\n    }\n\n    let horizonPart, affectedBoundary;\n    let q,\n        k,\n        maxXNew = -Infinity;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      let xNew;\n\n      if (affectedBoundary.x2 > boundary.x1) {\n        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n      } else if (affectedBoundary.x2New === undefined) {\n        xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n      } else {\n        xNew = affectedBoundary.x2New;\n      }\n\n      if (xNew > maxXNew) {\n        maxXNew = xNew;\n      }\n    }\n\n    boundary.x1New = maxXNew;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New === undefined) {\n        if (affectedBoundary.x2 > boundary.x1) {\n          if (affectedBoundary.index > boundary.index) {\n            affectedBoundary.x2New = affectedBoundary.x2;\n          }\n        } else {\n          affectedBoundary.x2New = maxXNew;\n        }\n      } else if (affectedBoundary.x2New > maxXNew) {\n        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n      }\n    }\n\n    const changedHorizon = [];\n    let lastBoundary = null;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n      if (lastBoundary === useBoundary) {\n        changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n      } else {\n        changedHorizon.push({\n          start: horizonPart.start,\n          end: horizonPart.end,\n          boundary: useBoundary\n        });\n        lastBoundary = useBoundary;\n      }\n    }\n\n    if (horizon[i].start < boundary.y1) {\n      changedHorizon[0].start = boundary.y1;\n      changedHorizon.unshift({\n        start: horizon[i].start,\n        end: boundary.y1,\n        boundary: horizon[i].boundary\n      });\n    }\n\n    if (boundary.y2 < horizon[j].end) {\n      changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n      changedHorizon.push({\n        start: boundary.y2,\n        end: horizon[j].end,\n        boundary: horizon[j].boundary\n      });\n    }\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New !== undefined) {\n        continue;\n      }\n\n      let used = false;\n\n      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = 0; !used && k < changedHorizon.length; k++) {\n        used = changedHorizon[k].boundary === affectedBoundary;\n      }\n\n      if (!used) {\n        affectedBoundary.x2New = maxXNew;\n      }\n    }\n\n    Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\n  }\n\n  for (const horizonPart of horizon) {\n    const affectedBoundary = horizonPart.boundary;\n\n    if (affectedBoundary.x2New === undefined) {\n      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n    }\n  }\n}\n\nclass TextLayerRenderTask {\n  constructor({\n    textContent,\n    textContentStream,\n    container,\n    viewport,\n    textDivs,\n    textContentItemsStr,\n    enhanceTextSelection\n  }) {\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = (0, _util.createPromiseCapability)();\n    this._renderTimer = null;\n    this._bounds = [];\n\n    this._capability.promise.finally(() => {\n      if (!this._enhanceTextSelection) {\n        this._textDivProperties = null;\n      }\n\n      if (this._layoutTextCtx) {\n        this._layoutTextCtx.canvas.width = 0;\n        this._layoutTextCtx.canvas.height = 0;\n        this._layoutTextCtx = null;\n      }\n    }).catch(() => {});\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  cancel() {\n    this._canceled = true;\n\n    if (this._reader) {\n      this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {});\n\n      this._reader = null;\n    }\n\n    if (this._renderTimer !== null) {\n      clearTimeout(this._renderTimer);\n      this._renderTimer = null;\n    }\n\n    this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n  }\n\n  _processItems(items, styleCache) {\n    for (let i = 0, len = items.length; i < len; i++) {\n      if (items[i].str === undefined) {\n        if (items[i].type === \"beginMarkedContentProps\" || items[i].type === \"beginMarkedContent\") {\n          const parent = this._container;\n          this._container = document.createElement(\"span\");\n\n          this._container.classList.add(\"markedContent\");\n\n          if (items[i].id !== null) {\n            this._container.setAttribute(\"id\", `${items[i].id}`);\n          }\n\n          parent.appendChild(this._container);\n        } else if (items[i].type === \"endMarkedContent\") {\n          this._container = this._container.parentNode;\n        }\n\n        continue;\n      }\n\n      this._textContentItemsStr.push(items[i].str);\n\n      appendText(this, items[i], styleCache, this._layoutTextCtx);\n    }\n  }\n\n  _layoutText(textDiv) {\n    const textDivProperties = this._textDivProperties.get(textDiv);\n\n    let transform = \"\";\n\n    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {\n      const {\n        fontSize,\n        fontFamily\n      } = textDiv.style;\n\n      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n        this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;\n        this._layoutTextLastFontSize = fontSize;\n        this._layoutTextLastFontFamily = fontFamily;\n      }\n\n      const {\n        width\n      } = this._layoutTextCtx.measureText(textDiv.textContent);\n\n      if (width > 0) {\n        const scale = textDivProperties.canvasWidth / width;\n\n        if (this._enhanceTextSelection) {\n          textDivProperties.scale = scale;\n        }\n\n        transform = `scaleX(${scale})`;\n      }\n    }\n\n    if (textDivProperties.angle !== 0) {\n      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n    }\n\n    if (transform.length > 0) {\n      if (this._enhanceTextSelection) {\n        textDivProperties.originalTransform = transform;\n      }\n\n      textDiv.style.transform = transform;\n    }\n\n    if (textDivProperties.hasText) {\n      this._container.appendChild(textDiv);\n    }\n\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n\n      this._container.appendChild(br);\n    }\n  }\n\n  _render(timeout = 0) {\n    const capability = (0, _util.createPromiseCapability)();\n    let styleCache = Object.create(null);\n\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.height = canvas.width = DEFAULT_FONT_SIZE;\n    canvas.mozOpaque = true;\n    this._layoutTextCtx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n\n    if (this._textContent) {\n      const textItems = this._textContent.items;\n      const textStyles = this._textContent.styles;\n\n      this._processItems(textItems, textStyles);\n\n      capability.resolve();\n    } else if (this._textContentStream) {\n      const pump = () => {\n        this._reader.read().then(({\n          value,\n          done\n        }) => {\n          if (done) {\n            capability.resolve();\n            return;\n          }\n\n          Object.assign(styleCache, value.styles);\n\n          this._processItems(value.items, styleCache);\n\n          pump();\n        }, capability.reject);\n      };\n\n      this._reader = this._textContentStream.getReader();\n      pump();\n    } else {\n      throw new Error('Neither \"textContent\" nor \"textContentStream\" parameters specified.');\n    }\n\n    capability.promise.then(() => {\n      styleCache = null;\n\n      if (!timeout) {\n        render(this);\n      } else {\n        this._renderTimer = setTimeout(() => {\n          render(this);\n          this._renderTimer = null;\n        }, timeout);\n      }\n    }, this._capability.reject);\n  }\n\n  expandTextDivs(expandDivs = false) {\n    if (!this._enhanceTextSelection || !this._renderingDone) {\n      return;\n    }\n\n    if (this._bounds !== null) {\n      expand(this);\n      this._bounds = null;\n    }\n\n    const transformBuf = [],\n          paddingBuf = [];\n\n    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\n      const div = this._textDivs[i];\n\n      const divProps = this._textDivProperties.get(div);\n\n      if (!divProps.hasText) {\n        continue;\n      }\n\n      if (expandDivs) {\n        transformBuf.length = 0;\n        paddingBuf.length = 0;\n\n        if (divProps.originalTransform) {\n          transformBuf.push(divProps.originalTransform);\n        }\n\n        if (divProps.paddingTop > 0) {\n          paddingBuf.push(`${divProps.paddingTop}px`);\n          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingRight > 0) {\n          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingBottom > 0) {\n          paddingBuf.push(`${divProps.paddingBottom}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingLeft > 0) {\n          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        div.style.padding = paddingBuf.join(\" \");\n\n        if (transformBuf.length) {\n          div.style.transform = transformBuf.join(\" \");\n        }\n      } else {\n        div.style.padding = null;\n        div.style.transform = divProps.originalTransform;\n      }\n    }\n  }\n\n}\n\nfunction renderTextLayer(renderParameters) {\n  const task = new TextLayerRenderTask({\n    textContent: renderParameters.textContent,\n    textContentStream: renderParameters.textContentStream,\n    container: renderParameters.container,\n    viewport: renderParameters.viewport,\n    textDivs: renderParameters.textDivs,\n    textContentItemsStr: renderParameters.textContentItemsStr,\n    enhanceTextSelection: renderParameters.enhanceTextSelection\n  });\n\n  task._render(renderParameters.timeout);\n\n  return task;\n}\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SVGGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(5);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nlet SVGGraphics = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: SVGGraphics\");\n  }\n\n};\nexports.SVGGraphics = SVGGraphics;\n{\n  const SVG_DEFAULTS = {\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    fillColor: \"#000000\"\n  };\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n  const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n  const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n  const createObjectURL = function (data, contentType = \"\", forceDataSchema = false) {\n    if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n      return URL.createObjectURL(new Blob([data], {\n        type: contentType\n      }));\n    }\n\n    const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let buffer = `data:${contentType};base64,`;\n\n    for (let i = 0, ii = data.length; i < ii; i += 3) {\n      const b1 = data[i] & 0xff;\n      const b2 = data[i + 1] & 0xff;\n      const b3 = data[i + 2] & 0xff;\n      const d1 = b1 >> 2,\n            d2 = (b1 & 3) << 4 | b2 >> 4;\n      const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n      const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n\n    return buffer;\n  };\n\n  const convertImgDataToPng = function () {\n    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n    const CHUNK_WRAPPER_SIZE = 12;\n    const crcTable = new Int32Array(256);\n\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n\n      for (let h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n        } else {\n          c = c >> 1 & 0x7fffffff;\n        }\n      }\n\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      let crc = -1;\n\n      for (let i = start; i < end; i++) {\n        const a = (crc ^ data[i]) & 0xff;\n        const b = crcTable[a];\n        crc = crc >>> 8 ^ b;\n      }\n\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      let p = offset;\n      const len = body.length;\n      data[p] = len >> 24 & 0xff;\n      data[p + 1] = len >> 16 & 0xff;\n      data[p + 2] = len >> 8 & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n      data.set(body, p);\n      p += body.length;\n      const crc = crc32(data, offset + 4, p);\n      data[p] = crc >> 24 & 0xff;\n      data[p + 1] = crc >> 16 & 0xff;\n      data[p + 2] = crc >> 8 & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      let a = 1;\n      let b = 0;\n\n      for (let i = start; i < end; ++i) {\n        a = (a + (data[i] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      return b << 16 | a;\n    }\n\n    function deflateSync(literals) {\n      if (!_is_node.isNodeJS) {\n        return deflateSyncUncompressed(literals);\n      }\n\n      try {\n        let input;\n\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          input = Buffer.from(literals);\n        }\n\n        const output = (__webpack_require__(/*! zlib */ \"?afbb\").deflateSync)(input, {\n          level: 9\n        });\n\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    function deflateSyncUncompressed(literals) {\n      let len = literals.length;\n      const maxBlockLength = 0xffff;\n      const deflateBlocks = Math.ceil(len / maxBlockLength);\n      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      let pi = 0;\n      idat[pi++] = 0x78;\n      idat[pi++] = 0x9c;\n      let pos = 0;\n\n      while (len > maxBlockLength) {\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = len >> 8 & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n      const adler = adler32(literals, 0, literals.length);\n      idat[pi++] = adler >> 24 & 0xff;\n      idat[pi++] = adler >> 16 & 0xff;\n      idat[pi++] = adler >> 8 & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      let bitDepth, colorType, lineSize;\n      const bytes = imgData.data;\n\n      switch (kind) {\n        case _util.ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = width + 7 >> 3;\n          break;\n\n        case _util.ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n\n        case _util.ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n\n        default:\n          throw new Error(\"invalid format\");\n      }\n\n      const literals = new Uint8Array((1 + lineSize) * height);\n      let offsetLiterals = 0,\n          offsetBytes = 0;\n\n      for (let y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0;\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n        offsetLiterals = 0;\n\n        for (let y = 0; y < height; y++) {\n          offsetLiterals++;\n\n          for (let i = 0; i < lineSize; i++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n      const idat = deflateSync(literals);\n      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      const data = new Uint8Array(pngLength);\n      let offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk(\"IHDR\", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk(\"IDATA\", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n      return createObjectURL(data, \"image/png\", forceDataSchema);\n    }\n\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  }();\n\n  class SVGExtraState {\n    constructor() {\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = \"#000000\";\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = \"\";\n      this.lineCap = \"\";\n      this.miterLimit = 0;\n      this.dashArray = [];\n      this.dashPhase = 0;\n      this.dependencies = [];\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n      this.maskId = \"\";\n    }\n\n    clone() {\n      return Object.create(this);\n    }\n\n    setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n  }\n\n  function opListToTree(opList) {\n    let opTree = [];\n    const tmp = [];\n\n    for (const opListElement of opList) {\n      if (opListElement.fn === \"save\") {\n        opTree.push({\n          fnId: 92,\n          fn: \"group\",\n          items: []\n        });\n        tmp.push(opTree);\n        opTree = opTree[opTree.length - 1].items;\n        continue;\n      }\n\n      if (opListElement.fn === \"restore\") {\n        opTree = tmp.pop();\n      } else {\n        opTree.push(opListElement);\n      }\n    }\n\n    return opTree;\n  }\n\n  function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n\n    const s = value.toFixed(10);\n    let i = s.length - 1;\n\n    if (s[i] !== \"0\") {\n      return s;\n    }\n\n    do {\n      i--;\n    } while (s[i] === \"0\");\n\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\n  }\n\n  function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return \"\";\n        }\n\n        return `scale(${pf(m[0])} ${pf(m[3])})`;\n      }\n\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        const a = Math.acos(m[0]) * 180 / Math.PI;\n        return `rotate(${pf(a)})`;\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return `translate(${pf(m[4])} ${pf(m[5])})`;\n      }\n    }\n\n    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n  }\n\n  let clipCount = 0;\n  let maskCount = 0;\n  let shadingCount = 0;\n  exports.SVGGraphics = SVGGraphics = class {\n    constructor(commonObjs, objs, forceDataSchema = false) {\n      this.svgFactory = new _display_utils.DOMSVGFactory();\n      this.current = new SVGExtraState();\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n      this._operatorIdMapping = [];\n\n      for (const op in _util.OPS) {\n        this._operatorIdMapping[_util.OPS[op]] = op;\n      }\n    }\n\n    save() {\n      this.transformStack.push(this.transformMatrix);\n      const old = this.current;\n      this.extraStack.push(old);\n      this.current = old.clone();\n    }\n\n    restore() {\n      this.transformMatrix = this.transformStack.pop();\n      this.current = this.extraStack.pop();\n      this.pendingClip = null;\n      this.tgrp = null;\n    }\n\n    group(items) {\n      this.save();\n      this.executeOpTree(items);\n      this.restore();\n    }\n\n    loadDependencies(operatorList) {\n      const fnArray = operatorList.fnArray;\n      const argsArray = operatorList.argsArray;\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        if (fnArray[i] !== _util.OPS.dependency) {\n          continue;\n        }\n\n        for (const obj of argsArray[i]) {\n          const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n          const promise = new Promise(resolve => {\n            objsPool.get(obj, resolve);\n          });\n          this.current.dependencies.push(promise);\n        }\n      }\n\n      return Promise.all(this.current.dependencies);\n    }\n\n    transform(a, b, c, d, e, f) {\n      const transformMatrix = [a, b, c, d, e, f];\n      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n      this.tgrp = null;\n    }\n\n    getSVG(operatorList, viewport) {\n      this.viewport = viewport;\n\n      const svgElement = this._initialize(viewport);\n\n      return this.loadDependencies(operatorList).then(() => {\n        this.transformMatrix = _util.IDENTITY_MATRIX;\n        this.executeOpTree(this.convertOpList(operatorList));\n        return svgElement;\n      });\n    }\n\n    convertOpList(operatorList) {\n      const operatorIdMapping = this._operatorIdMapping;\n      const argsArray = operatorList.argsArray;\n      const fnArray = operatorList.fnArray;\n      const opList = [];\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        const fnId = fnArray[i];\n        opList.push({\n          fnId,\n          fn: operatorIdMapping[fnId],\n          args: argsArray[i]\n        });\n      }\n\n      return opListToTree(opList);\n    }\n\n    executeOpTree(opTree) {\n      for (const opTreeElement of opTree) {\n        const fn = opTreeElement.fn;\n        const fnId = opTreeElement.fnId;\n        const args = opTreeElement.args;\n\n        switch (fnId | 0) {\n          case _util.OPS.beginText:\n            this.beginText();\n            break;\n\n          case _util.OPS.dependency:\n            break;\n\n          case _util.OPS.setLeading:\n            this.setLeading(args);\n            break;\n\n          case _util.OPS.setLeadingMoveText:\n            this.setLeadingMoveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setFont:\n            this.setFont(args);\n            break;\n\n          case _util.OPS.showText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.showSpacedText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.endText:\n            this.endText();\n            break;\n\n          case _util.OPS.moveText:\n            this.moveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setCharSpacing:\n            this.setCharSpacing(args[0]);\n            break;\n\n          case _util.OPS.setWordSpacing:\n            this.setWordSpacing(args[0]);\n            break;\n\n          case _util.OPS.setHScale:\n            this.setHScale(args[0]);\n            break;\n\n          case _util.OPS.setTextMatrix:\n            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.setTextRise:\n            this.setTextRise(args[0]);\n            break;\n\n          case _util.OPS.setTextRenderingMode:\n            this.setTextRenderingMode(args[0]);\n            break;\n\n          case _util.OPS.setLineWidth:\n            this.setLineWidth(args[0]);\n            break;\n\n          case _util.OPS.setLineJoin:\n            this.setLineJoin(args[0]);\n            break;\n\n          case _util.OPS.setLineCap:\n            this.setLineCap(args[0]);\n            break;\n\n          case _util.OPS.setMiterLimit:\n            this.setMiterLimit(args[0]);\n            break;\n\n          case _util.OPS.setFillRGBColor:\n            this.setFillRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeRGBColor:\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeColorN:\n            this.setStrokeColorN(args);\n            break;\n\n          case _util.OPS.setFillColorN:\n            this.setFillColorN(args);\n            break;\n\n          case _util.OPS.shadingFill:\n            this.shadingFill(args[0]);\n            break;\n\n          case _util.OPS.setDash:\n            this.setDash(args[0], args[1]);\n            break;\n\n          case _util.OPS.setRenderingIntent:\n            this.setRenderingIntent(args[0]);\n            break;\n\n          case _util.OPS.setFlatness:\n            this.setFlatness(args[0]);\n            break;\n\n          case _util.OPS.setGState:\n            this.setGState(args[0]);\n            break;\n\n          case _util.OPS.fill:\n            this.fill();\n            break;\n\n          case _util.OPS.eoFill:\n            this.eoFill();\n            break;\n\n          case _util.OPS.stroke:\n            this.stroke();\n            break;\n\n          case _util.OPS.fillStroke:\n            this.fillStroke();\n            break;\n\n          case _util.OPS.eoFillStroke:\n            this.eoFillStroke();\n            break;\n\n          case _util.OPS.clip:\n            this.clip(\"nonzero\");\n            break;\n\n          case _util.OPS.eoClip:\n            this.clip(\"evenodd\");\n            break;\n\n          case _util.OPS.paintSolidColorImageMask:\n            this.paintSolidColorImageMask();\n            break;\n\n          case _util.OPS.paintImageXObject:\n            this.paintImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintInlineImageXObject:\n            this.paintInlineImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintImageMaskXObject:\n            this.paintImageMaskXObject(args[0]);\n            break;\n\n          case _util.OPS.paintFormXObjectBegin:\n            this.paintFormXObjectBegin(args[0], args[1]);\n            break;\n\n          case _util.OPS.paintFormXObjectEnd:\n            this.paintFormXObjectEnd();\n            break;\n\n          case _util.OPS.closePath:\n            this.closePath();\n            break;\n\n          case _util.OPS.closeStroke:\n            this.closeStroke();\n            break;\n\n          case _util.OPS.closeFillStroke:\n            this.closeFillStroke();\n            break;\n\n          case _util.OPS.closeEOFillStroke:\n            this.closeEOFillStroke();\n            break;\n\n          case _util.OPS.nextLine:\n            this.nextLine();\n            break;\n\n          case _util.OPS.transform:\n            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.constructPath:\n            this.constructPath(args[0], args[1]);\n            break;\n\n          case _util.OPS.endPath:\n            this.endPath();\n            break;\n\n          case 92:\n            this.group(opTreeElement.items);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented operator ${fn}`);\n            break;\n        }\n      }\n    }\n\n    setWordSpacing(wordSpacing) {\n      this.current.wordSpacing = wordSpacing;\n    }\n\n    setCharSpacing(charSpacing) {\n      this.current.charSpacing = charSpacing;\n    }\n\n    nextLine() {\n      this.moveText(0, this.current.leading);\n    }\n\n    setTextMatrix(a, b, c, d, e, f) {\n      const current = this.current;\n      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n      current.textMatrixScale = Math.hypot(a, b);\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtElement.appendChild(current.tspan);\n    }\n\n    beginText() {\n      const current = this.current;\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.textMatrix = _util.IDENTITY_MATRIX;\n      current.lineMatrix = _util.IDENTITY_MATRIX;\n      current.textMatrixScale = 1;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    moveText(x, y) {\n      const current = this.current;\n      current.x = current.lineX += x;\n      current.y = current.lineY += y;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    }\n\n    showText(glyphs) {\n      const current = this.current;\n      const font = current.font;\n      const fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return;\n      }\n\n      const fontSizeScale = current.fontSizeScale;\n      const charSpacing = current.charSpacing;\n      const wordSpacing = current.wordSpacing;\n      const fontDirection = current.fontDirection;\n      const textHScale = current.textHScale * fontDirection;\n      const vertical = font.vertical;\n      const spacingDir = vertical ? 1 : -1;\n      const defaultVMetrics = font.defaultVMetrics;\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\n      let x = 0;\n\n      for (const glyph of glyphs) {\n        if (glyph === null) {\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if (typeof glyph === \"number\") {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        const character = glyph.fontChar;\n        let scaledX, scaledY;\n        let width = glyph.width;\n\n        if (vertical) {\n          let vx;\n          const vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          const vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (glyph.isInFont || font.missingFile) {\n          current.xcoords.push(current.x + scaledX);\n\n          if (vertical) {\n            current.ycoords.push(-current.y + scaledY);\n          }\n\n          current.tspan.textContent += character;\n        } else {}\n\n        let charWidth;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n      }\n\n      current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n\n      if (vertical) {\n        current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n      } else {\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n        current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n      }\n\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n        current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n      }\n\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n          current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n        }\n\n        if (current.fillAlpha < 1) {\n          current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        }\n      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n        current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n      } else {\n        current.tspan.setAttributeNS(null, \"fill\", \"none\");\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        const lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n        this._setStrokeAttributes(current.tspan, lineWidthScale);\n      }\n\n      let textMatrix = current.textMatrix;\n\n      if (current.textRise !== 0) {\n        textMatrix = textMatrix.slice();\n        textMatrix[5] += current.textRise;\n      }\n\n      current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n      current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n      current.txtElement.appendChild(current.tspan);\n      current.txtgrp.appendChild(current.txtElement);\n\n      this._ensureTransformGroup().appendChild(current.txtElement);\n    }\n\n    setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    }\n\n    addFontStyle(fontObj) {\n      if (!fontObj.data) {\n        throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n      }\n\n      if (!this.cssStyle) {\n        this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n        this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n        this.defs.appendChild(this.cssStyle);\n      }\n\n      const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n      this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n    }\n\n    setFont(details) {\n      const current = this.current;\n      const fontObj = this.commonObjs.get(details[0]);\n      let size = details[1];\n      current.font = fontObj;\n\n      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n        this.addFontStyle(fontObj);\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\n      }\n\n      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n      let bold = \"normal\";\n\n      if (fontObj.black) {\n        bold = \"900\";\n      } else if (fontObj.bold) {\n        bold = \"bold\";\n      }\n\n      const italic = fontObj.italic ? \"italic\" : \"normal\";\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      current.fontSize = size;\n      current.fontFamily = fontObj.loadedName;\n      current.fontWeight = bold;\n      current.fontStyle = italic;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    endText() {\n      const current = this.current;\n\n      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n        current.element = current.txtElement;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    setLineWidth(width) {\n      if (width > 0) {\n        this.current.lineWidth = width;\n      }\n    }\n\n    setLineCap(style) {\n      this.current.lineCap = LINE_CAP_STYLES[style];\n    }\n\n    setLineJoin(style) {\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\n    }\n\n    setMiterLimit(limit) {\n      this.current.miterLimit = limit;\n    }\n\n    setStrokeAlpha(strokeAlpha) {\n      this.current.strokeAlpha = strokeAlpha;\n    }\n\n    setStrokeRGBColor(r, g, b) {\n      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n    }\n\n    setFillAlpha(fillAlpha) {\n      this.current.fillAlpha = fillAlpha;\n    }\n\n    setFillRGBColor(r, g, b) {\n      this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n      this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      this.current.xcoords = [];\n      this.current.ycoords = [];\n    }\n\n    setStrokeColorN(args) {\n      this.current.strokeColor = this._makeColorN_Pattern(args);\n    }\n\n    setFillColorN(args) {\n      this.current.fillColor = this._makeColorN_Pattern(args);\n    }\n\n    shadingFill(args) {\n      const width = this.viewport.width;\n      const height = this.viewport.height;\n\n      const inv = _util.Util.inverseTransform(this.transformMatrix);\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", x0);\n      rect.setAttributeNS(null, \"y\", y0);\n      rect.setAttributeNS(null, \"width\", x1 - x0);\n      rect.setAttributeNS(null, \"height\", y1 - y0);\n      rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n\n      if (this.current.fillAlpha < 1) {\n        rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n      }\n\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    _makeColorN_Pattern(args) {\n      if (args[0] === \"TilingPattern\") {\n        return this._makeTilingPattern(args);\n      }\n\n      return this._makeShadingPattern(args);\n    }\n\n    _makeTilingPattern(args) {\n      const color = args[1];\n      const operatorList = args[2];\n      const matrix = args[3] || _util.IDENTITY_MATRIX;\n      const [x0, y0, x1, y1] = args[4];\n      const xstep = args[5];\n      const ystep = args[6];\n      const paintType = args[7];\n      const tilingId = `shading${shadingCount++}`;\n\n      const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);\n\n      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n\n      const txstep = xstep * xscale;\n      const tystep = ystep * yscale;\n      const tiling = this.svgFactory.createElement(\"svg:pattern\");\n      tiling.setAttributeNS(null, \"id\", tilingId);\n      tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n      tiling.setAttributeNS(null, \"width\", txstep);\n      tiling.setAttributeNS(null, \"height\", tystep);\n      tiling.setAttributeNS(null, \"x\", `${tx0}`);\n      tiling.setAttributeNS(null, \"y\", `${ty0}`);\n      const svg = this.svg;\n      const transformMatrix = this.transformMatrix;\n      const fillColor = this.current.fillColor;\n      const strokeColor = this.current.strokeColor;\n      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n      this.svg = bbox;\n      this.transformMatrix = matrix;\n\n      if (paintType === 2) {\n        const cssColor = _util.Util.makeHexColor(...color);\n\n        this.current.fillColor = cssColor;\n        this.current.strokeColor = cssColor;\n      }\n\n      this.executeOpTree(this.convertOpList(operatorList));\n      this.svg = svg;\n      this.transformMatrix = transformMatrix;\n      this.current.fillColor = fillColor;\n      this.current.strokeColor = strokeColor;\n      tiling.appendChild(bbox.childNodes[0]);\n      this.defs.appendChild(tiling);\n      return `url(#${tilingId})`;\n    }\n\n    _makeShadingPattern(args) {\n      if (typeof args === \"string\") {\n        args = this.objs.get(args);\n      }\n\n      switch (args[0]) {\n        case \"RadialAxial\":\n          const shadingId = `shading${shadingCount++}`;\n          const colorStops = args[3];\n          let gradient;\n\n          switch (args[1]) {\n            case \"axial\":\n              const point0 = args[4];\n              const point1 = args[5];\n              gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"x1\", point0[0]);\n              gradient.setAttributeNS(null, \"y1\", point0[1]);\n              gradient.setAttributeNS(null, \"x2\", point1[0]);\n              gradient.setAttributeNS(null, \"y2\", point1[1]);\n              break;\n\n            case \"radial\":\n              const focalPoint = args[4];\n              const circlePoint = args[5];\n              const focalRadius = args[6];\n              const circleRadius = args[7];\n              gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n              gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n              gradient.setAttributeNS(null, \"r\", circleRadius);\n              gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n              gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n              gradient.setAttributeNS(null, \"fr\", focalRadius);\n              break;\n\n            default:\n              throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n          }\n\n          for (const colorStop of colorStops) {\n            const stop = this.svgFactory.createElement(\"svg:stop\");\n            stop.setAttributeNS(null, \"offset\", colorStop[0]);\n            stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n            gradient.appendChild(stop);\n          }\n\n          this.defs.appendChild(gradient);\n          return `url(#${shadingId})`;\n\n        case \"Mesh\":\n          (0, _util.warn)(\"Unimplemented pattern Mesh\");\n          return null;\n\n        case \"Dummy\":\n          return \"hotpink\";\n\n        default:\n          throw new Error(`Unknown IR type: ${args[0]}`);\n      }\n    }\n\n    setDash(dashArray, dashPhase) {\n      this.current.dashArray = dashArray;\n      this.current.dashPhase = dashPhase;\n    }\n\n    constructPath(ops, args) {\n      const current = this.current;\n      let x = current.x,\n          y = current.y;\n      let d = [];\n      let j = 0;\n\n      for (const op of ops) {\n        switch (op | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            const width = args[j++];\n            const height = args[j++];\n            const xw = x + width;\n            const yh = y + height;\n            d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"M\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"L\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            d.push(\"Z\");\n            break;\n        }\n      }\n\n      d = d.join(\" \");\n\n      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n        d = current.path.getAttributeNS(null, \"d\") + d;\n      } else {\n        current.path = this.svgFactory.createElement(\"svg:path\");\n\n        this._ensureTransformGroup().appendChild(current.path);\n      }\n\n      current.path.setAttributeNS(null, \"d\", d);\n      current.path.setAttributeNS(null, \"fill\", \"none\");\n      current.element = current.path;\n      current.setCurrentPoint(x, y);\n    }\n\n    endPath() {\n      const current = this.current;\n      current.path = null;\n\n      if (!this.pendingClip) {\n        return;\n      }\n\n      if (!current.element) {\n        this.pendingClip = null;\n        return;\n      }\n\n      const clipId = `clippath${clipCount++}`;\n      const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n      clipPath.setAttributeNS(null, \"id\", clipId);\n      clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n      const clipElement = current.element.cloneNode(true);\n\n      if (this.pendingClip === \"evenodd\") {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n      } else {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n      }\n\n      this.pendingClip = null;\n      clipPath.appendChild(clipElement);\n      this.defs.appendChild(clipPath);\n\n      if (current.activeClipUrl) {\n        current.clipGroup = null;\n\n        for (const prev of this.extraStack) {\n          prev.clipGroup = null;\n        }\n\n        clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n      }\n\n      current.activeClipUrl = `url(#${clipId})`;\n      this.tgrp = null;\n    }\n\n    clip(type) {\n      this.pendingClip = type;\n    }\n\n    closePath() {\n      const current = this.current;\n\n      if (current.path) {\n        const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n        current.path.setAttributeNS(null, \"d\", d);\n      }\n    }\n\n    setLeading(leading) {\n      this.current.leading = -leading;\n    }\n\n    setTextRise(textRise) {\n      this.current.textRise = textRise;\n    }\n\n    setTextRenderingMode(textRenderingMode) {\n      this.current.textRenderingMode = textRenderingMode;\n    }\n\n    setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    }\n\n    setRenderingIntent(intent) {}\n\n    setFlatness(flatness) {}\n\n    setGState(states) {\n      for (const [key, value] of states) {\n        switch (key) {\n          case \"LW\":\n            this.setLineWidth(value);\n            break;\n\n          case \"LC\":\n            this.setLineCap(value);\n            break;\n\n          case \"LJ\":\n            this.setLineJoin(value);\n            break;\n\n          case \"ML\":\n            this.setMiterLimit(value);\n            break;\n\n          case \"D\":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case \"RI\":\n            this.setRenderingIntent(value);\n            break;\n\n          case \"FL\":\n            this.setFlatness(value);\n            break;\n\n          case \"Font\":\n            this.setFont(value);\n            break;\n\n          case \"CA\":\n            this.setStrokeAlpha(value);\n            break;\n\n          case \"ca\":\n            this.setFillAlpha(value);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n            break;\n        }\n      }\n    }\n\n    fill() {\n      const current = this.current;\n\n      if (current.element) {\n        current.element.setAttributeNS(null, \"fill\", current.fillColor);\n        current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        this.endPath();\n      }\n    }\n\n    stroke() {\n      const current = this.current;\n\n      if (current.element) {\n        this._setStrokeAttributes(current.element);\n\n        current.element.setAttributeNS(null, \"fill\", \"none\");\n        this.endPath();\n      }\n    }\n\n    _setStrokeAttributes(element, lineWidthScale = 1) {\n      const current = this.current;\n      let dashArray = current.dashArray;\n\n      if (lineWidthScale !== 1 && dashArray.length > 0) {\n        dashArray = dashArray.map(function (value) {\n          return lineWidthScale * value;\n        });\n      }\n\n      element.setAttributeNS(null, \"stroke\", current.strokeColor);\n      element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n      element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n      element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n      element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n      element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n      element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n      element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n    }\n\n    eoFill() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fill();\n    }\n\n    fillStroke() {\n      this.stroke();\n      this.fill();\n    }\n\n    eoFillStroke() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fillStroke();\n    }\n\n    closeStroke() {\n      this.closePath();\n      this.stroke();\n    }\n\n    closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    }\n\n    closeEOFillStroke() {\n      this.closePath();\n      this.eoFillStroke();\n    }\n\n    paintSolidColorImageMask() {\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", \"1px\");\n      rect.setAttributeNS(null, \"height\", \"1px\");\n      rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    paintImageXObject(objId) {\n      const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    }\n\n    paintInlineImageXObject(imgData, mask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\n      cliprect.setAttributeNS(null, \"x\", \"0\");\n      cliprect.setAttributeNS(null, \"y\", \"0\");\n      cliprect.setAttributeNS(null, \"width\", pf(width));\n      cliprect.setAttributeNS(null, \"height\", pf(height));\n      this.current.element = cliprect;\n      this.clip(\"nonzero\");\n      const imgEl = this.svgFactory.createElement(\"svg:image\");\n      imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n      imgEl.setAttributeNS(null, \"x\", \"0\");\n      imgEl.setAttributeNS(null, \"y\", pf(-height));\n      imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n      imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n      imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n\n      if (mask) {\n        mask.appendChild(imgEl);\n      } else {\n        this._ensureTransformGroup().appendChild(imgEl);\n      }\n    }\n\n    paintImageMaskXObject(imgData) {\n      const current = this.current;\n      const width = imgData.width;\n      const height = imgData.height;\n      const fillColor = current.fillColor;\n      current.maskId = `mask${maskCount++}`;\n      const mask = this.svgFactory.createElement(\"svg:mask\");\n      mask.setAttributeNS(null, \"id\", current.maskId);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", pf(width));\n      rect.setAttributeNS(null, \"height\", pf(height));\n      rect.setAttributeNS(null, \"fill\", fillColor);\n      rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n      this.defs.appendChild(mask);\n\n      this._ensureTransformGroup().appendChild(rect);\n\n      this.paintInlineImageXObject(imgData, mask);\n    }\n\n    paintFormXObjectBegin(matrix, bbox) {\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n      }\n\n      if (bbox) {\n        const width = bbox[2] - bbox[0];\n        const height = bbox[3] - bbox[1];\n        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", bbox[0]);\n        cliprect.setAttributeNS(null, \"y\", bbox[1]);\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    paintFormXObjectEnd() {}\n\n    _initialize(viewport) {\n      const svg = this.svgFactory.create(viewport.width, viewport.height);\n      const definitions = this.svgFactory.createElement(\"svg:defs\");\n      svg.appendChild(definitions);\n      this.defs = definitions;\n      const rootGroup = this.svgFactory.createElement(\"svg:g\");\n      rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n      svg.appendChild(rootGroup);\n      this.svg = rootGroup;\n      return svg;\n    }\n\n    _ensureClipGroup() {\n      if (!this.current.clipGroup) {\n        const clipGroup = this.svgFactory.createElement(\"svg:g\");\n        clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n        this.svg.appendChild(clipGroup);\n        this.current.clipGroup = clipGroup;\n      }\n\n      return this.current.clipGroup;\n    }\n\n    _ensureTransformGroup() {\n      if (!this.tgrp) {\n        this.tgrp = this.svgFactory.createElement(\"svg:g\");\n        this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n        if (this.current.activeClipUrl) {\n          this._ensureClipGroup().appendChild(this.tgrp);\n        } else {\n          this.svg.appendChild(this.tgrp);\n        }\n      }\n\n      return this.tgrp;\n    }\n\n  };\n}\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNodeStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(24);\n\n;\n\nconst fs = __webpack_require__(/*! fs */ \"?fe90\");\n\nconst http = __webpack_require__(/*! http */ \"?d446\");\n\nconst https = __webpack_require__(/*! https */ \"?4c38\");\n\nconst url = __webpack_require__(/*! url */ \"?9f5f\");\n\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  const parsedUrl = url.parse(sourceUrl);\n\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n\n  return parsedUrl;\n}\n\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n    this._rangeRequestReaders.push(rangeReader);\n\n    return rangeReader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNodeStream = PDFNodeStream;\n\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._headersCapability = (0, _util.createPromiseCapability)();\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new _util.AbortException(\"streaming is disabled\"));\n    }\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers\n  };\n}\n\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._headersCapability.resolve();\n\n      this._setReadableStream(response);\n\n      const getResponseHeader = name => {\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n\n      this._headersCapability.reject(reason);\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    this._httpHeaders = {};\n\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      this._httpHeaders[property] = value;\n    }\n\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n\n      this._setReadableStream(response);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n        }\n\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._contentLength = stat.size;\n\n      this._setReadableStream(fs.createReadStream(path));\n\n      this._headersCapability.resolve();\n    });\n  }\n\n}\n\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    this._setReadableStream(fs.createReadStream(path, {\n      start,\n      end: end - 1\n    }));\n  }\n\n}\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _content_disposition = __w_pdfjs_require__(25);\n\nvar _display_utils = __w_pdfjs_require__(5);\n\nfunction validateRangeRequestCapabilities({\n  getResponseHeader,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  (0, _util.assert)(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\n\n  if (contentDisposition) {\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n\n    if ((0, _display_utils.isPdfFile)(filename)) {\n      return filename;\n    }\n  }\n\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n\n  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\nvar _util = __w_pdfjs_require__(1);\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  tmp = rfc2231getparam(contentDisposition);\n\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = (0, _util.stringToBytes)(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch (e) {}\n    }\n\n    return value;\n  }\n\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n\n    return value;\n  }\n\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n\n        continue;\n      }\n\n      matches[n] = [quot, part];\n    }\n\n    const parts = [];\n\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n\n      if (quot) {\n        part = unescape(part);\n\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n\n      parts.push(part);\n    }\n\n    return parts.join(\"\");\n  }\n\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n      }\n\n      value = parts.join('\"');\n    }\n\n    return value;\n  }\n\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n\n    if (encodingend === -1) {\n      return extvalue;\n    }\n\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replace(/_/g, \" \");\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n\n      try {\n        text = atob(text);\n      } catch (e) {}\n\n      return textdecode(charset, text);\n    });\n  }\n\n  return \"\";\n}\n\n/***/ }),\n/* 26 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNetworkStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(24);\n\n;\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n\n  if (typeof data !== \"string\") {\n    return data;\n  }\n\n  const array = (0, _util.stringToBytes)(data);\n  return array.buffer;\n}\n\nclass NetworkManager {\n  constructor(url, args = {}) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n    this.withCredentials = args.withCredentials || false;\n\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n      return new XMLHttpRequest();\n    };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n\n    return this.request(args);\n  }\n\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n\n  request(args) {\n    const xhr = this.getXhr();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      xhr.setRequestHeader(property, value);\n    }\n\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n\n    xhr.responseType = \"arraybuffer\";\n\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    pendingRequest.onProgress?.(evt);\n  }\n\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    const xhr = pendingRequest.xhr;\n\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n\n    delete this.pendingRequests[xhrId];\n\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const chunk = getArrayBuffer(xhr);\n\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n\n}\n\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNetworkStream = PDFNetworkStream;\n\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\n      getResponseHeader,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n\n    this._headersReceivedCapability.resolve();\n  }\n\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n\n    this._done = true;\n\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    this._headersReceivedCapability.reject(this._storedError);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._headersReceivedCapability.reject(reason);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n\n    this._fullRequestReader = null;\n  }\n\n}\n\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _close() {\n    this.onClosed?.(this);\n  }\n\n  _onDone(data) {\n    const chunk = data.chunk;\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._close();\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n\n    this._close();\n  }\n\n}\n\n/***/ }),\n/* 27 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFFetchStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(24);\n\n;\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController?.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n\n    if (typeof value === \"undefined\") {\n      continue;\n    }\n\n    headers.append(property, value);\n  }\n\n  return headers;\n}\n\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFFetchStream = PDFFetchStream;\n\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._reader = response.body.getReader();\n\n      this._headersCapability.resolve();\n\n      const getResponseHeader = name => {\n        return response.headers.get(name);\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n\n}\n\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._isStreamingSupported = !source.disableStream;\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._readCapability.resolve();\n\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n\n}\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\nvar exports = __webpack_exports__;\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"AnnotationLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_layer.AnnotationLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationMode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationMode;\n  }\n}));\nObject.defineProperty(exports, \"CMapCompressionType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.CMapCompressionType;\n  }\n}));\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\n  enumerable: true,\n  get: function () {\n    return _worker_options.GlobalWorkerOptions;\n  }\n}));\nObject.defineProperty(exports, \"InvalidPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.InvalidPDFException;\n  }\n}));\nObject.defineProperty(exports, \"LoopbackPort\", ({\n  enumerable: true,\n  get: function () {\n    return _api.LoopbackPort;\n  }\n}));\nObject.defineProperty(exports, \"MissingPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.MissingPDFException;\n  }\n}));\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return _util.OPS;\n  }\n}));\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFDataRangeTransport;\n  }\n}));\nObject.defineProperty(exports, \"PDFDateString\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PDFDateString;\n  }\n}));\nObject.defineProperty(exports, \"PDFWorker\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFWorker;\n  }\n}));\nObject.defineProperty(exports, \"PasswordResponses\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PasswordResponses;\n  }\n}));\nObject.defineProperty(exports, \"PermissionFlag\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PermissionFlag;\n  }\n}));\nObject.defineProperty(exports, \"PixelsPerInch\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PixelsPerInch;\n  }\n}));\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.RenderingCancelledException;\n  }\n}));\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _svg.SVGGraphics;\n  }\n}));\nObject.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UNSUPPORTED_FEATURES;\n  }\n}));\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UnexpectedResponseException;\n  }\n}));\nObject.defineProperty(exports, \"Util\", ({\n  enumerable: true,\n  get: function () {\n    return _util.Util;\n  }\n}));\nObject.defineProperty(exports, \"VerbosityLevel\", ({\n  enumerable: true,\n  get: function () {\n    return _util.VerbosityLevel;\n  }\n}));\nObject.defineProperty(exports, \"XfaLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _xfa_layer.XfaLayer;\n  }\n}));\nObject.defineProperty(exports, \"build\", ({\n  enumerable: true,\n  get: function () {\n    return _api.build;\n  }\n}));\nObject.defineProperty(exports, \"createPromiseCapability\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createPromiseCapability;\n  }\n}));\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createValidAbsoluteUrl;\n  }\n}));\nObject.defineProperty(exports, \"getDocument\", ({\n  enumerable: true,\n  get: function () {\n    return _api.getDocument;\n  }\n}));\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getPdfFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getPdfFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getXfaPageViewport\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getXfaPageViewport;\n  }\n}));\nObject.defineProperty(exports, \"isPdfFile\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isPdfFile;\n  }\n}));\nObject.defineProperty(exports, \"loadScript\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.loadScript;\n  }\n}));\nObject.defineProperty(exports, \"renderTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.renderTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"shadow\", ({\n  enumerable: true,\n  get: function () {\n    return _util.shadow;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function () {\n    return _api.version;\n  }\n}));\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _api = __w_pdfjs_require__(4);\n\nvar _display_utils = __w_pdfjs_require__(5);\n\nvar _annotation_layer = __w_pdfjs_require__(18);\n\nvar _worker_options = __w_pdfjs_require__(12);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nvar _text_layer = __w_pdfjs_require__(21);\n\nvar _svg = __w_pdfjs_require__(22);\n\nvar _xfa_layer = __w_pdfjs_require__(20);\n\nconst pdfjsVersion = '2.13.216';\nconst pdfjsBuild = '399a0ec60';\n{\n  if (_is_node.isNodeJS) {\n    const {\n      PDFNodeStream\n    } = __w_pdfjs_require__(23);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    const {\n      PDFNetworkStream\n    } = __w_pdfjs_require__(26);\n\n    const {\n      PDFFetchStream\n    } = __w_pdfjs_require__(27);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      if ((0, _display_utils.isValidFetchUrl)(params.url)) {\n        return new PDFFetchStream(params);\n      }\n\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=pdf.js.map\n\n//# sourceURL=webpack://crity/./node_modules/pdfjs-dist/build/pdf.js?");

/***/ }),

/***/ "./node_modules/pdfjs-dist/webpack.js":
/*!********************************************!*\
  !*** ./node_modules/pdfjs-dist/webpack.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Copyright 2022 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nconst pdfjs = __webpack_require__(/*! ./build/pdf.js */ \"./node_modules/pdfjs-dist/build/pdf.js\");\nconst PdfjsWorker = __webpack_require__(/*! worker-loader?esModule=false&filename=[name].[contenthash].js!./build/pdf.worker.js */ \"./node_modules/worker-loader/dist/cjs.js?esModule=false&filename=[name].[contenthash].js!./node_modules/pdfjs-dist/build/pdf.worker.js\");\n\nif (typeof window !== \"undefined\" && \"Worker\" in window) {\n  pdfjs.GlobalWorkerOptions.workerPort = new PdfjsWorker();\n}\n\nmodule.exports = pdfjs;\n\n\n//# sourceURL=webpack://crity/./node_modules/pdfjs-dist/webpack.js?");

/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?esModule=false&filename=[name].[contenthash].js!./node_modules/pdfjs-dist/build/pdf.worker.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?esModule=false&filename=[name].[contenthash].js!./node_modules/pdfjs-dist/build/pdf.worker.js ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = function Worker_fn() {\n  return new Worker(__webpack_require__.p + \"pdf.worker.bede8f4913e007492f80.js\");\n}\n\n\n//# sourceURL=webpack://crity/./node_modules/pdfjs-dist/build/pdf.worker.js?./node_modules/worker-loader/dist/cjs.js?esModule=false&filename=%5Bname%5D.%5Bcontenthash%5D.js");

/***/ }),

/***/ "?4a14":
/*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crity/canvas_(ignored)?");

/***/ }),

/***/ "?fe90":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crity/fs_(ignored)?");

/***/ }),

/***/ "?d446":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crity/http_(ignored)?");

/***/ }),

/***/ "?4c38":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crity/https_(ignored)?");

/***/ }),

/***/ "?9f5f":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crity/url_(ignored)?");

/***/ }),

/***/ "?afbb":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crity/zlib_(ignored)?");

/***/ }),

/***/ "./app/src/common/model/AccountSession.js":
/*!************************************************!*\
  !*** ./app/src/common/model/AccountSession.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoginState\": () => (/* binding */ LoginState),\n/* harmony export */   \"AccountSession\": () => (/* binding */ AccountSession),\n/* harmony export */   \"accountSession\": () => (/* binding */ accountSession)\n/* harmony export */ });\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _appwrite_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./appwrite.js */ \"./app/src/common/model/appwrite.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"./app/src/common/utils.js\");\n\n\n\n\nvar accountSession;\n\nconst LoginState = {\n    // The page just finished loading. Where are asynchronously checking if we have any sessions.\n    UNKNOWN: \"UNKNOWN\",\n\n    LOGGED_IN: \"LOGGED_IN\",\n    LOGGED_OUT: \"LOGGED_OUT\",\n};\n\nclass AccountSession extends _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    static EVENT_LOGIN_STATE_CHANGED = \"EVENT_LOGIN_STATE_CHANGED\";\n\n    constructor() {\n        super();\n\n        this.loginState = LoginState.UNKNOWN;\n        this.p_accountId = null;\n        \n        (async () => {\n            // Check if already logged in.\n            try { \n                // TODO: Is there a cleaner way of doing this?\n                let account = await _appwrite_js__WEBPACK_IMPORTED_MODULE_1__.appwrite.account.get();\n                this.p_accountId = account.$id;\n                this.p_changeLoginState(LoginState.LOGGED_IN);\n            } catch (e) {\n                this.p_changeLoginState(LoginState.LOGGED_OUT);\n            }\n        })();\n    }\n\n    get accountId() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.loginState === LoginState.LOGGED_IN);\n        return this.p_accountId;\n    }\n\n    async createAccountAndLogIn(name, email, password) {\n        // FIXME: What should we do in the UNKNOWN state?\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.loginState === LoginState.LOGGED_OUT);\n\n        // TODO: Handle failure.\n        await _appwrite_js__WEBPACK_IMPORTED_MODULE_1__.appwrite.account.create(\"unique()\", email, password, name);\n        this.logIn(email, password);\n    }\n\n    async logIn(email, password, message) {\n        // FIXME: What should we do in the UNKNOWN state?\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.loginState === LoginState.LOGGED_OUT);\n\n        try {\n            let session = await _appwrite_js__WEBPACK_IMPORTED_MODULE_1__.appwrite.account.createSession(email, password);\n            this.p_accountId = session.userId;\n            this.p_changeLoginState(LoginState.LOGGED_IN);\n        } catch (e) {\n            message.textContent = \"Wrong e-mail or password\";\n        }\n    }\n\n    async logOut() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.loginState === LoginState.LOGGED_IN);\n\n        // Do this first I guess, to prevent people from using the account while\n        // we're waiting for the server response.\n        this.p_changeLoginState(LoginState.UNKNOWN);\n\n        await _appwrite_js__WEBPACK_IMPORTED_MODULE_1__.appwrite.account.deleteSession(\"current\");\n        \n        this.p_changeLoginState(LoginState.LOGGED_OUT);\n    }\n\n    onceLoginStateIsKnownDo(doWhat, listener) {\n        if (this.loginState !== LoginState.UNKNOWN) {\n            doWhat();\n        } else {\n            let alreadyCalled = false;\n            this.addEventListener(AccountSession.EVENT_LOGIN_STATE_CHANGED, () => {\n                if (!alreadyCalled && this.loginState !== LoginState.UNKNOWN) {\n                    alreadyCalled = true;\n                    doWhat();\n                }\n            }, listener);\n        }\n    }\n\n    onceLoggedInDo(doWhat, listener) {\n        if (this.loginState === LoginState.LOGGED_IN) {\n            doWhat();\n        } else {\n            let alreadyCalled = false;\n            this.addEventListener(AccountSession.EVENT_LOGIN_STATE_CHANGED, () => {\n                if (!alreadyCalled && this.loginState === LoginState.LOGGED_IN) {\n                    alreadyCalled = true;\n                    doWhat();\n                }\n            }, listener);\n        }\n    }\n\n    p_changeLoginState(loginState) {\n        this.loginState = loginState;\n        this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(AccountSession.EVENT_LOGIN_STATE_CHANGED, {}));\n    }\n}\n\naccountSession = new AccountSession();\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/AccountSession.js?");

/***/ }),

/***/ "./app/src/common/model/Comment.js":
/*!*****************************************!*\
  !*** ./app/src/common/model/Comment.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Comment\": () => (/* binding */ Comment)\n/* harmony export */ });\n/* harmony import */ var _appwrite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appwrite.js */ \"./app/src/common/model/appwrite.js\");\n\n\n// WARNING: ALWAYS make sure to import Comment.js! Apparently, the Web APIs already\n// have a Comment class, which will be created if you forget the import!\nclass Comment {\n    constructor(author, text, authors, messages, likes) {\n        this.author = author;\n        this.text = text;\n        this.authors = authors;\n        this.messages = messages;\n        this.likes = likes;\n    }\n\n    static fromAppwriteDocument(appwriteComment) {\n        return new Comment(appwriteComment.author, appwriteComment.text, appwriteComment.authors, appwriteComment.messages, appwriteComment.likes);\n    }\n\n    async submit() {\n        return await _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.database.createDocument(\"comments\", \"unique()\", { text: this.text, author: this.author });\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/Comment.js?");

/***/ }),

/***/ "./app/src/common/model/Observable.js":
/*!********************************************!*\
  !*** ./app/src/common/model/Observable.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Event\": () => (/* binding */ Event),\n/* harmony export */   \"Observable\": () => (/* binding */ Observable),\n/* harmony export */   \"Listener\": () => (/* binding */ Listener)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"./app/src/common/utils.js\");\n/* eslint-env browser */\n\n\n\nclass Event {\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n        Object.freeze(this);\n    }\n}\n\nclass Subscription {\n    constructor(listenerId, observableId, eventType, callback) {\n        this.listenerId = listenerId;\n        this.observableId = observableId;\n        this.eventType = eventType;\n        this.callback = callback;\n    }\n}\n\nclass GlobalSubscriptionTable {\n    /////////////////////////////////////////////////////////////////////////////////////////////////\n    // Static members.\n    /////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // These are indexes, not indices!\n\n    // (observableId, eventType) |-> Set(subscription references)\n    static observableAndEventTypeIndex = {};\n    // observableId |-> Set(subscription references)\n    static observableIndex = {};\n    // listenerId |-> Set(subscription references)\n    static listenerIndex = {};\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////\n    // Entry creation/removal\n    /////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static addSubscription(subscription) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!subscription.eventType.includes(\",\"));\n\n        GlobalSubscriptionTable.p_forEachIndex(subscription, (index, key) => {\n            if (index[key] === undefined) {\n                index[key] = new Set();\n            }\n\n            index[key].add(subscription);\n        });\n    }\n\n    static removeSubscription(subscription) {\n        GlobalSubscriptionTable.p_forEachIndex(subscription, (index, key) => {\n            if (index[key] !== undefined) {\n                index[key].delete(subscription);\n                if (index[key].size === 0) {\n                    delete index[key];\n                }\n            }\n\n        });\n    }\n\n    static removeSubscriptions(subscriptions) {\n        subscriptions.forEach(subscription => GlobalSubscriptionTable.removeSubscription(subscription));\n    }\n\n    static p_forEachIndex(subscription, doWhat) {\n        doWhat(GlobalSubscriptionTable.observableAndEventTypeIndex, `${subscription.observableId},${subscription.eventType}`);\n        doWhat(GlobalSubscriptionTable.observableIndex, `${subscription.observableId}`);\n        doWhat(GlobalSubscriptionTable.listenerIndex, `${subscription.listenerId}`);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////\n    // Query\n    /////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @return Set.\n    static querySubscriptionsByObservableAndEventType(observableId, eventType) {\n        return GlobalSubscriptionTable.p_queryIndex(GlobalSubscriptionTable.observableAndEventTypeIndex, `${observableId},${eventType}`);\n    }\n\n    /// @return Set.\n    static querySubscriptionsByObservable(observableId) {\n        return GlobalSubscriptionTable.p_queryIndex(GlobalSubscriptionTable.observableIndex, `${observableId}`);\n    }\n\n    /// @return Set.\n    static querySubscriptionsByListener(listenerId) {\n        return GlobalSubscriptionTable.p_queryIndex(GlobalSubscriptionTable.listenerIndex, `${listenerId}`);\n    }\n    \n    /// @return Set.\n    static p_queryIndex(index, key) {\n        let result = index[key];\n        if (result === undefined) {\n            result = new Set();\n        }\n        return result;\n    }\n}\n\n// Whenever your class wants to subscribe to events, create one instance (once is enough for multiple event types and\n// for multiple observers).\n// Call listener.terminate() when terminating your class.\nclass Listener {\n    constructor() {\n        this.listenerId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.generateId)();\n    }\n\n    // Call this to \n    // (1) Save memory from the table entries. \n    // (2) Avoid zombie-callbacks when a listener gets terminated but the observable remains alive.\n    // (3) If you forget to call this and the observable remains alive, the listener will *not* be garbage-collected.\n    //     This is because the callback closure still keeps a reference to the listener.\n    terminate() {\n        let subscriptions = GlobalSubscriptionTable.querySubscriptionsByListener(this.listenerId);\n        GlobalSubscriptionTable.removeSubscriptions(subscriptions);\n    }\n}\n\n// Inherit this to be able to emit events.\nclass Observable {\n    constructor() {\n        // Intentionally not calling this id, to avoid naming collisions farther down\n        // the class hierarchy.\n        this.observableId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.generateId)();\n    }\n\n    // Call this to save memory from the table entries. But if you forget to call terminate(), the observable itself will still get\n    // garbage-collected (even when listeners remain alive) since the subscriptions only store IDs, not references.\n    terminate() {\n        this.clearEventListeners();\n    }\n\n    // Subscribe to eventType.\n    addEventListener(eventType, callback, listener) {\n        let subscription = new Subscription(listener.listenerId, this.observableId, eventType, callback);\n        GlobalSubscriptionTable.addSubscription(subscription);\n    }\n\n    clearEventListeners() {\n        let subscriptions = GlobalSubscriptionTable.querySubscriptionsByObservable(this.observableId);\n        GlobalSubscriptionTable.removeSubscriptions(subscriptions);\n    }\n\n    // Emit an event.\n    notifyAll(event) {\n        let subscriptions = GlobalSubscriptionTable.querySubscriptionsByObservableAndEventType(this.observableId, event.type);\n        subscriptions.forEach(subscription => {\n            subscription.callback(event);\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/Observable.js?");

/***/ }),

/***/ "./app/src/common/model/ObservableArray.js":
/*!*************************************************!*\
  !*** ./app/src/common/model/ObservableArray.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObservableArray\": () => (/* binding */ ObservableArray)\n/* harmony export */ });\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observable.js */ \"./app/src/common/model/Observable.js\");\n\n\n// Array + Events.\nclass ObservableArray extends _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    static EVENT_ITEM_ADDED = \"ITEM_ADDED\";\n    static EVENT_CLEARED = \"CLEARED\";\n    \n    // TODO: Add those?\n    //static EVENT_ITEM_REMOVED = \"ITEM_REMOVED\";\n    //static EVENT_FULL_UPDATE = \"FULL_UPDATE\";\n\n    constructor() {\n        super();\n        this.items = [];\n    }\n\n    push(item) {\n        this.items.push(item);\n        this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(ObservableArray.EVENT_ITEM_ADDED, {item}));\n    }\n\n    clear() {\n        this.items.length = 0;\n        this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(ObservableArray.EVENT_CLEARED, {}));\n    }\n\n    getFirst() {\n        if (this.items.length === 0) {\n            return null;\n        }\n\n        return this.items[0];\n    }\n\n    getLast() {\n        if (this.items.length === 0) {\n            return null;\n        }\n        \n        return this.items[this.items.length - 1];\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/ObservableArray.js?");

/***/ }),

/***/ "./app/src/common/model/PdfPage.js":
/*!*****************************************!*\
  !*** ./app/src/common/model/PdfPage.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PdfPage\": () => (/* binding */ PdfPage)\n/* harmony export */ });\n// At the moment, this is just a thin wrapper that sits on PDFJS's PDFPageProxy\nclass PdfPage {\n    constructor(pdfJsPage) {\n        this.pdfJsPage = pdfJsPage;\n\n        // This represents general information about page measurements.\n        // We mainly use this to get the page width/height.\n        this.viewport = pdfJsPage.getViewport({scale: 1});\n    }\n\n    get asp() {\n        return this.viewport.width / this.viewport.height;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/PdfPage.js?");

/***/ }),

/***/ "./app/src/common/model/Presentation.js":
/*!**********************************************!*\
  !*** ./app/src/common/model/Presentation.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Presentation\": () => (/* binding */ Presentation)\n/* harmony export */ });\nclass Presentation {\n    constructor(appwriteId, title, description) {\n        this.appwriteId = appwriteId;\n        this.title = title;\n        this.description = description;\n    }\n\n    static fromAppwriteDocument(appwritePresentation) {\n        return new Presentation(\n            appwritePresentation.$id,\n            appwritePresentation.title,\n            appwritePresentation.description);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/Presentation.js?");

/***/ }),

/***/ "./app/src/common/model/PresentationList.js":
/*!**************************************************!*\
  !*** ./app/src/common/model/PresentationList.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PresentationList\": () => (/* binding */ PresentationList)\n/* harmony export */ });\n/* harmony import */ var _ObservableArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObservableArray.js */ \"./app/src/common/model/ObservableArray.js\");\n/* harmony import */ var _AccountSession_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n/* harmony import */ var _appwrite_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./appwrite.js */ \"./app/src/common/model/appwrite.js\");\n/* harmony import */ var _Presentation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Presentation.js */ \"./app/src/common/model/Presentation.js\");\n/* harmony import */ var appwrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! appwrite */ \"./node_modules/appwrite/dist/esm/sdk.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils.js */ \"./app/src/common/utils.js\");\n\n\n\n\n\n\n\n\nclass PresentationList {\n    static PRESENTATIONS_COLLECTION_ID = \"presentations\";\n\n    constructor() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.assert)(_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.accountSession.loginState === _AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.LoginState.LOGGED_IN);\n\n        this.presentations = new _ObservableArray_js__WEBPACK_IMPORTED_MODULE_0__.ObservableArray();\n\n        this.p_fetch();\n    }\n\n    terminate() {\n        this.presentations.terminate();\n    }\n\n    async p_fetch() {\n        let presentations = await _appwrite_js__WEBPACK_IMPORTED_MODULE_2__.appwrite.database.listDocuments(PresentationList.PRESENTATIONS_COLLECTION_ID, [\n            appwrite__WEBPACK_IMPORTED_MODULE_4__.Query.equal(\"author\", _AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.accountSession.accountId),\n        ]);\n\n        for (let i = 0; i < presentations.documents.length; i++) {\n            let appwritePresentation = presentations.documents[i],\n                presentation = _Presentation_js__WEBPACK_IMPORTED_MODULE_3__.Presentation.fromAppwriteDocument(appwritePresentation);\n\n            this.presentations.push(presentation);\n        }\n    }\n\n    async createPresentation(title, description) {\n        let appwritePresentation = await _appwrite_js__WEBPACK_IMPORTED_MODULE_2__.appwrite.database.createDocument(\n                PresentationList.PRESENTATIONS_COLLECTION_ID, \n                \"unique()\", \n                {author: _AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.accountSession.accountId, title, description},\n            ),\n            presentation = _Presentation_js__WEBPACK_IMPORTED_MODULE_3__.Presentation.fromAppwriteDocument(appwritePresentation);\n\n        this.presentations.push(presentation);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/PresentationList.js?");

/***/ }),

/***/ "./app/src/common/model/Version.js":
/*!*****************************************!*\
  !*** ./app/src/common/model/Version.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Version\": () => (/* binding */ Version)\n/* harmony export */ });\n// Stores version-related metadata, as opposed to VersionPdf which downloads the PDF.\nclass Version {\n    constructor(label, pdfUrl, appwriteId) {\n        this.label = label;\n        this.pdfUrl = pdfUrl;\n        this.appwriteId = appwriteId;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/Version.js?");

/***/ }),

/***/ "./app/src/common/model/VersionComment.js":
/*!************************************************!*\
  !*** ./app/src/common/model/VersionComment.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VersionComment\": () => (/* binding */ VersionComment)\n/* harmony export */ });\n/* harmony import */ var _appwrite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appwrite.js */ \"./app/src/common/model/appwrite.js\");\n/* harmony import */ var _Comment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Comment.js */ \"./app/src/common/model/Comment.js\");\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _AccountSession_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n\n\n\n\n\nclass VersionComment extends _Observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable {\n    // TODO: Is there a better place for this? Should we add constants for _all_ collection IDs?\n    static VERSION_COMMENT_COLLECTION_ID = \"6214e5ef06bef7005816\";\n\n    static EVENT_PAGE_POS_CHANGED = \"PAGE_POS_CHANGED\";\n    static EVENT_SELECTED = \"SELECTED\";\n\n    constructor(version, pageNo, comment, pageX, pageY, commentId) {\n        super();\n\n        this.version = version;\n        this.pageNo = pageNo;\n\n        this.comment = comment;\n        this.pageX = pageX;\n        this.pageY = pageY;\n\n        this.id = commentId;\n    }\n\n    static async fromAppwriteDocument(version, appwriteVersionComment) {\n        let appwriteComment = await _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.database.getDocument(\"comments\", appwriteVersionComment.comment),\n            comment = _Comment_js__WEBPACK_IMPORTED_MODULE_1__.Comment.fromAppwriteDocument(appwriteComment);\n        return new VersionComment(version, appwriteVersionComment.pageNo, comment, appwriteVersionComment.xOnPage, appwriteVersionComment.yOnPage, appwriteVersionComment.comment);\n    }\n\n    setPagePos(pageX, pageY) {\n        this.pageX = pageX;\n        this.pageY = pageY;\n\n        this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_2__.Event(VersionComment.EVENT_PAGE_POS_CHANGED, {}));\n    }\n\n    async submit() {\n        let appwriteComment, appwriteVersionComment;\n\n        // Create an entry in the comments collection.\n        // This data is supposed to be shared across all versions that contain this comment.\n        appwriteComment = await this.comment.submit();\n\n        // Create an entry in the version-comment collection.\n        // This is supposed to contain version-specific data related to a given comment.\n        appwriteVersionComment = await _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.database.createDocument(\n            VersionComment.VERSION_COMMENT_COLLECTION_ID,\n            \"unique()\", \n            {\n                presentationVersion: this.version.appwriteId,\n                pageNo: this.pageNo,\n                xOnPage: this.pageX,\n                yOnPage: this.pageY,\n                comment: appwriteComment.$id,\n            },\n        );\n\n        return appwriteVersionComment;\n    }\n\n    async submitComment(author, message) {\n        this.comment.authors.push(author);\n        this.comment.messages.push(message);\n        console.log(this.comment.authors);\n        console.log(this.comment.messages);\n        await _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.database.updateDocument(\"comments\", this.id, {\n            authors: this.comment.authors,\n            messages: this.comment.messages,\n        });\n    }\n\n    subscribeToCommentDocument(uiComment) {  \n        let id = 'documents.'+this.id;  \n        this.unsubscribeFunc = _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.subscribe(\n            id,\n            response => this.onDocumentChanged(response, uiComment),\n        );   \n    }\n\n    async onDocumentChanged(response, uiComment) {\n        console.log(response);\n        this.comment.authors = response.payload.authors;\n        this.comment.messages = response.payload.messages;\n        console.log(this.comment.authors);\n        uiComment.addComment(this.comment.authors[this.comment.authors.length-1], this.comment.messages[this.comment.messages.length-1]);\n    }\n\n    async loadNewestComments(uiComment) {\n        let appwriteComment = await _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.database.getDocument(\"comments\", this.id),\n            comment = _Comment_js__WEBPACK_IMPORTED_MODULE_1__.Comment.fromAppwriteDocument(appwriteComment);\n        if(this.comment.authors.length !== comment.authors.length) {\n            this.comment = comment;\n            uiComment.addComments(comment);\n        }\n    }\n\n    async changeLikeStatus(liked, uiComment) {\n        let appwriteComment = await _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.database.getDocument(\"comments\", this.id),\n            comment = _Comment_js__WEBPACK_IMPORTED_MODULE_1__.Comment.fromAppwriteDocument(appwriteComment);\n        if(liked) {\n            comment.likes.push(_AccountSession_js__WEBPACK_IMPORTED_MODULE_3__.accountSession.accountId);\n        }else{\n            comment.likes.splice(_AccountSession_js__WEBPACK_IMPORTED_MODULE_3__.accountSession.accountId, 1);\n        }\n        this.comment.likes = comment.likes;\n        appwriteComment = await _appwrite_js__WEBPACK_IMPORTED_MODULE_0__.appwrite.database.updateDocument(\"comments\", this.id, {\n            likes: comment.likes,\n        });\n        uiComment.likesChanged(comment.likes);\n    }\n\n    commentOpened() {\n        this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_2__.Event(VersionComment.EVENT_SELECTED, {open: true}));\n    }\n\n    commentClosed() {\n        this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_2__.Event(VersionComment.EVENT_SELECTED, {open: false}));\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/VersionComment.js?");

/***/ }),

/***/ "./app/src/common/model/VersionCommentQuery.js":
/*!*****************************************************!*\
  !*** ./app/src/common/model/VersionCommentQuery.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VersionCommentQuery\": () => (/* binding */ VersionCommentQuery)\n/* harmony export */ });\n/* harmony import */ var appwrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! appwrite */ \"./node_modules/appwrite/dist/esm/sdk.js\");\n/* harmony import */ var _appwrite_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./appwrite.js */ \"./app/src/common/model/appwrite.js\");\n/* harmony import */ var _ObservableArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ObservableArray.js */ \"./app/src/common/model/ObservableArray.js\");\n/* harmony import */ var _VersionComment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VersionComment.js */ \"./app/src/common/model/VersionComment.js\");\n\n\n\n\n\n// Responsible for tracking comments that match a certain query. Keep this generic and put the editor-specific code\n// in the editor model.\nclass VersionCommentQuery {\n    // TODO: Unless if I messed up this should return the comments for *all* pages of the version, but yours truly didn't test.\n    static PAGE_NO_ANY = \"PAGE_NO_ANY\";\n\n    constructor(version, pageNo) {\n        this.version = version;\n        this.pageNo = pageNo;\n\n        // Fill this with the query results.\n        this.versionComments = new _ObservableArray_js__WEBPACK_IMPORTED_MODULE_2__.ObservableArray();\n        this.subscribeToCommentsVersionCollections();\n\n        this.p_fetch();\n    }\n    \n    // TODO: Might want to wrap Appwrite's subscription mechanisms to make use of our Observable infrastructure?\n    // TODO: Listening to collection events is not feasible on production scale.\n    subscribeToCommentsVersionCollections() {\n        this.unsubscribeFunc = _appwrite_js__WEBPACK_IMPORTED_MODULE_1__.appwrite.subscribe(\n            `collections.${_VersionComment_js__WEBPACK_IMPORTED_MODULE_3__.VersionComment.VERSION_COMMENT_COLLECTION_ID}.documents`, \n            response => this.onVersionCommentCollectionChanged(response),\n        );\n    }\n\n    appwriteVersionCommentMatchesQuery(appwriteVersionComment) {\n        if (appwriteVersionComment.presentationVersion !== this.version.appwriteId) {\n            return false;\n        }\n\n        if (this.pageNo !== VersionCommentQuery.PAGE_NO_ANY && appwriteVersionComment.pageNo !== this.pageNo) {\n            return false;\n        }\n\n        return true;\n    }\n\n    async onVersionCommentCollectionChanged(response) {\n        if (this.appwriteVersionCommentMatchesQuery(response.payload)) {\n            let versionComment = await _VersionComment_js__WEBPACK_IMPORTED_MODULE_3__.VersionComment.fromAppwriteDocument(this.version, response.payload);\n            this.versionComments.push(versionComment);\n        }\n    }\n\n    terminate() {\n        this.versionComments.terminate();\n        this.unsubscribeFunc();\n    }\n\n    buildAppwriteQueryArray() {\n        let queries = [appwrite__WEBPACK_IMPORTED_MODULE_0__.Query.equal(\"presentationVersion\", this.version.appwriteId)];\n        if (this.pageNo !== VersionCommentQuery.PAGE_NO_ANY) {\n            queries.push(appwrite__WEBPACK_IMPORTED_MODULE_0__.Query.equal(\"pageNo\", this.pageNo));\n        }\n        return queries;\n    }\n\n    async p_fetch() {\n        this.versionComments.clear();\n\n        // Do the query.\n        let appwriteVersionComments = await _appwrite_js__WEBPACK_IMPORTED_MODULE_1__.appwrite.database.listDocuments(_VersionComment_js__WEBPACK_IMPORTED_MODULE_3__.VersionComment.VERSION_COMMENT_COLLECTION_ID, this.buildAppwriteQueryArray());\n\n        // Feed the result into our observable array.\n        for (let i = 0; i < appwriteVersionComments.documents.length; i++) {\n            // Without the asynchronous function, every comment HTTP request would have to wait for its\n            // predecessor's roundtrip to finish, which slows comment loading down severely.\n            // FIXME: This messes up the order of the comments.\n            //(async () => {\n                let appwriteVersionComment = appwriteVersionComments.documents[i],\n                    versionComment = await _VersionComment_js__WEBPACK_IMPORTED_MODULE_3__.VersionComment.fromAppwriteDocument(this.version, appwriteVersionComment);\n                this.versionComments.push(versionComment);\n            //})();\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/VersionCommentQuery.js?");

/***/ }),

/***/ "./app/src/common/model/VersionList.js":
/*!*********************************************!*\
  !*** ./app/src/common/model/VersionList.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VersionList\": () => (/* binding */ VersionList)\n/* harmony export */ });\n/* harmony import */ var appwrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! appwrite */ \"./node_modules/appwrite/dist/esm/sdk.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./app/src/common/utils.js\");\n/* harmony import */ var _AccountSession_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n/* harmony import */ var _appwrite_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./appwrite.js */ \"./app/src/common/model/appwrite.js\");\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _ObservableArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ObservableArray.js */ \"./app/src/common/model/ObservableArray.js\");\n/* harmony import */ var _Version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Version.js */ \"./app/src/common/model/Version.js\");\n\n\n\n\n\n\n\n\nclass VersionList extends _Observable_js__WEBPACK_IMPORTED_MODULE_4__.Observable {\n    static EVENT_INITIAL_FETCH_CONCLUDED = \"INITIAL_FETCH_CONCLUDED\";\n\n    constructor(presentationId) {\n        super();\n\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.assert)(_AccountSession_js__WEBPACK_IMPORTED_MODULE_2__.accountSession.loginState === _AccountSession_js__WEBPACK_IMPORTED_MODULE_2__.LoginState.LOGGED_IN);\n        this.presentationId = presentationId;\n        this.versions = new _ObservableArray_js__WEBPACK_IMPORTED_MODULE_5__.ObservableArray();\n\n        (async () => {\n            await this.p_fetch();\n            this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_4__.Event(VersionList.EVENT_INITIAL_FETCH_CONCLUDED, {}));\n        })();\n    }\n\n    terminate() {\n        this.versions.terminate();\n    }\n\n    async p_fetch() {\n        let presentationId = this.presentationId,\n            presentationVersions = await _appwrite_js__WEBPACK_IMPORTED_MODULE_3__.appwrite.database.listDocuments(\"presentationVersions\", [\n                appwrite__WEBPACK_IMPORTED_MODULE_0__.Query.equal(\"presentation\", presentationId),\n            ]);\n\n        for (let i = 0; i < presentationVersions.documents.length; i++) {\n            let presentationVersion = presentationVersions.documents[i],\n                label = presentationVersion.label,\n                storageFileId = presentationVersion.storageFile,\n                pdfUrl = await _appwrite_js__WEBPACK_IMPORTED_MODULE_3__.appwrite.storage.getFileDownload(storageFileId),\n                version = new _Version_js__WEBPACK_IMPORTED_MODULE_6__.Version(label, pdfUrl, presentationVersion.$id);\n\n            this.versions.push(version);\n        }\n    }\n\n    async createVersion(presentationId, label, file) {\n        let storageFile = await _appwrite_js__WEBPACK_IMPORTED_MODULE_3__.appwrite.storage.createFile(\n                \"unique()\",\n                file, \n                [\"role:all\"], \n                [\"role:all\"]),\n            appwriteVersion = await _appwrite_js__WEBPACK_IMPORTED_MODULE_3__.appwrite.database.createDocument(\"presentationVersions\", \"unique()\", {label, storageFile: storageFile.$id, presentation: presentationId}),\n            storageFileId = storageFile.$id,\n            pdfUrl = await _appwrite_js__WEBPACK_IMPORTED_MODULE_3__.appwrite.storage.getFileDownload(storageFileId),\n            version = new _Version_js__WEBPACK_IMPORTED_MODULE_6__.Version(label, pdfUrl, appwriteVersion.$id);\n\n        this.versions.push(version);\n\n        return version;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/VersionList.js?");

/***/ }),

/***/ "./app/src/common/model/VersionPdf.js":
/*!********************************************!*\
  !*** ./app/src/common/model/VersionPdf.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VersionPdf\": () => (/* binding */ VersionPdf)\n/* harmony export */ });\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _PdfPage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PdfPage.js */ \"./app/src/common/model/PdfPage.js\");\n/* harmony import */ var pdfjs_dist_webpack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pdfjs-dist/webpack.js */ \"./node_modules/pdfjs-dist/webpack.js\");\n\n\n\n\n// Wraps PDFJS's PDFDocumentProxy.\n//\n// We maintain the notion of an \"active\" page number.\n// This is the page that is visible in the viewer and where the\n// comments are taken from.\n//\n// The first page has pageNo _1_(not 0)! This is to keep things consistent\n// with PDFJS.\nclass VersionPdf extends _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    // Events {\n\n    // The PDF is ready.\n    // >> `pdfUrl`: The (shortened) URL of the PDF that was loaded.\n    static EVENT_PDF_LOADED = \"PDF_LOADED\";\n\n    // }\n\n    constructor(version) {\n        super();\n\n        this.version = version;\n\n        this.pdfJsPdf = null;\n        this.numPages = null;\n\n        this.p_fetch();\n    }\n\n    async p_fetch() {\n        this.pdfJsPdf = await pdfjs_dist_webpack_js__WEBPACK_IMPORTED_MODULE_2__.getDocument(this.version.pdfUrl).promise;\n\n        // Not sure how expensive it is to access the # of pages, let's store this ourselves to be on the safe side.\n        this.numPages = this.pdfJsPdf.numPages;\n        \n        this.notifyAll(new _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(VersionPdf.EVENT_PDF_LOADED, {pdfUrl: this.version.pdfUrl}));\n    }\n\n    // Asynchronously fetch the PdfPage corresponding to the page number.\n    async fetchPage(pageNo) {\n        let page = await this.pdfJsPdf.getPage(pageNo),\n            activePdfPage = new _PdfPage_js__WEBPACK_IMPORTED_MODULE_1__.PdfPage(page);\n        return activePdfPage;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/VersionPdf.js?");

/***/ }),

/***/ "./app/src/common/model/appwrite.js":
/*!******************************************!*\
  !*** ./app/src/common/model/appwrite.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"appwrite\": () => (/* binding */ appwrite)\n/* harmony export */ });\n/* harmony import */ var appwrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! appwrite */ \"./node_modules/appwrite/dist/esm/sdk.js\");\n\n\nvar appwrite = new appwrite__WEBPACK_IMPORTED_MODULE_0__.Appwrite();\nappwrite\n    .setEndpoint(\"https://appwrite.software-engineering.education/v1\")\n    .setProject(/* crity */ \"6206644928ab8835c77f\");\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/model/appwrite.js?");

/***/ }),

/***/ "./app/src/common/ui/UiScrollbar.js":
/*!******************************************!*\
  !*** ./app/src/common/ui/UiScrollbar.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiScrollbar\": () => (/* binding */ UiScrollbar)\n/* harmony export */ });\n/* harmony import */ var _model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./app/src/common/utils.js\");\n/* harmony import */ var _dom_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n\n\n\n\n// Custom scrollbar. Works by creating a dummy div that is big enough to produce the desired knob length.\nclass UiScrollbar extends _model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    static EVENT_VISIBLE_INTERVAL_CHANGED = \"VISIBLE_INTERVAL_CHANGED\";\n\n    constructor(containerDiv, axis) {\n        super();\n\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.assert)(axis === \"x\" || axis === \"y\");\n\n        this.axis = axis;\n        this.el = (0,_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__.cloneDomTemplate)(`#scrollbar-${axis}-template`);\n        this.fakeContentEl = this.el.querySelector(\".id-fake-content\");\n\n        this.scrollPos = 0;\n        \n        containerDiv.appendChild(this.el);\n\n        this.el.addEventListener(\"scroll\", () => this.onScroll());\n        this.el.addEventListener(\"mousedown\", () => this.onMouseDown());\n\n        this.throttledScrollHandlerPending = false;\n    }\n\n    // Kind of confusing: The knob represents the visible area, the trough represents the content (which is\n    // bigger than the visible area when zoomed in). \n\n    reconfigure(contentStart, contentEnd, visibleStart, visibleEnd) {\n        this.contentStart = contentStart;\n        this.contentEnd = contentEnd;\n        this.visibleStart = visibleStart;\n        this.visibleEnd = visibleEnd;\n        this.p_reconfigure();\n    }\n\n    p_reconfigure() {\n        let ds, absoluteFakeContentSize;\n\n        ds = this.computeDerivedSizes();\n\n        this.setFakeContentSize(`${100.0/ds.visibleClippedProportion}%`);\n\n        absoluteFakeContentSize = this.getFakeContentSize();\n        this.scrollPos = absoluteFakeContentSize * Math.max(0.0, this.visibleStart - this.contentStart) / ds.contentSize;\n        this.scrollTo(this.scrollPos);\n    }\n\n    computeDerivedSizes() {\n        let visibleSize = this.visibleEnd - this.visibleStart, \n            clippedVisibleSize = Math.min(this.contentEnd, this.visibleEnd) - Math.max(this.contentStart, this.visibleStart),\n            contentSize = this.contentEnd - this.contentStart,\n            visibleClippedProportion = clippedVisibleSize / contentSize;\n\n        return { visibleSize, clippedVisibleSize, contentSize, visibleClippedProportion };\n    }\n\n    onScroll() {\n        // MSDN suggests doing this: https://developer.mozilla.org/en-US/docs/Web/API/Element/scroll_event#scroll_event_throttling\n        // An alternative might be to have the viewing area only emit events on animation frames?\n        if (!this.throttledScrollHandlerPending) {\n            this.throttledScrollHandlerPending = true;\n\n            window.requestAnimationFrame(() => {\n                this.onThrottledScroll();\n                this.throttledScrollHandlerPending = false;\n            });\n        }\n    }\n\n    onThrottledScroll() {\n        let scrollPos, relKnobLeft, ds = this.computeDerivedSizes();\n\n        if (this.axis === \"x\") {\n            scrollPos = this.el.scrollLeft;\n        } else {\n            scrollPos = this.el.scrollTop;\n        }\n\n        // HACK: Fix some numerical precision problems ... Ideally there would be a way to\n        // tell the Web API not to call us when the scroll position was set programmatically ...\n        if (Math.abs(scrollPos - this.scrollPos) < 2) {\n            return;\n        }\n\n        this.scrollPos = scrollPos;\n\n        relKnobLeft = scrollPos / this.getFakeContentSize();\n        // \"Un-clip\" the knob.\n        relKnobLeft -= Math.max(0, this.contentStart - this.visibleStart) / (this.contentEnd - this.contentStart);\n\n        this.visibleStart = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(this.contentStart, this.contentEnd, relKnobLeft);\n        this.visibleEnd = this.visibleStart + ds.visibleSize;\n\n        this.notifyAll(new _model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(UiScrollbar.EVENT_VISIBLE_INTERVAL_CHANGED, {}));\n        this.p_reconfigure();\n    }\n\n    onMouseDown() {\n        // There is no way (I can think of) to get the knob to e.g. be dragged farther out than the content\n        // (unless we go crazy and write our own scrollbar with HTML5 canvas), so clip the position when the user clicks the scrollbar ...\n        let ds = this.computeDerivedSizes();\n\n        this.visibleStart = Math.max(this.visibleStart, this.contentStart);\n        this.visibleEnd = this.visibleStart + ds.visibleSize;\n\n        this.visibleEnd = Math.min(this.visibleEnd, this.contentEnd);\n        this.visibleStart = this.visibleEnd - ds.visibleSize;\n\n        this.notifyAll(new _model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(UiScrollbar.EVENT_VISIBLE_INTERVAL_CHANGED, {}));\n        this.p_reconfigure();\n    }\n\n    scrollTo(numPixels) {\n        let scrollOptions = {};\n        scrollOptions.behavior = \"instant\";\n\n        if (this.axis === \"x\") {\n            scrollOptions.left = numPixels;\n        } else {\n            scrollOptions.top = numPixels;\n        }\n\n        this.el.scrollTo(scrollOptions);\n    }\n\n    getElSize() {\n        let result;\n        if (this.axis === \"x\") {\n            result = this.el.offsetWidth;\n        } else {\n            result = this.el.offsetHeight;\n        }\n        return result;\n    }\n\n    setFakeContentSize(size) {\n        if (this.axis === \"x\") {\n            this.fakeContentEl.style.width = size;\n        } else {\n            this.fakeContentEl.style.height = size;\n        }\n    }\n\n    getFakeContentSize() {\n        let result;\n        if (this.axis === \"x\") {\n            result = this.fakeContentEl.offsetWidth;\n        } else {\n            result = this.fakeContentEl.offsetHeight;\n        }\n        return result;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/ui/UiScrollbar.js?");

/***/ }),

/***/ "./app/src/common/ui/dom-utils.js":
/*!****************************************!*\
  !*** ./app/src/common/ui/dom-utils.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cloneDomTemplate\": () => (/* binding */ cloneDomTemplate),\n/* harmony export */   \"ensureCssClassPresentIff\": () => (/* binding */ ensureCssClassPresentIff),\n/* harmony export */   \"MouseButtonCodes\": () => (/* binding */ MouseButtonCodes)\n/* harmony export */ });\n// IIRC, calling clone on the template directly produces a document fragment;\n// this causes subtle issues when working with the fragment that are not\n// very fun to debug. This method has proven more reliable thus far.\nfunction cloneDomTemplate(selector) {\n    let templateEl = document.querySelector(selector);\n    return templateEl.content.firstElementChild.cloneNode(true);\n}\n\n/// After the function executes, the @p elements will have the CSS-class @p className if and \n/// only if @p predicate is ´true´.\nfunction ensureCssClassPresentIff(predicate, className, ...elements) {\n    elements.forEach(element => {\n        if (predicate) {\n            element.classList.add(className);\n        } else {\n            element.classList.remove(className);\n        }\n    });\n}\n\nconst MouseButtonCodes = {\n    LEFT: 0,\n    MIDDLE: 1,\n};\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/ui/dom-utils.js?");

/***/ }),

/***/ "./app/src/common/utils.js":
/*!*********************************!*\
  !*** ./app/src/common/utils.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unused\": () => (/* binding */ unused),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"generateId\": () => (/* binding */ generateId),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"clamped\": () => (/* binding */ clamped)\n/* harmony export */ });\nconst IS_DBG = true;\n\n// Pacify the linter.\n// Often, we have variables that do not get used for a good reason,\n// e.g. callback parameters. In that case, `unused(thingThatDoesntGetUsed)`\n// can come in handy to move on with stuff that actually matters.\nfunction unused() {\n    return;\n}\n\n// TODO: Can webpack compile this out in release builds?\n// TODO: Does JS support programmatic breakpoints?\nfunction assert(predicate) {\n    console.assert(!IS_DBG || predicate);\n}\n\n// Generate a globally unique ID.\nlet nextId = 0;\nfunction generateId() {\n    return nextId++;\n}\n\nfunction lerp(a, b, t) {\n    return (1.0 - t) * a + t * b;\n}\n\nfunction clamped(x, min, max) {\n    return Math.min(max, Math.max(min, x));\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/common/utils.js?");

/***/ }),

/***/ "./app/src/index.js":
/*!**************************!*\
  !*** ./app/src/index.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app_resources_css_text_layer_builder_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../app/resources/css/text_layer_builder.css */ \"./app/resources/css/text_layer_builder.css\");\n/* harmony import */ var _navbar_UiNavbar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./navbar/UiNavbar.js */ \"./app/src/navbar/UiNavbar.js\");\n/* harmony import */ var _screens_uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./screens/uiScreenSwapper.js */ \"./app/src/screens/uiScreenSwapper.js\");\n/* harmony import */ var _screens_import_screens_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./screens/import-screens.js */ \"./app/src/screens/import-screens.js\");\n// Crity web client, entry point: Webpack bundling starts here.\n//\n//\n//         \\ \\   \\ \\   \\ \\                    (_) | |                / /   / /   / /\n//          \\ \\   \\ \\   \\ \\       ___   _ __   _  | |_   _   _      / /   / /   / /\n//           > >   > >   > >     / __| | '__| | | | __| | | | |    < <   < <   < <\n//          / /   / /   / /     | (__  | |    | | | |_  | |_| |     \\ \\   \\ \\   \\ \\\n//         /_/   /_/   /_/       \\___| |_|    |_|  \\__|  \\__, |      \\_\\   \\_\\   \\_\\\n//                                                        __/ |\n//                                                       |___/\n//\n// Uni Regensburg, MME Abschlussprojekte WS 20/21.\n//\n// Team Crity (feedback loop):\n//      - Lee-Ann Seegets\n//      - Marcelo Mutzbauer\n//      - Maximilian Schmerle\n//      - Philipp Hohenthanner\n//      - Selina Roos\n//\n\n// Causes Webpack to distribute and <link> the css file.\n\n\n// The screens rely on the navbar, so let's import this first.\n\n\n// UiScreens depend on the screenbar, so let's import this now\n// to make dependencies clear, even though this is only needed\n// farther down.\n\n\n// Will register all our screen URLs. The screen swapper and the navbar are agnostic to\n// the concrete UiScreen implementations, so the UiScreens can make use of both without\n// any circular dependencies. \n\n\n// And GO!\n_screens_uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_2__.uiScreenSwapper.loadScreenFromUrl();\n\n\n//# sourceURL=webpack://crity/./app/src/index.js?");

/***/ }),

/***/ "./app/src/navbar/UiNavbar.js":
/*!************************************!*\
  !*** ./app/src/navbar/UiNavbar.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiNavbar\": () => (/* binding */ UiNavbar),\n/* harmony export */   \"uiNavbar\": () => (/* binding */ uiNavbar)\n/* harmony export */ });\n/* harmony import */ var _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/model/AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n/* harmony import */ var _screens_uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../screens/uiScreenSwapper.js */ \"./app/src/screens/uiScreenSwapper.js\");\n\n\n\n\n\nvar uiNavbar;\n\nclass UiLoggedInAccountPanel {\n    constructor() {\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__.cloneDomTemplate)(\"#logged-in-template\");\n\n        this.logOutButtonEl = this.el.querySelector(\".id-log-out-button\");\n        this.logOutButtonEl.addEventListener(\"click\", () => this.onLogOutButtonClicked());\n    }\n\n    onLogOutButtonClicked() {\n        _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.logOut();\n    }\n\n    terminate() {\n        return;\n    }\n}\n\nclass UiLoggedOutAccountPanel {\n    constructor() {\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__.cloneDomTemplate)(\"#logged-out-template\");\n\n        this.logInButtonEl = this.el.querySelector(\".id-log-in-button\");\n        this.logInButtonEl.addEventListener(\"click\", () => this.onLogInButtonClicked());\n    }\n\n    onLogInButtonClicked() {\n        _screens_uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_3__.uiScreenSwapper.loadScreen(\"login\", {});\n    }\n\n    terminate() {\n        return;\n    }\n}\n\nclass UiAccountPanel {\n    constructor() {\n        this.el = document.querySelector(\".id-account-panel\");\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__.Listener();\n\n        this.currentPanel = null;\n\n        _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.addEventListener(_common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.AccountSession.EVENT_LOGIN_STATE_CHANGED, () => this.onLoginStateChanged(), this.listener);\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    onLoginStateChanged() {\n        this.currentPanel?.terminate();\n        this.el.innerHTML = \"\";\n\n        switch (_common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.loginState) {\n            case _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.LoginState.LOGGED_IN: this.currentPanel = new UiLoggedInAccountPanel(); break;\n            case _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.LoginState.LOGGED_OUT: this.currentPanel = new UiLoggedOutAccountPanel(); break;\n\n            default: break;\n        }\n\n        this.el.appendChild(this.currentPanel.el);\n    }\n}\n\nclass UiNavbar {\n    constructor() {\n        this.el = document.querySelector(\"#navbar\");\n        this.accountPanel = new UiAccountPanel();\n    }\n\n    terminate() {\n        this.accountPanel.terminate();\n    }\n}\n\nuiNavbar = new UiNavbar();\n\n\n\n//# sourceURL=webpack://crity/./app/src/navbar/UiNavbar.js?");

/***/ }),

/***/ "./app/src/screens/UiRestrictedScreen.js":
/*!***********************************************!*\
  !*** ./app/src/screens/UiRestrictedScreen.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiRestrictedScreen\": () => (/* binding */ UiRestrictedScreen)\n/* harmony export */ });\n/* harmony import */ var _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/model/AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _UiScreen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UiScreen.js */ \"./app/src/screens/UiScreen.js\");\n/* harmony import */ var _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uiScreenSwapper.js */ \"./app/src/screens/uiScreenSwapper.js\");\n\n\n\n\n\n// Screen that is restricted to users that are logged in. Otherwise, redirect to the\n// login screen.\n// To use this, override: initRestrictedData(), terminateRestrictedData().\n// The benefit of this design is that the usage code can rely on the login-restricted data\n// being available.\nclass UiRestrictedScreen extends _UiScreen_js__WEBPACK_IMPORTED_MODULE_2__.UiScreen {\n    constructor(templateSelector, screenParameters) {\n        super(templateSelector, screenParameters);\n    }\n    \n    onScreenLoaded() {\n        super.onScreenLoaded();\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__.Listener();\n        this.restrictedInitRan = false;\n\n        this.updateLoginState();\n        _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.addEventListener(_common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.AccountSession.EVENT_LOGIN_STATE_CHANGED, () => this.updateLoginState(), this.listener);\n    }\n\n    terminate() {\n        super.terminate();\n\n        this.listener.terminate();\n        if (this.restrictedInitRan) {\n            this.terminateRestricted();\n        }\n    }\n\n    updateLoginState() {\n        switch (_common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.loginState) {\n            case _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.LoginState.LOGGED_IN: {\n                if (!this.restrictedInitRan) {\n                    this.restrictedInitRan = true;\n                    this.initRestricted();\n                }\n            } break;\n\n            case _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.LoginState.LOGGED_OUT: {\n                _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_3__.uiScreenSwapper.loadScreen(\"login\", {});\n            } break;\n\n            case _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.LoginState.UNKNOWN: break;\n            default: break;\n        }\n    }\n\n    initRestricted() {\n        // Override this.\n        return;\n    }\n\n    terminateRestricted() {\n        // Override this.\n        return;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/UiRestrictedScreen.js?");

/***/ }),

/***/ "./app/src/screens/UiScreen.js":
/*!*************************************!*\
  !*** ./app/src/screens/UiScreen.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiScreen\": () => (/* binding */ UiScreen)\n/* harmony export */ });\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n\n\nclass UiScreen {\n    // Overwrite this when you inherit. This tells UiRegistry.add() under which URL to place the screen.\n    static NAME = undefined;\n\n    constructor(templateSelector, screenParameters) {\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__.cloneDomTemplate)(templateSelector);\n        this.screenParameters = screenParameters;\n    }\n\n    // Override this if you need to do initialization that might call #uiScreenScreenSwapper.loadScreen().\n    // Should probably try to come up with a better design ...\n    onScreenLoaded() {\n        return;\n    }\n\n    // No longer needed, but probably a good practice to have sub-classes super-call this.\n    terminate() {\n        return;\n    }\n\n    static formatUrl(screen, screenParameters) {\n        let urlSearchParams = new URLSearchParams(screenParameters),\n            paramsString = urlSearchParams.toString();\n\n        if (paramsString.length > 0) {\n            paramsString = \"?\" + paramsString;\n        }\n\n        // Having the slash in there is important, otherwise history.pushState() won't remove\n        // the old parameters.\n        return `/${paramsString}#${screen}`;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/UiScreen.js?");

/***/ }),

/***/ "./app/src/screens/create-account/ui/UiCreateAccountScreen.js":
/*!********************************************************************!*\
  !*** ./app/src/screens/create-account/ui/UiCreateAccountScreen.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiCreateAccountScreen\": () => (/* binding */ UiCreateAccountScreen)\n/* harmony export */ });\n/* harmony import */ var _UiScreen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../UiScreen.js */ \"./app/src/screens/UiScreen.js\");\n/* harmony import */ var _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/model/AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../uiScreenRegistry.js */ \"./app/src/screens/uiScreenRegistry.js\");\n/* harmony import */ var _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../uiScreenSwapper.js */ \"./app/src/screens/uiScreenSwapper.js\");\n\n\n\n\n\n\nclass UiCreateAccountScreen extends _UiScreen_js__WEBPACK_IMPORTED_MODULE_0__.UiScreen {\n    static NAME = \"create-account\";\n\n    constructor() {\n        super(\"#create-account-screen-template\");\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_2__.Listener();\n\n        this.nameInputEl = this.el.querySelector(\".id-name-input\");\n        this.emailInputEl = this.el.querySelector(\".id-email-input\");\n        this.passwordInputEl = this.el.querySelector(\".id-password-input\");\n        this.confPasswordInputEl = this.el.querySelector(\".id-confPassword-input\");\n        this.message = this.el.querySelector(\".id-message\");\n        this.registerFormEl = this.el.querySelector(\".id-register-form\");\n\n        this.registerFormEl.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n            this.onCreateButtonClicked();\n        });\n\n        // FIXME: exactly the same two lines of code already exist in UiNavbar.js.\n        //          Maybe there's a way to refactor so the clicklistener for elements\n        //          with class \".id-log-in-button\" is only registered once?\n        this.logInButtonEl = this.el.querySelector(\".id-log-in-button\");\n        this.logInButtonEl.addEventListener(\"click\", () => this.onLogInButtonClicked());\n\n        _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.accountSession.addEventListener(\n            _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.AccountSession.EVENT_LOGIN_STATE_CHANGED,\n            () => this.onLoginStateChanged(),\n            this.listener,\n        );\n    }\n\n    terminate() {\n        super.terminate();\n        this.listener.terminate();\n    }\n\n    onLoginStateChanged() {\n        if (_common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.accountSession.loginState === _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.LoginState.LOGGED_IN) {\n            _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_4__.uiScreenSwapper.loadScreen(\"dashboard\", {});\n        }\n    }\n\n    onCreateButtonClicked() {\n        let name = this.nameInputEl.value,\n            email = this.emailInputEl.value,\n            password = this.passwordInputEl.value,\n            confPassword = this.confPasswordInputEl.value;\n\n        if (password !== confPassword) {\n            this.message.textContent = \"Passwords do not match\";\n            this.confPasswordInputEl.classList.remove(\"border-none\");\n            this.passwordInputEl.classList.remove(\"border-none\");\n        } else {\n            this.message.textContent = \"\";\n            (async () => {\n                await _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.accountSession.createAccountAndLogIn(name, email, password);\n            })();\n        }\n    }\n\n    onLogInButtonClicked() {\n        _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_4__.uiScreenSwapper.loadScreen(\"login\", {});\n    }\n}\n\n_uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_3__.uiScreenRegistry.add(UiCreateAccountScreen);\n\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/create-account/ui/UiCreateAccountScreen.js?");

/***/ }),

/***/ "./app/src/screens/dashboard/model/data.js":
/*!*************************************************!*\
  !*** ./app/src/screens/dashboard/model/data.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DashboardData\": () => (/* binding */ DashboardData),\n/* harmony export */   \"data\": () => (/* binding */ data),\n/* harmony export */   \"initData\": () => (/* binding */ initData),\n/* harmony export */   \"terminateData\": () => (/* binding */ terminateData)\n/* harmony export */ });\n/* harmony import */ var _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/model/AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_PresentationList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/model/PresentationList.js */ \"./app/src/common/model/PresentationList.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/utils.js */ \"./app/src/common/utils.js\");\n\n\n\n\n\nvar data;\n\nclass DashboardData extends _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable {\n    constructor() {\n        super();\n\n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_3__.assert)(_common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.loginState === _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.LoginState.LOGGED_IN);\n\n        this.presentationList = null;\n        this.presentationList = new _common_model_PresentationList_js__WEBPACK_IMPORTED_MODULE_2__.PresentationList();\n    }\n\n    terminate() {\n        super.terminate();\n        this.presentationList.terminate();\n    }\n}\n\nfunction initData() {\n    data = new DashboardData();\n}\n\nfunction terminateData() {\n    data.terminate();\n    data = null;\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/dashboard/model/data.js?");

/***/ }),

/***/ "./app/src/screens/dashboard/ui/UiDashboardScreen.js":
/*!***********************************************************!*\
  !*** ./app/src/screens/dashboard/ui/UiDashboardScreen.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiDashboardScreen\": () => (/* binding */ UiDashboardScreen)\n/* harmony export */ });\n/* harmony import */ var _UiRestrictedScreen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../UiRestrictedScreen.js */ \"./app/src/screens/UiRestrictedScreen.js\");\n/* harmony import */ var _uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../uiScreenRegistry.js */ \"./app/src/screens/uiScreenRegistry.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/data.js */ \"./app/src/screens/dashboard/model/data.js\");\n/* harmony import */ var _UiPresentationCreation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UiPresentationCreation.js */ \"./app/src/screens/dashboard/ui/UiPresentationCreation.js\");\n/* harmony import */ var _UiPresentationList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UiPresentationList.js */ \"./app/src/screens/dashboard/ui/UiPresentationList.js\");\n\n\n\n\n\n\nclass UiDashboardScreen extends _UiRestrictedScreen_js__WEBPACK_IMPORTED_MODULE_0__.UiRestrictedScreen {\n    static NAME = \"dashboard\";\n\n    constructor() {\n        super(\"#dashboard-screen-template\");\n    }\n\n    initRestricted() {\n        (0,_model_data_js__WEBPACK_IMPORTED_MODULE_2__.initData)();\n        this.presentationList = new _UiPresentationList_js__WEBPACK_IMPORTED_MODULE_4__.UiPresentationList(this);\n        this.presentationCreation = new _UiPresentationCreation_js__WEBPACK_IMPORTED_MODULE_3__.UiPresentationCreation(this);\n\n        this.navBarInfo = document.querySelector(\".id-info\");\n        this.navBarInfo.classList.add(\"hidden\");\n        this.copyLinkButton = document.querySelector(\"#copy-link-button\");\n        this.copyLinkButton.classList.add(\"hidden\");\n    }\n\n    terminateRestricted() {\n        this.presentationList.terminate();\n        (0,_model_data_js__WEBPACK_IMPORTED_MODULE_2__.terminateData)();\n    }\n}\n\n_uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_1__.uiScreenRegistry.add(UiDashboardScreen);\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/dashboard/ui/UiDashboardScreen.js?");

/***/ }),

/***/ "./app/src/screens/dashboard/ui/UiPresentationCreation.js":
/*!****************************************************************!*\
  !*** ./app/src/screens/dashboard/ui/UiPresentationCreation.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiPresentationCreation\": () => (/* binding */ UiPresentationCreation)\n/* harmony export */ });\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/data.js */ \"./app/src/screens/dashboard/model/data.js\");\n\n\nclass UiPresentationCreation {\n    constructor(screen) {\n        this.titleInputEl = screen.el.querySelector(\".id-presentation-title-input\");\n        this.descriptionInputEl = screen.el.querySelector(\".id-presentation-description-input\");\n        this.modal = screen.el.querySelector(\".id-modal\");\n        this.addProjectButtonEl = screen.el.querySelector(\".id-add-project-button\");\n        this.addButtonEl = screen.el.querySelector(\".id-add-presentation-button\");\n        this.closeButtonEl = screen.el.querySelector(\".id-close-button\");\n\n        this.addButtonEl.addEventListener(\"click\", () => this.onAddButtonClicked());\n        this.addProjectButtonEl.addEventListener(\"click\", () => this.onAddProjectButtonClicked());\n        this.closeButtonEl.addEventListener(\"click\", () => this.onCloseButtonClicked());\n    }\n\n    onAddButtonClicked() {\n        let title = this.titleInputEl.value,\n            description = this.descriptionInputEl.value;\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_0__.data.presentationList.createPresentation(title, description);\n\n        this.titleInputEl.value = \"\";\n        this.descriptionInputEl.value = \"\";\n        this.modal.classList.add(\"hidden\");\n    }\n\n    onAddProjectButtonClicked() {\n        this.modal.classList.remove(\"hidden\");\n    }\n\n    onCloseButtonClicked() {\n        this.modal.classList.add(\"hidden\");\n    }\n\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/dashboard/ui/UiPresentationCreation.js?");

/***/ }),

/***/ "./app/src/screens/dashboard/ui/UiPresentationItem.js":
/*!************************************************************!*\
  !*** ./app/src/screens/dashboard/ui/UiPresentationItem.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiPresentationItem\": () => (/* binding */ UiPresentationItem)\n/* harmony export */ });\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n/* harmony import */ var _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../uiScreenSwapper.js */ \"./app/src/screens/uiScreenSwapper.js\");\n\n\n\nclass UiPresentationItem {\n    constructor(screen, presentation) {\n        this.screen = screen;\n\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__.cloneDomTemplate)(\"#presentation-template\");\n        this.el.addEventListener(\"click\", () => this.onClick());\n\n        this.presentation = presentation;\n\n        this.titleEl = this.el.querySelector(\".presentation-title\");\n        this.titleEl.textContent = presentation.title;\n\n        this.descriptionEl = this.el.querySelector(\".presentation-description\");\n        this.descriptionEl.textContent = presentation.description;\n\n        this.dotsButtonEl = this.el.querySelector(\".id-dots-button\");\n        this.dotsButtonEl.addEventListener(\"click\", () => this.onDotsButtonClicked());\n    }\n\n    onClick() {\n        _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_1__.uiScreenSwapper.loadScreen(\"editor\", {presentation: this.presentation.appwriteId});\n    }\n\n    onDotsButtonClicked() {\n        console.log(\"robbed confirmed\");\n    }\n\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/dashboard/ui/UiPresentationItem.js?");

/***/ }),

/***/ "./app/src/screens/dashboard/ui/UiPresentationList.js":
/*!************************************************************!*\
  !*** ./app/src/screens/dashboard/ui/UiPresentationList.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiPresentationList\": () => (/* binding */ UiPresentationList)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/model/ObservableArray.js */ \"./app/src/common/model/ObservableArray.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/data.js */ \"./app/src/screens/dashboard/model/data.js\");\n/* harmony import */ var _UiPresentationItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UiPresentationItem.js */ \"./app/src/screens/dashboard/ui/UiPresentationItem.js\");\n\n\n\n\n\nclass UiPresentationList {\n    constructor(screen) {\n        this.screen = screen;\n        this.el = this.screen.el.querySelector(\".id-presentation-list\");\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.presentationList.presentations.addEventListener(_common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_1__.ObservableArray.EVENT_ITEM_ADDED, e => this.onPresentationAdded(e), this.listener);\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    onPresentationAdded(e) {\n        let presentationItem = new _UiPresentationItem_js__WEBPACK_IMPORTED_MODULE_3__.UiPresentationItem(this.screen, e.data.item);\n        this.el.appendChild(presentationItem.el);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/dashboard/ui/UiPresentationList.js?");

/***/ }),

/***/ "./app/src/screens/editor/model/EditorCommentEditing.js":
/*!**************************************************************!*\
  !*** ./app/src/screens/editor/model/EditorCommentEditing.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorCommentEditing\": () => (/* binding */ EditorCommentEditing)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n\n\n// Comment editing must be coordinated across the entire user interface, since multiple\n// widgets are involved.\nclass EditorCommentEditing extends _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    static EVENT_COMMENT_EDITING_STARTED = \"COMMENT_EDITING_STARTED\";\n    static EVENT_COMMENT_EDITING_FINISHED = \"COMMENT_EDITING_FINISHED\";\n\n    constructor() {\n        super();\n        this.editedVersionComment = null;\n    }\n\n    isEditing() {\n        return this.editedVersionComment !== null;\n    }\n\n    startEditingComment(versionComment) {\n        this.editedVersionComment = versionComment;\n        this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(EditorCommentEditing.EVENT_COMMENT_EDITING_STARTED, {}));\n    }\n\n    finishEditingComment(submit) {\n        if (submit) {\n            this.editedVersionComment.submit();\n        }\n\n        if(this.editedVersionComment !== null){\n            this.editedVersionComment.terminate();\n            this.editedVersionComment = null;\n            this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(EditorCommentEditing.EVENT_COMMENT_EDITING_FINISHED, {submitted: submit}));\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/model/EditorCommentEditing.js?");

/***/ }),

/***/ "./app/src/screens/editor/model/EditorSelTracker.js":
/*!**********************************************************!*\
  !*** ./app/src/screens/editor/model/EditorSelTracker.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorSelTracker\": () => (/* binding */ EditorSelTracker)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_VersionPdf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/model/VersionPdf.js */ \"./app/src/common/model/VersionPdf.js\");\n\n\n\n// Track the active version and page. \n// TODO: Probably too broad, especially once we need to select comments etc.\n\nclass EditorSelTracker extends _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    // Someone set a new active version.\n    // >> `version`: The new active #Version.\n    static EVENT_ACTIVE_VERSION_CHANGED = \"ACTIVE_VERSION_CHANGED\";\n\n    // The \"active\" page changed. \n    // >> `pageNo`: The number of the page that _became_ active. \n    static EVENT_ACTIVE_PAGE_CHANGED = \"ACTIVE_PAGE_CHANGED\";\n\n    constructor() {\n        super();\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n        this.version = null;\n        this.pdf = null;\n        // TODO: Should this be tracked by a separate class?\n        this.activePageNo = null;\n        this.activePage = null;\n    }\n\n    terminate() {\n        this.listener.terminate();\n        this.pdf?.terminate();\n    }\n    \n    activateVersion(version) {\n        if (this.version === version) {\n            return;\n        }\n\n        this.pdf?.terminate();\n        \n        this.version = version;\n        this.activePageNo = null;\n\n        this.pdf = new _common_model_VersionPdf_js__WEBPACK_IMPORTED_MODULE_1__.VersionPdf(version);\n        // TODO: Check if the PDF is empty.\n        this.pdf.addEventListener(_common_model_VersionPdf_js__WEBPACK_IMPORTED_MODULE_1__.VersionPdf.EVENT_PDF_LOADED, () => this.activatePage(1), this.listener);\n\n        this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(EditorSelTracker.EVENT_ACTIVE_VERSION_CHANGED, {version}));\n    }\n\n    // TODO: Leaving this (porting), but seems a bit weird now, revisit this.\n    hasPdf() {\n        return this.pdf !== null;\n    }\n\n    async activatePage(pageNo) {\n        if (this.activePageNo === pageNo) {\n            return;\n        }\n\n        this.activePageNo = pageNo;\n        this.activePage = await this.pdf.fetchPage(pageNo);\n        this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(EditorSelTracker.EVENT_ACTIVE_PAGE_CHANGED, {pageNo}));\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/model/EditorSelTracker.js?");

/***/ }),

/***/ "./app/src/screens/editor/model/ViewingArea.js":
/*!*****************************************************!*\
  !*** ./app/src/screens/editor/model/ViewingArea.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorViewingArea\": () => (/* binding */ EditorViewingArea)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/utils.js */ \"./app/src/common/utils.js\");\n\n\n\nclass EditorViewingArea extends _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    static EVENT_CHANGED = \"CHANGED\";\n\n    constructor() {\n        super();\n\n        // Properties are chosen such that we get reasonable behavior if\n        // (1) we get a new page with a different aspect ratio\n        // (2) the window gets resized.\n\n        // If longerAxis is such that max(pageDims[x], pageDims[y]) = pageDims[longerAxis],\n        // then zoom = pageDims[longerAxis] / containerDims[longerAxis].\n        this.zoom = 0.8;\n\n        // Relative page coordinates of the point that should end up at the center.\n        this.centeredX = 0.5;\n        this.centeredY = 0.5;\n    }\n\n    setZoom(zoom) {\n        this.zoom = zoom;\n        this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(EditorViewingArea.EVENT_CHANGED, {}));\n    }\n\n    computePageRect(asp, containerWidth, containerHeight) {\n        let pageRect, pageCenterX, pageCenterY, pageWidth, pageHeight;\n\n        pageRect = {};\n\n        if (asp > 1) {\n            // longerAxis = x\n            pageWidth = this.zoom * containerWidth;\n            pageHeight = pageWidth / asp;\n        } else {\n            // longerAxis = y\n            pageHeight = this.zoom * containerHeight;\n            pageWidth = pageHeight * asp; \n        }\n\n        pageCenterX = 0.5 * containerWidth + (0.5 - this.centeredX) * pageWidth;\n        pageCenterY = 0.5 * containerHeight + (0.5 - this.centeredY) * pageHeight;\n\n        pageRect.left = pageCenterX - 0.5 * pageWidth;\n        pageRect.right = pageCenterX + 0.5 * pageWidth;\n        pageRect.top = pageCenterY - 0.5 * pageHeight;\n        pageRect.bottom = pageCenterY + 0.5 * pageHeight;\n\n        return pageRect;\n    }\n\n    setPageRect(asp, containerWidth, containerHeight, pageRect) {\n        let pageWidth, pageHeight, pageCenterX, pageCenterY;\n\n        pageWidth = pageRect.right - pageRect.left;\n        pageHeight = pageRect.bottom - pageRect.top;\n        pageCenterX = 0.5 * (pageRect.left + pageRect.right);\n        pageCenterY = 0.5 * (pageRect.top + pageRect.bottom);\n\n        if (asp > 1) {\n            // longerAxis = x\n            this.zoom = pageWidth / containerWidth;\n        } else {\n            // longerAxis = y\n            this.zoom = pageHeight / containerHeight;\n        }\n\n        this.centeredX = (-pageCenterX + 0.5 * containerWidth + 0.5 * pageWidth) / pageWidth;\n        this.centeredY = (-pageCenterY + 0.5 * containerHeight + 0.5 * pageHeight) / pageHeight;\n\n        // Kind of ugly to have this here ... But easiest way to get this working for now.\n        this.clampPanning();\n\n        this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(EditorViewingArea.EVENT_CHANGED, {}));\n    }\n\n    clampPanning() {\n        this.centeredX = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.clamped)(this.centeredX, 0.0, 1.0);\n        this.centeredY = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.clamped)(this.centeredY, 0.0, 1.0);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/model/ViewingArea.js?");

/***/ }),

/***/ "./app/src/screens/editor/model/data.js":
/*!**********************************************!*\
  !*** ./app/src/screens/editor/model/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorData\": () => (/* binding */ EditorData),\n/* harmony export */   \"data\": () => (/* binding */ data),\n/* harmony export */   \"initData\": () => (/* binding */ initData),\n/* harmony export */   \"terminateData\": () => (/* binding */ terminateData)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_VersionList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/model/VersionList.js */ \"./app/src/common/model/VersionList.js\");\n/* harmony import */ var _EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditorSelTracker.js */ \"./app/src/screens/editor/model/EditorSelTracker.js\");\n/* harmony import */ var _common_model_VersionCommentQuery_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/model/VersionCommentQuery.js */ \"./app/src/common/model/VersionCommentQuery.js\");\n/* harmony import */ var _EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditorCommentEditing.js */ \"./app/src/screens/editor/model/EditorCommentEditing.js\");\n/* harmony import */ var _ViewingArea_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewingArea.js */ \"./app/src/screens/editor/model/ViewingArea.js\");\n\n\n\n\n\n\n\nvar data;\n\nfunction initData(presentationId) {\n    data = new EditorData(presentationId);\n}\n\nfunction terminateData() {\n    data.terminate();\n    data = null;\n}\n\n// The global object representing all the abstract state of the screen.\nclass EditorData extends _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    static EVENT_VERSION_COMMENT_QUERY_CHANGED = \"VERSION_COMMENT_QUERY_CHANGED\";\n\n    constructor(presentationId) {\n        super();\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n\n        this.presentationId = presentationId;\n\n        this.selTracker = new _EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__.EditorSelTracker();\n        this.selTracker.addEventListener(_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__.EditorSelTracker.EVENT_ACTIVE_PAGE_CHANGED, () => this.onActivePageChanged(), this.listener);\n\n        this.versionCommentQuery = null;\n\n        this.commentEditing = new _EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_4__.EditorCommentEditing();\n\n        this.versionList = new _common_model_VersionList_js__WEBPACK_IMPORTED_MODULE_1__.VersionList(this.presentationId);\n        this.versionList.addEventListener(_common_model_VersionList_js__WEBPACK_IMPORTED_MODULE_1__.VersionList.EVENT_INITIAL_FETCH_CONCLUDED, () => {\n            this.selTracker.activateVersion(this.versionList.versions.getLast());\n        }, this.listener);\n\n        this.viewingArea = new _ViewingArea_js__WEBPACK_IMPORTED_MODULE_5__.EditorViewingArea();\n    }\n\n    terminate() {\n        super.terminate();\n        this.commentEditing.terminate();\n        this.listener.terminate();\n        this.selTracker.terminate();\n        this.versionList.terminate();\n        this.versionCommentQuery?.terminate();\n        this.viewingArea.terminate();\n    }\n\n    onActivePageChanged() {\n        if (this.commentEditing.isEditing()) {\n            this.commentEditing.finishEditingComment(false);\n        }\n\n        this.versionCommentQuery?.terminate();\n        // TODO: Support querying for comments on _all_ the pages. This could be exposed in the UI as a filter option?\n        this.versionCommentQuery = new _common_model_VersionCommentQuery_js__WEBPACK_IMPORTED_MODULE_3__.VersionCommentQuery(this.selTracker.version, this.selTracker.activePageNo);\n\n        this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(EditorData.EVENT_VERSION_COMMENT_QUERY_CHANGED, {}));\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/model/data.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/UiEditorScreen.js":
/*!*****************************************************!*\
  !*** ./app/src/screens/editor/ui/UiEditorScreen.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiEditorScreen\": () => (/* binding */ UiEditorScreen)\n/* harmony export */ });\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _UiRestrictedScreen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../UiRestrictedScreen.js */ \"./app/src/screens/UiRestrictedScreen.js\");\n/* harmony import */ var _thumbnail_sidebar_UiThumbnailBar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./thumbnail-sidebar/UiThumbnailBar.js */ \"./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnailBar.js\");\n/* harmony import */ var _content_center_UiContentCenter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./content-center/UiContentCenter.js */ \"./app/src/screens/editor/ui/content-center/UiContentCenter.js\");\n/* harmony import */ var _timeline_UiTimeline_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./timeline/UiTimeline.js */ \"./app/src/screens/editor/ui/timeline/UiTimeline.js\");\n/* harmony import */ var _comment_sidebar_UiRightSidebar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./comment-sidebar/UiRightSidebar.js */ \"./app/src/screens/editor/ui/comment-sidebar/UiRightSidebar.js\");\n/* harmony import */ var _uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../uiScreenRegistry.js */ \"./app/src/screens/uiScreenRegistry.js\");\n/* harmony import */ var _common_model_appwrite_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/model/appwrite.js */ \"./app/src/common/model/appwrite.js\");\n\n\n\n\n\n\n\n\n\n// TODO: We probably won't want to inherit from restricted screen, since people\n// should be able to add comments without an account? That doesn't work at the\n// moment, so for now this is probably okay.\nclass UiEditorScreen extends _UiRestrictedScreen_js__WEBPACK_IMPORTED_MODULE_1__.UiRestrictedScreen {\n    static NAME = \"editor\";\n\n    constructor(screenParameters) {\n        super(\"#editor-screen-template\", screenParameters);\n    }\n\n    initRestricted() {\n        (0,_model_data_js__WEBPACK_IMPORTED_MODULE_0__.initData)(this.screenParameters.presentation);\n\n        this.navBarInfo = document.querySelector(\".id-info\");\n        this.navBarInfo.classList.remove(\"hidden\");\n        this.getProjectDataForNavbar();\n        this.copyLinkButton = document.querySelector(\"#copy-link-button\");\n        this.copyLinkButton.classList.remove(\"hidden\");\n        this.copyLinkButton.addEventListener(\"click\", () => this.onCopyLinkButtonClicked());\n\n        this.thumbnailBar = new _thumbnail_sidebar_UiThumbnailBar_js__WEBPACK_IMPORTED_MODULE_2__.UiThumbnailBar(this);\n        this.contentCenter = new _content_center_UiContentCenter_js__WEBPACK_IMPORTED_MODULE_3__.UiContentCenter(this);\n        this.timeline = new _timeline_UiTimeline_js__WEBPACK_IMPORTED_MODULE_4__.UiTimeline(this);\n        this.rightSideBar = new _comment_sidebar_UiRightSidebar_js__WEBPACK_IMPORTED_MODULE_5__.UiRightSidebar(this);\n    }\n\n    terminateRestricted() {\n        this.rightSideBar.terminate();\n        this.timeline.terminate();\n        this.contentCenter.terminate();\n        this.thumbnailBar.terminate();\n\n        (0,_model_data_js__WEBPACK_IMPORTED_MODULE_0__.terminateData)();\n    }\n\n    async getProjectDataForNavbar() {\n        let appwritePresentation = await _common_model_appwrite_js__WEBPACK_IMPORTED_MODULE_7__.appwrite.database.getDocument(\"presentations\", this.screenParameters.presentation);\n        this.navBarInfo.textContent = appwritePresentation.title;\n    }\n\n    onCopyLinkButtonClicked() {\n        navigator.clipboard.writeText(window.location.href);\n\n        // TODO: Make this a custom popup (like we do with the presentation creation dialog).\n        //alert(\"URL copied to clipboard!!!\");\n    }\n}\n\n_uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_6__.uiScreenRegistry.add(UiEditorScreen);\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/UiEditorScreen.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/UiPageCanvas.js":
/*!***************************************************!*\
  !*** ./app/src/screens/editor/ui/UiPageCanvas.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiPageCanvas\": () => (/* binding */ UiPageCanvas)\n/* harmony export */ });\n// All the code that is necessary for feeding the PDFJS render output into a canvas.\n// Currently used for the main PDF display and the thumbnail preview.\nclass UiPageCanvas {\n    constructor(canvasEl) {\n        this.canvasEl = canvasEl;\n        this.canvasCtx = this.canvasEl.getContext(\"2d\");\n        this.currentRenderTask = null;\n        this.currentPage = null;\n    }\n\n    // This will be how big the canvas shows up in the UI.\n    // Always call this before rendering, to keep the aspect ratio reasonable!\n    // The PDF will be rendered at the same resolution as its canvas in the UI.\n    setDimensions(width, height) {\n        // Support HiDPI-screens.\n        let outputScale = window.devicePixelRatio || 1;\n\n        this.canvasEl.width = Math.floor(width * outputScale);\n        this.canvasEl.height = Math.floor(height * outputScale);\n\n        this.canvasEl.style.width = Math.floor(width) + \"px\";\n        this.canvasEl.style.height = Math.floor(height) + \"px\";\n    }\n\n    /// Tells PDFJS to asynchronously draw the PDF into our canvas.\n    /// @param[pdfPage] Has type PdfPage.\n    renderPage(pdfPage) {\n        let viewport, scaleX, scaleY, renderTask;\n\n        if (pdfPage === null) {\n            return;\n        }\n\n        this.currentPdfPage = pdfPage;\n\n        if (this.currentRenderTask !== null) {\n            this.currentRenderTask.cancel();\n            this.currentRenderTask = null;\n        }\n\n        viewport = pdfPage.viewport;\n\n        // Without any transform, PDFJS will try to render in the coordinate system\n        // given by the viewport. Apply a scale to make the PDF fit into the canvas.\n        // An alternative solution might be to create a new viewport, but this seems nicest.\n        scaleX = this.canvasEl.width / viewport.width;\n        scaleY = this.canvasEl.height / viewport.height;\n\n        renderTask = pdfPage.pdfJsPage.render({\n            canvasContext: this.canvasCtx,\n\n            // I think this encodes the first two rows of the 3x3 homogeneous transform in column-major\n            // layout (last row can be set to 0 0 1 for affine transforms). It is applied like so:\n            // transformed_x = transform[0]*x + transform[2]*y + transform[4]\n            // transformed_y = transform[1]*x + transform[3]*y + transform[5]\n            transform: [scaleX, 0, 0, scaleY, 0, 0],\n\n            viewport,\n        });\n\n        this.currentRenderTask = renderTask;\n\n        (async () => {\n            await renderTask.promise;\n            this.currentRenderTask = null;\n        })();\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/UiPageCanvas.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/comment-sidebar/UiComment.js":
/*!****************************************************************!*\
  !*** ./app/src/screens/editor/ui/comment-sidebar/UiComment.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiComment\": () => (/* binding */ UiComment)\n/* harmony export */ });\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n/* harmony import */ var _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/model/AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n\n\n\nclass UiComment {\n    constructor(comment, parent, versionComment) {\n        this.parent = parent;\n        this.versionComment = versionComment;\n        this.comment = comment;\n\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__.cloneDomTemplate)(\"#thread-template\");\n\n        this.textEl = this.el.querySelector(\".thread-title\");\n        this.textEl.textContent = comment.text;\n\n        this.authorEl = this.el.querySelector(\".thread-author\");\n        this.authorEl.textContent = comment.author;\n\n        this.header = this.el.querySelector(\".thread-header\");\n        //this.header.addEventListener(\"click\", () => this.clicked());\n\n        this.comments = this.el.querySelector(\".thread-comments\");\n        this.comments.style.display = \"none\";\n\n        this.like = this.el.querySelector(\".thread-like\");\n        this.like.addEventListener(\"click\", () => this.likeClicked());\n        this.likeFilled = this.el.querySelector(\".thread-like-filled\");\n        this.likeFilled.addEventListener(\"click\", () => this.likeClicked());\n\n        this.arrowUp = this.el.querySelector(\".thread-arrow-up\");\n        this.arrowUp.addEventListener(\"click\", () => this.clicked());\n        this.arrowDown = this.el.querySelector(\".thread-arrow-down\");\n        this.arrowDown.addEventListener(\"click\", () => this.clicked());\n\n        this.likeCounter = this.el.querySelector(\".like-counter\");\n        this.likeCounter.textContent = comment.likes.length;\n\n        this.liked = false;\n        this.checkForLike(comment);\n        this.addComments(comment);\n    }\n\n    checkForLike(comment) {\n        comment.likes.forEach(id => {\n            if(id === _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_1__.accountSession.accountId) {\n                this.toggleLike();\n                this.liked = true;\n            }\n        });\n    }\n\n    addComments(comment) {\n        this.comments.innerHTML = \"\";\n        this.comment = comment;\n        for(let i = 0; i < comment.authors.length; i++) {\n            let commentElement = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__.cloneDomTemplate)(\"#thread-comment-template\"),\n                commentElementText = commentElement.querySelector(\".comment-text\"),\n                commentElementAuthor = commentElement.querySelector(\".comment-author\");\n                commentElementText.textContent = comment.messages[i];\n            commentElementAuthor.textContent = comment.authors[i];\n            this.comments.appendChild(commentElement);\n        }\n    }\n\n    clicked() {\n        this.parent.shutDownLastOpen(this);\n        this.toggle();\n    }\n\n    likeClicked() {\n        this.toggleLike();\n        if(this.liked) {\n            this.versionComment.changeLikeStatus(false, this);\n            this.liked = false;\n        }else{\n            this.versionComment.changeLikeStatus(true, this);\n            this.liked = true;\n        }\n        \n    }\n\n    likesChanged(newLikes) {\n        this.likeCounter.textContent = newLikes.length;\n        this.comment.likes = newLikes;\n    }\n\n    toggle() {\n        if (this.comments.style.display === \"none\") {\n            this.comments.style.display = \"block\";\n            this.arrowUp.classList.add(\"hidden\");\n            this.arrowDown.classList.remove(\"hidden\");\n            this.versionComment.subscribeToCommentDocument(this);\n            this.versionComment.loadNewestComments(this);\n            this.versionComment.commentOpened();\n        } else {\n            this.comments.style.display = \"none\";\n            this.arrowUp.classList.remove(\"hidden\");\n            this.arrowDown.classList.add(\"hidden\");\n            this.versionComment.unsubscribeFunc();\n            this.versionComment.commentClosed();\n        }\n    }\n\n    toggleLike() {\n        this.likeFilled.classList.toggle(\"hidden\");\n        this.like.classList.toggle(\"hidden\");\n    }\n\n    terminate() {\n        return;\n    }\n\n    addComment(author, text) {\n        let commentElement = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__.cloneDomTemplate)(\"#thread-comment-template\"),\n            commentElementText = commentElement.querySelector(\".comment-text\"),\n            commentElementAuthor = commentElement.querySelector(\".comment-author\");\n        commentElementText.textContent = text;\n\n        commentElementAuthor.textContent = author;\n\n        this.comments.appendChild(commentElement);\n        this.comment.authors.push(author);\n        this.comment.messages.push(text);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/comment-sidebar/UiComment.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/comment-sidebar/UiCommentEditor.js":
/*!**********************************************************************!*\
  !*** ./app/src/screens/editor/ui/comment-sidebar/UiCommentEditor.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiCommentEditor\": () => (/* binding */ UiCommentEditor)\n/* harmony export */ });\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/EditorCommentEditing.js */ \"./app/src/screens/editor/model/EditorCommentEditing.js\");\n\n\n\n\nclass UiCommentEditor {\n    constructor(screen) {\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__.Listener();\n        this.el = screen.el.querySelector(\".id-comment-editor\");\n\n        this.nameInputFieldEl = screen.el.querySelector(\".id-name-input\");\n\n        this.quitEditingButtonEl = screen.el.querySelector(\".id-quit-editing-button\");\n        this.quitEditingButtonEl.addEventListener(\"click\", () => this.onQuitEditingButtonClicked());\n\n        this.commentInputFieldEl = screen.el.querySelector(\".id-comment-input\");\n        this.commentInputFieldEl.addEventListener(\"keydown\", e => this.onKeyDown(e));\n\n        this.commentEditorText = screen.el.querySelector(\".comment-editor-text\");\n\n        this.setVisible(false);\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_0__.data.commentEditing.addEventListener(_model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_2__.EditorCommentEditing.EVENT_COMMENT_EDITING_STARTED, () => this.onCommentEditingStarted(), this.listener);\n        _model_data_js__WEBPACK_IMPORTED_MODULE_0__.data.commentEditing.addEventListener(_model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_2__.EditorCommentEditing.EVENT_COMMENT_EDITING_FINISHED, () => this.onCommentEditingFinished(), this.listener);\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    setVisible(visible) {\n        if (visible) {\n            this.el.style = \"\";\n            this.quitEditingButtonEl.style = \"\";\n            this.commentEditorText.textContent = \"Add Thread\";\n            \n        } else {\n            this.el.style = \"display: none\";\n        }\n    }\n\n    onKeyDown(e) {\n        if(this.commentEditorText.textContent !== \"Add Thread\") {\n            return;\n        }\n        if(e.keyCode !== /* enter */ 13) {\n            return;\n        }\n\n        // TODO: (Why) do we need this?\n        e.preventDefault();\n        \n        _model_data_js__WEBPACK_IMPORTED_MODULE_0__.data.commentEditing.editedVersionComment.comment.author = this.nameInputFieldEl.value;\n        _model_data_js__WEBPACK_IMPORTED_MODULE_0__.data.commentEditing.editedVersionComment.comment.text = this.commentInputFieldEl.value;\n        this.commentInputFieldEl.value = \"\";\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_0__.data.commentEditing.finishEditingComment(true);\n    }\n\n    onQuitEditingButtonClicked() {\n        _model_data_js__WEBPACK_IMPORTED_MODULE_0__.data.commentEditing.finishEditingComment(false);\n    }\n\n    onCommentEditingStarted() {\n        this.setVisible(true);\n    }\n\n    onCommentEditingFinished() {\n        this.setVisible(false);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/comment-sidebar/UiCommentEditor.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/comment-sidebar/UiCommentList.js":
/*!********************************************************************!*\
  !*** ./app/src/screens/editor/ui/comment-sidebar/UiCommentList.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiCommentList\": () => (/* binding */ UiCommentList)\n/* harmony export */ });\n/* harmony import */ var _common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/ObservableArray.js */ \"./app/src/common/model/ObservableArray.js\");\n/* harmony import */ var _UiComment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UiComment.js */ \"./app/src/screens/editor/ui/comment-sidebar/UiComment.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/EditorCommentEditing.js */ \"./app/src/screens/editor/model/EditorCommentEditing.js\");\n\n\n\n\n\n\nclass UiCommentList {\n    constructor(screen) {\n        this.el = screen.el.querySelector(\".id-comment-list\");\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_3__.Listener();\n\n        this.uiComments = [];\n        this.lastOpen = null;\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.addEventListener(_model_data_js__WEBPACK_IMPORTED_MODULE_2__.EditorData.EVENT_VERSION_COMMENT_QUERY_CHANGED, () => this.onVersionCommentQueryChanged(), this.listener);\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.commentEditing.addEventListener(_model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_4__.EditorCommentEditing.EVENT_COMMENT_EDITING_STARTED, () => this.onCommentEditingStarted(), this.listener);\n\n        this.el2 = screen.el.querySelector(\".id-comment-editor\");\n\n        this.nameInputFieldEl = screen.el.querySelector(\".id-name-input\");\n\n        this.quitEditingButtonEl = screen.el.querySelector(\".id-quit-editing-button\");\n\n        this.commentInputFieldEl = screen.el.querySelector(\".id-comment-input\");\n        this.commentInputFieldEl.addEventListener(\"keydown\", e => this.onKeyDown(e));\n\n        this.commentEditorText = screen.el.querySelector(\".comment-editor-text\");\n    }\n\n\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    onVersionCommentQueryChanged() {\n        this.clearUiComments();\n        \n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.versionCommentQuery.versionComments.addEventListener(_common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_0__.ObservableArray.EVENT_ITEM_ADDED, e => this.onVersionCommentAdded(e.data.item), this.listener);\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.versionCommentQuery.versionComments.addEventListener(_common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_0__.ObservableArray.EVENT_CLEARED, () => this.clearUiComments(), this.listener);\n    }\n\n    onVersionCommentAdded(versionComment) {\n        let uiComment = new _UiComment_js__WEBPACK_IMPORTED_MODULE_1__.UiComment(versionComment.comment, this, versionComment);\n        for(let i = 0; i < this.uiComments.length; i++) {\n            if(this.uiComments[i].comment.likes.length < uiComment.comment.likes.length) {\n                this.el.insertBefore(uiComment.el, this.uiComments[i].el);\n                this.uiComments.splice(this.uiComments.indexOf(this.uiComments[i]), 0, uiComment);\n                return;\n            }\n        }\n        this.el.appendChild(uiComment.el);\n        this.uiComments.push(uiComment);\n    }\n\n    clearUiComments() {\n        this.uiComments.forEach(uiComment => {\n            uiComment.terminate();\n        });\n        this.el.innerHTML = \"\";\n    }\n\n    onCommentEditingStarted() {\n        if(this.lastOpen !== null) {\n            this.lastOpen.toggle();\n            this.lastOpen = null;\n        }\n    }\n\n    toggleCommentEditor(visible) {\n        if (visible) {\n            this.el2.style = \"\";\n            this.quitEditingButtonEl.style = \"display: none\";\n            this.commentEditorText.textContent = \"Add Comment\";\n        } else {\n            this.el2.style = \"display: none\";\n        }\n    }\n\n    shutDownLastOpen(elem) {\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.commentEditing.finishEditingComment(false);\n        // Kein zuletzt geöffnetes\n        if(this.lastOpen === null) {\n            this.lastOpen = elem;\n            this.toggleCommentEditor(true);\n            return;\n        }\n        // Zuletzt geöffnetes ist neu geöffnetes\n        if(this.lastOpen === elem) {\n            this.lastOpen = null;\n            this.toggleCommentEditor(false);\n            return;\n        }\n        // Zuletzt geöffnetes und neu geöffnetes unterschiedlich\n        this.lastOpen.toggle();\n        this.lastOpen = elem;\n        this.toggleCommentEditor(true);\n    }\n\n    onKeyDown(e) {\n        if(this.commentEditorText.textContent !== \"Add Comment\") {\n            return;\n        }\n        if(e.keyCode !== /* enter */ 13) {\n            return;\n        }\n        this.lastOpen.versionComment.submitComment(this.nameInputFieldEl.value, this.commentInputFieldEl.value);\n    }\n\n}\n\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/comment-sidebar/UiCommentList.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/comment-sidebar/UiRightSidebar.js":
/*!*********************************************************************!*\
  !*** ./app/src/screens/editor/ui/comment-sidebar/UiRightSidebar.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiRightSidebar\": () => (/* binding */ UiRightSidebar)\n/* harmony export */ });\n/* harmony import */ var _UiCommentEditor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UiCommentEditor.js */ \"./app/src/screens/editor/ui/comment-sidebar/UiCommentEditor.js\");\n/* harmony import */ var _UiCommentList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UiCommentList.js */ \"./app/src/screens/editor/ui/comment-sidebar/UiCommentList.js\");\n\n\n\nclass UiRightSidebar {\n    constructor(screen) {\n        this.el = screen.el.querySelector(\".id-sidebar-right\");\n\n        this.commentList = new _UiCommentList_js__WEBPACK_IMPORTED_MODULE_1__.UiCommentList(screen);\n        this.commentEditor = new _UiCommentEditor_js__WEBPACK_IMPORTED_MODULE_0__.UiCommentEditor(screen);\n    }\n\n    terminate() {\n        this.commentList.terminate();\n        this.commentEditor.terminate();\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/comment-sidebar/UiRightSidebar.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/content-center/UiCanvasLayer.js":
/*!*******************************************************************!*\
  !*** ./app/src/screens/editor/ui/content-center/UiCanvasLayer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiCanvasLayer\": () => (/* binding */ UiCanvasLayer)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/EditorSelTracker.js */ \"./app/src/screens/editor/model/EditorSelTracker.js\");\n/* harmony import */ var _UiPageCanvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../UiPageCanvas.js */ \"./app/src/screens/editor/ui/UiPageCanvas.js\");\n/* harmony import */ var _UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UiPageRectTracker.js */ \"./app/src/screens/editor/ui/content-center/UiPageRectTracker.js\");\n\n\n\n\n\n\nclass UiCanvasLayer {\n    constructor(screen, pageRectTracker) {\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n\n        this.pageCanvas = new _UiPageCanvas_js__WEBPACK_IMPORTED_MODULE_3__.UiPageCanvas(screen.el.querySelector(\".id-pdf-canvas\"));\n\n        this.pageRectTracker = pageRectTracker;\n        this.pageRectTracker.addEventListener(_UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_4__.UiPageRectTracker.EVENT_PAGE_RECT_CHANGED, () => this.updateTransform(), this.listener);\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.addEventListener(_model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__.EditorSelTracker.EVENT_ACTIVE_PAGE_CHANGED, () => this.onActivePageChanged(), this.listener);\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    async onActivePageChanged() {\n        let activePdfPage = await _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage,\n            viewport = activePdfPage.viewport;\n\n        this.pageCanvas.setDimensions(viewport.width, viewport.height);\n        this.pageCanvas.renderPage(activePdfPage);\n    }\n\n    updateTransform() {\n        let pageRect, scale;\n\n        pageRect = this.pageRectTracker.computePageRect();\n        this.pageCanvas.canvasEl.style.transformOrigin = \"left top\";\n\n        scale = (pageRect.right - pageRect.left) / _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage.viewport.width;\n        this.pageCanvas.canvasEl.style.transform = `matrix(${scale}, 0, 0, ${scale}, ${pageRect.left}, ${pageRect.top})`;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/content-center/UiCanvasLayer.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/content-center/UiCommentMarker.js":
/*!*********************************************************************!*\
  !*** ./app/src/screens/editor/ui/content-center/UiCommentMarker.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiCommentMarker\": () => (/* binding */ UiCommentMarker)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_VersionComment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/model/VersionComment.js */ \"./app/src/common/model/VersionComment.js\");\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../common/utils.js */ \"./app/src/common/utils.js\");\n/* harmony import */ var _UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UiPageRectTracker.js */ \"./app/src/screens/editor/ui/content-center/UiPageRectTracker.js\");\n\n\n\n\n\n\nclass UiCommentMarker {\n    constructor(pageRectTracker, versionComment) {\n        this.pageRectTracker = pageRectTracker;\n        this.versionComment = versionComment;\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__.cloneDomTemplate)(\"#comment-marker\");\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n\n        this.versionComment.addEventListener(_common_model_VersionComment_js__WEBPACK_IMPORTED_MODULE_1__.VersionComment.EVENT_PAGE_POS_CHANGED, () => this.updatePosition(), this.listener);\n        this.pageRectTracker.addEventListener(_UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_4__.UiPageRectTracker.EVENT_PAGE_RECT_CHANGED, () => this.updatePosition(), this.listener);\n        this.versionComment.addEventListener(_common_model_VersionComment_js__WEBPACK_IMPORTED_MODULE_1__.VersionComment.EVENT_SELECTED, e => this.setSelected(e), this.listener);\n\n        this.updatePosition();\n    }\n\n    terminate() {\n        this.el.remove();\n        this.listener.terminate();\n    }\n\n    updatePosition() {\n        let pageRect, x, y;\n\n        pageRect = this.pageRectTracker.computePageRect();\n\n        x = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_3__.lerp)(pageRect.left, pageRect.right, this.versionComment.pageX);\n        y = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_3__.lerp)(pageRect.top, pageRect.bottom, this.versionComment.pageY);\n\n        this.el.style.left = `${x}px`;\n        this.el.style.top = `${y}px`;\n    }\n\n    setSelected(e) {\n        if(e.data.open) {\n            this.el.classList.remove(\"h-4\", \"w-4\");\n            this.el.classList.add(\"h-6\", \"w-6\");\n        }else{\n            this.el.classList.remove(\"h-6\", \"w-6\");\n            this.el.classList.add(\"h-4\", \"w-4\");\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/content-center/UiCommentMarker.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/content-center/UiContentCenter.js":
/*!*********************************************************************!*\
  !*** ./app/src/screens/editor/ui/content-center/UiContentCenter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiContentCenter\": () => (/* binding */ UiContentCenter)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _common_model_Comment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../common/model/Comment.js */ \"./app/src/common/model/Comment.js\");\n/* harmony import */ var _common_model_VersionComment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../common/model/VersionComment.js */ \"./app/src/common/model/VersionComment.js\");\n/* harmony import */ var _UiTextLayer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UiTextLayer.js */ \"./app/src/screens/editor/ui/content-center/UiTextLayer.js\");\n/* harmony import */ var _UiMarkerLayer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UiMarkerLayer.js */ \"./app/src/screens/editor/ui/content-center/UiMarkerLayer.js\");\n/* harmony import */ var _UiCanvasLayer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UiCanvasLayer.js */ \"./app/src/screens/editor/ui/content-center/UiCanvasLayer.js\");\n/* harmony import */ var _UiViewportScrollbar_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UiViewportScrollbar.js */ \"./app/src/screens/editor/ui/content-center/UiViewportScrollbar.js\");\n/* harmony import */ var _UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./UiPageRectTracker.js */ \"./app/src/screens/editor/ui/content-center/UiPageRectTracker.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../common/utils.js */ \"./app/src/common/utils.js\");\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nclass UiContentCenterState {\n    constructor(pageRectTracker) {\n        this.pageRectTracker = pageRectTracker;\n        this.nextState = null;\n    }\n\n    changeToState(nextState) {\n        this.nextState = nextState;\n    }\n\n    // Override those to handle the events.\n    onMouseDown(e) {\n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.unused)(e);\n    }\n\n    onMouseUp(e) { \n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.unused)(e);\n    }\n\n    onMouseMotion(e) {\n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.unused)(e);\n    }\n\n    onMouseLeave(e) {\n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.unused)(e);\n    }\n\n    onWheel(e) {\n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.unused)(e);\n    }\n}\n\nfunction translateRect(rect, xOffset, yOffset) {\n    rect.left   += xOffset;\n    rect.right  += xOffset;\n    rect.top    += yOffset;\n    rect.bottom += yOffset;\n}\n\nfunction scaleRect(rect, factor) {\n    rect.left   *= factor;\n    rect.right  *= factor;\n    rect.top    *= factor;\n    rect.bottom *= factor;\n}\n\nclass UiContentCenterPanningState extends UiContentCenterState {\n    onMouseUp(e) {\n        if (e.button === _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_10__.MouseButtonCodes.MIDDLE) {\n            this.changeToState(new UiContentCenterMainState(this.pageRectTracker));\n        }\n    }\n\n    onMouseLeave(e) {\n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.unused)(e);\n        this.changeToState(new UiContentCenterMainState(this.pageRectTracker));\n    }\n\n    onMouseMotion(e) {\n        let pageRect = this.pageRectTracker.computePageRect();\n        translateRect(pageRect, e.movementX, e.movementY);\n        this.pageRectTracker.setPageRect(pageRect);\n    }\n}\n\nclass UiContentCenterMainState extends UiContentCenterState {\n    onMouseDown(e) {\n        switch (e.button) {\n            // Start panning.\n            case _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_10__.MouseButtonCodes.MIDDLE: {\n                this.changeToState(new UiContentCenterPanningState(this.pageRectTracker));\n            } break;\n\n            // Add a comment marker.\n            case _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_10__.MouseButtonCodes.LEFT: {\n                let viewportX, viewportY, pageRect, pageX, pageY;\n\n                [viewportX, viewportY] = this.pageRectTracker.clientToViewportCoords(e.clientX, e.clientY);\n                pageRect = this.pageRectTracker.computePageRect();\n\n                pageX = (viewportX - pageRect.left) / (pageRect.right - pageRect.left);\n                pageY = (viewportY - pageRect.top) / (pageRect.bottom - pageRect.top);\n\n                if (_model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.commentEditing.isEditing()) {\n                    _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.commentEditing.editedVersionComment.setPagePos(pageX, pageY);\n                } else {\n                    let comment = new _common_model_VersionComment_js__WEBPACK_IMPORTED_MODULE_3__.VersionComment(_model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.version, _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePageNo, new _common_model_Comment_js__WEBPACK_IMPORTED_MODULE_2__.Comment(\"\", \"\"), pageX, pageY);\n                    _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.commentEditing.startEditingComment(comment);\n                }\n            } break;\n\n            default: break;\n        }\n    }\n\n    static ZOOM_STEP = 1.3;\n    static ZOOM_MIN = Math.pow(UiContentCenterMainState.ZOOM_STEP, -8);\n    static ZOOM_MAX = Math.pow(UiContentCenterMainState.ZOOM_STEP, +8);\n    onWheel(e) {\n        let normalizedDelta, factor, pageRect, viewportMouseX, viewportMouseY;\n\n        // For some reason, a single scroll step has e.deltaY = 102 (Windows 10).\n        // TODO: Does this depend on the OS?\n        normalizedDelta = e.deltaY / 102;\n        factor = Math.pow(UiContentCenterMainState.ZOOM_STEP, -normalizedDelta);\n        factor = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.clamped)(\n            factor,\n            UiContentCenterMainState.ZOOM_MIN / _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.viewingArea.zoom,\n            UiContentCenterMainState.ZOOM_MAX / _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.viewingArea.zoom);\n\n        pageRect = this.pageRectTracker.computePageRect();\n        [viewportMouseX, viewportMouseY] = this.pageRectTracker.clientToViewportCoords(e.clientX, e.clientY);\n\n        translateRect(pageRect, -viewportMouseX, -viewportMouseY);\n        scaleRect(pageRect, factor);\n        translateRect(pageRect, viewportMouseX, viewportMouseY);\n        this.pageRectTracker.setPageRect(pageRect);\n\n        // Prevent the browser from resizing the page when Ctrl is pressed.\n        if (e.ctrlKey) {\n            e.preventDefault();\n        }\n    }\n}\n\n// The PDF-viewer proper. We only display a single page for now.\n// PDFJS renders into a canvas, however this alone does not allow for selecting\n// text. We therefore construct a rough facsimile (the \"text layer\") of the PDF in the DOM.\n// PDFJS does this for us. This facsimile is positioned atop the canvas. The text is all there,\n// but we make it transparent. A good way to understand how this works is to using element inspection\n// in your web browser.\nclass UiContentCenter {\n    constructor(screen) {\n        this.pageRectTracker = new _UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_8__.UiPageRectTracker(screen);\n\n        this.canvasLayer = new _UiCanvasLayer_js__WEBPACK_IMPORTED_MODULE_6__.UiCanvasLayer(screen, this.pageRectTracker);\n        this.markerLayer = new _UiMarkerLayer_js__WEBPACK_IMPORTED_MODULE_5__.UiMarkerLayer(screen, this.pageRectTracker);\n        this.textLayer = new _UiTextLayer_js__WEBPACK_IMPORTED_MODULE_4__.UiTextLayer(screen, this.pageRectTracker);\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n\n        this.scrollbarX = new _UiViewportScrollbar_js__WEBPACK_IMPORTED_MODULE_7__.UiViewportScrollbar(screen, this.pageRectTracker, \"x\");\n        this.scrollbarY = new _UiViewportScrollbar_js__WEBPACK_IMPORTED_MODULE_7__.UiViewportScrollbar(screen, this.pageRectTracker, \"y\");\n\n        this.viewportEl = this.pageRectTracker.viewportEl;\n        this.wireUpViewportEvent(\"mousedown\", \"onMouseDown\");\n        this.wireUpViewportEvent(\"mouseup\", \"onMouseUp\");\n        this.wireUpViewportEvent(\"wheel\", \"onWheel\");\n        this.wireUpViewportEvent(\"mousemove\", \"onMouseMotion\");\n        this.wireUpViewportEvent(\"mouseleave\", \"onMouseLeave\");\n\n        this.state = new UiContentCenterMainState(this.pageRectTracker);\n    }\n\n    terminate() {\n        this.listener.terminate();\n        this.textLayer.terminate();\n        this.markerLayer.terminate();\n        this.canvasLayer.terminate();\n        this.scrollbarX.terminate();\n        this.scrollbarY.terminate();\n    }\n\n    pollStateChange() {\n        if (this.state.nextState) {\n            this.state = this.state.nextState;\n        }\n    }\n\n    wireUpViewportEvent(jsEventName, handlerFuncName) {\n        this.viewportEl.addEventListener(jsEventName, e => {\n            this.state[handlerFuncName](e);\n            this.pollStateChange();\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/content-center/UiContentCenter.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/content-center/UiMarkerLayer.js":
/*!*******************************************************************!*\
  !*** ./app/src/screens/editor/ui/content-center/UiMarkerLayer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiMarkerLayer\": () => (/* binding */ UiMarkerLayer)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/model/ObservableArray.js */ \"./app/src/common/model/ObservableArray.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/EditorCommentEditing.js */ \"./app/src/screens/editor/model/EditorCommentEditing.js\");\n/* harmony import */ var _UiCommentMarker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UiCommentMarker.js */ \"./app/src/screens/editor/ui/content-center/UiCommentMarker.js\");\n\n\n\n\n\n\nclass UiMarkerLayer {\n    constructor(screen, pageRectTracker) {\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n\n        this.pageRectTracker = pageRectTracker;\n\n        this.commentMarkers = [];\n\n        this.commentEditingMarker = null;\n        this.markerContainerEl = screen.el.querySelector(\".id-marker-container\");\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.commentEditing.addEventListener(_model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_3__.EditorCommentEditing.EVENT_COMMENT_EDITING_STARTED, () => this.onCommentEditingStarted(), this.listener);\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.commentEditing.addEventListener(_model_EditorCommentEditing_js__WEBPACK_IMPORTED_MODULE_3__.EditorCommentEditing.EVENT_COMMENT_EDITING_FINISHED, () => this.onCommentEditingFinished(), this.listener);\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.addEventListener(_model_data_js__WEBPACK_IMPORTED_MODULE_2__.EditorData.EVENT_VERSION_COMMENT_QUERY_CHANGED, () => this.onVersionCommentQueryChanged(), this.listener);\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    async onCommentEditingStarted() {\n        this.commentEditingMarker = this.createCommentMarker(_model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.commentEditing.editedVersionComment);\n    }\n\n    onVersionCommentQueryChanged() {\n        this.clearCommentMarkers();\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.versionCommentQuery.versionComments.addEventListener(_common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_1__.ObservableArray.EVENT_ITEM_ADDED, e => this.createCommentMarker(e.data.item), this.listener);\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.versionCommentQuery.versionComments.addEventListener(_common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_1__.ObservableArray.EVENT_CLEARED, () => this.clearCommentMarkers(), this.listener);\n    }\n\n    onCommentEditingFinished() {\n        this.commentEditingMarker?.terminate();\n        this.commentEditingMarker = null;\n    }\n\n    createCommentMarker(versionComment) {\n        let commentMarker = new _UiCommentMarker_js__WEBPACK_IMPORTED_MODULE_4__.UiCommentMarker(this.pageRectTracker, versionComment);\n        this.commentMarkers.push(commentMarker);\n        this.markerContainerEl.appendChild(commentMarker.el);\n\n        return commentMarker;\n    }\n\n    clearCommentMarkers() {\n        this.commentMarkers.forEach(commentMarker => {\n            commentMarker.terminate();\n        });\n        this.commentMarkers.length = 0;\n\n        this.markerContainerEl.innerHTML = \"\";\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/content-center/UiMarkerLayer.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/content-center/UiPageRectTracker.js":
/*!***********************************************************************!*\
  !*** ./app/src/screens/editor/ui/content-center/UiPageRectTracker.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiPageRectTracker\": () => (/* binding */ UiPageRectTracker)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/EditorSelTracker.js */ \"./app/src/screens/editor/model/EditorSelTracker.js\");\n/* harmony import */ var _model_ViewingArea_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/ViewingArea.js */ \"./app/src/screens/editor/model/ViewingArea.js\");\n\n\n\n\n\nclass UiPageRectTracker extends _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    static EVENT_PAGE_RECT_CHANGED = \"PAGE_RECT_CHANGED\";\n\n    constructor(screen) {\n        super();\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n        this.viewportEl = screen.el.querySelector(\".id-viewport\");\n        this.resizeObserver = new ResizeObserver(entries => {\n            for (let entry of entries) {\n                if (entry.contentBoxSize && _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage) {\n                    this.emitChangeEvent();\n                }\n            }\n        });\n        this.resizeObserver.observe(this.viewportEl);\n\n        // Changing the active page might change the aspect ratio, which in turn changes the page rect.\n        _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.addEventListener(_model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__.EditorSelTracker.EVENT_ACTIVE_PAGE_CHANGED, () => this.emitChangeEvent(), this.listener);\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.viewingArea.addEventListener(_model_ViewingArea_js__WEBPACK_IMPORTED_MODULE_3__.EditorViewingArea.EVENT_CHANGED, () => this.emitChangeEvent(), this.listener);\n    }\n\n    terminate() {\n        super.terminate();\n        this.listener.terminate();\n        this.resizeObserver.unobserve(this.viewportEl);\n    }\n\n    emitChangeEvent() {\n        this.notifyAll(new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Event(UiPageRectTracker.EVENT_PAGE_RECT_CHANGED, {}));\n    }\n\n    getViewportWidth() {\n        return this.viewportEl.offsetWidth;\n    }\n\n    getViewportHeight() {\n        return this.viewportEl.offsetHeight;\n    }\n\n    clientToViewportCoords(clientX, clientY) {\n        let boundingRect, viewportX, viewportY;\n\n        boundingRect = this.viewportEl.getBoundingClientRect();\n        \n        viewportX = clientX - boundingRect.left;\n        viewportY = clientY - boundingRect.top;\n\n        return [viewportX, viewportY];\n    }\n\n    computePageRect() {\n        let asp, pageRect;\n\n        asp = 1;\n        if (_model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage !== null) {\n            asp = _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage.asp;\n        }\n        pageRect = _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.viewingArea.computePageRect(asp, this.viewportEl.offsetWidth, this.viewportEl.offsetHeight);\n        return pageRect;\n    }\n\n    setPageRect(pageRect) {\n        if (_model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage === null) {\n            return;\n        }\n        _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.viewingArea.setPageRect(_model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage.asp, this.viewportEl.offsetWidth, this.viewportEl.offsetHeight, pageRect);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/content-center/UiPageRectTracker.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/content-center/UiTextLayer.js":
/*!*****************************************************************!*\
  !*** ./app/src/screens/editor/ui/content-center/UiTextLayer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiTextLayer\": () => (/* binding */ UiTextLayer)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/EditorSelTracker.js */ \"./app/src/screens/editor/model/EditorSelTracker.js\");\n/* harmony import */ var pdfjs_dist_webpack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pdfjs-dist/webpack.js */ \"./node_modules/pdfjs-dist/webpack.js\");\n/* harmony import */ var _UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UiPageRectTracker.js */ \"./app/src/screens/editor/ui/content-center/UiPageRectTracker.js\");\n\n\n\n\n\n\nclass UiTextLayer {\n    constructor(screen, pageRectTracker) {\n        this.textLayerEl = screen.el.querySelector(\".id-pdf-text-layer\");\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n\n        this.pageRectTracker = pageRectTracker;\n        this.pageRectTracker.addEventListener(_UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_4__.UiPageRectTracker.EVENT_PAGE_RECT_CHANGED, () => this.updateTransform(), this.listener);\n\n        _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.addEventListener(_model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_2__.EditorSelTracker.EVENT_ACTIVE_PAGE_CHANGED, () => this.onActivePageChanged(), this.listener);\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    async onActivePageChanged() {\n        let activePage, pdfJsPage, viewport, textContent, textDivs, textContentItemsStr, textLayerFrag;\n\n        // TODO(optimize): Don't fetch the page everywhere.\n        activePage = _model_data_js__WEBPACK_IMPORTED_MODULE_1__.data.selTracker.activePage;\n        pdfJsPage = activePage.pdfJsPage;\n        viewport = activePage.viewport;\n\n        this.textLayerEl.innerHTML = \"\";\n\n        this.textLayerEl.style.width = Math.floor(viewport.width) + \"px\";\n        this.textLayerEl.style.height = Math.floor(viewport.height) + \"px\";\n    \n        textContent = await pdfJsPage.getTextContent();\n\n        // These two arrays will be populated by #renderTextLayer.\n        // There seems to be a one-to-one correspondence between the elements\n        // in the textDivs array and the textContentItemsStr array.\n        // TODO: Does this also hold for textContent.items?\n        textDivs = [];\n        textContentItemsStr = [];\n\n        // Also populated by #renderTextLayer.\n        textLayerFrag = document.createDocumentFragment();\n\n        await pdfjs_dist_webpack_js__WEBPACK_IMPORTED_MODULE_3__.renderTextLayer({\n            textContent: textContent,\n            // TODO: Could we be benefit from a stream-based approach?\n            textContentStream: null,\n            container: textLayerFrag,\n            viewport: viewport,\n            textDivs: textDivs,\n            textContentItemsStr: textContentItemsStr,\n            timeout: 0,\n            // TODO: Investigate what this is good for.\n            enhanceTextSelection: false,\n        });\n    \n        this.textLayerEl.appendChild(textLayerFrag);\n\n        this.updateTransform();\n    }\n\n    updateTransform() {\n        let pageRect, scale;\n\n        pageRect = this.pageRectTracker.computePageRect();\n\n        this.textLayerEl.style.transformOrigin = \"left top\";\n\n        scale = (pageRect.right - pageRect.left) / this.textLayerEl.offsetWidth;\n        this.textLayerEl.style.transform = `matrix(${scale}, 0, 0, ${scale}, ${pageRect.left}, ${pageRect.top})`;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/content-center/UiTextLayer.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/content-center/UiViewportScrollbar.js":
/*!*************************************************************************!*\
  !*** ./app/src/screens/editor/ui/content-center/UiViewportScrollbar.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiViewportScrollbar\": () => (/* binding */ UiViewportScrollbar)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_ui_UiScrollbar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/ui/UiScrollbar.js */ \"./app/src/common/ui/UiScrollbar.js\");\n/* harmony import */ var _UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UiPageRectTracker.js */ \"./app/src/screens/editor/ui/content-center/UiPageRectTracker.js\");\n\n\n\n\nclass UiViewportScrollbar extends _common_ui_UiScrollbar_js__WEBPACK_IMPORTED_MODULE_1__.UiScrollbar {\n    constructor(screen, pageRectTracker, axis) {\n        super(screen.el.querySelector(`.id-scrollbar-${axis}-container`), axis);\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n        \n        this.pageRectTracker = pageRectTracker;\n        this.pageRectTracker.addEventListener(_UiPageRectTracker_js__WEBPACK_IMPORTED_MODULE_2__.UiPageRectTracker.EVENT_PAGE_RECT_CHANGED, () => this.reconfigure(), this.listener);\n\n        this.addEventListener(_common_ui_UiScrollbar_js__WEBPACK_IMPORTED_MODULE_1__.UiScrollbar.EVENT_VISIBLE_INTERVAL_CHANGED, () => this.onVisibleIntervalChanged(), this.listener);\n    }\n\n    reconfigure() {\n        let pageRect, pageStart, pageEnd, pageSize;\n\n        pageRect = this.pageRectTracker.computePageRect();\n\n        if (this.axis === \"x\") {\n            pageStart = pageRect.left;\n            pageEnd = pageRect.right;\n        } else {\n            pageStart = pageRect.top;\n            pageEnd = pageRect.bottom;\n        }\n\n        pageSize = pageEnd - pageStart;\n\n        super.reconfigure(0, pageSize, -pageStart, this.getViewportSize() - pageStart);\n    }\n\n    onVisibleIntervalChanged() {\n        let pageRect = this.pageRectTracker.computePageRect();\n\n        if (this.axis === \"x\") {\n            let pageSize = pageRect.right - pageRect.left;\n            pageRect.left = -this.visibleStart;\n            pageRect.right = pageRect.left + pageSize;\n        } else {\n            let pageSize = pageRect.bottom - pageRect.top;\n            pageRect.top = -this.visibleStart;\n            pageRect.bottom = pageRect.top + pageSize;\n        }\n\n        this.pageRectTracker.setPageRect(pageRect);\n    }\n\n    getViewportSize() {\n        let result;\n        if (this.axis === \"x\") {\n            result = this.pageRectTracker.getViewportWidth();\n        } else {\n            result = this.pageRectTracker.getViewportHeight();\n        }\n        return result;\n    }\n\n    terminate() {\n        this.listener.terminate();\n        super.terminate();\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/content-center/UiViewportScrollbar.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnail.js":
/*!********************************************************************!*\
  !*** ./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnail.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiThumbnail\": () => (/* binding */ UiThumbnail)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n/* harmony import */ var _UiPageCanvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../UiPageCanvas.js */ \"./app/src/screens/editor/ui/UiPageCanvas.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/EditorSelTracker.js */ \"./app/src/screens/editor/model/EditorSelTracker.js\");\n\n\n\n\n\n\n// Represents the widget for a single PDF page in the thumbnail bar.\n// Instantiates the DOM template for the thumbnail. The user of the class\n// is responsible for linking UiThumbnail.el into the DOM tree.\nclass UiThumbnail {\n    constructor(pageNo) {\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_1__.cloneDomTemplate)(\"#thumbnail-template\");\n        this.el.addEventListener(\"click\", () => this.onClick());\n\n        this.pageNo = pageNo;\n        this.pageNoEl = this.el.querySelector(\".page-number\");\n        this.pageNoEl.textContent = pageNo;\n\n        let pageCanvasEl = this.el.querySelector(\"canvas\");\n        this.pageCanvas = new _UiPageCanvas_js__WEBPACK_IMPORTED_MODULE_2__.UiPageCanvas(pageCanvasEl);\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n        _model_data_js__WEBPACK_IMPORTED_MODULE_3__.data.selTracker.addEventListener(_model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_4__.EditorSelTracker.EVENT_ACTIVE_PAGE_CHANGED, () => this.updateSelectionState(), this.listener);\n        \n        this.updateSelectionState();\n        this.p_fetchPage();\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    // TODO(optimize): Lazy thumbnail loading, or at least prioritize rendering thumbnails that are in view.\n    // Asynchronously fill the canvas with our page.\n    async p_fetchPage() {\n        let activePdfPage = await _model_data_js__WEBPACK_IMPORTED_MODULE_3__.data.selTracker.pdf.fetchPage(this.pageNo),\n            [width, height] = this.computeDimensions(activePdfPage);\n        this.pageCanvas.setDimensions(width, height);\n        this.pageCanvas.renderPage(activePdfPage);\n    }\n\n    // Compute width and height such that correct proportions are preserved and the longer axis has size `TARGET_SIZE`.\n    static TARGET_SIZE = 150;\n    //static DBG_FORCE_ASP = 0.5;\n    computeDimensions(activePdfPage) {\n        // There are probably more elegant ways to do this, but hopefully this is correct ;)\n        // Note that at the end, width/height=asp as expected.\n\n        let viewport = activePdfPage.viewport,\n            width, height,\n            asp = viewport.width / viewport.height;\n        if (typeof UiThumbnail.DBG_FORCE_ASP !== \"undefined\") {\n            asp = UiThumbnail.DBG_FORCE_ASP;\n        }\n        if (asp > 1) {\n            width = UiThumbnail.TARGET_SIZE;\n            height = width / asp;\n        } else {\n            height = UiThumbnail.TARGET_SIZE;\n            width = height * asp;\n        }\n\n        return [width, height];\n    }\n\n    // TODO(optimize): This is called for every thumbnail, in theory we only need to call this for two thumbnails.\n    updateSelectionState() {\n        let isSelected = (_model_data_js__WEBPACK_IMPORTED_MODULE_3__.data.selTracker.activePageNo === this.pageNo);\n        (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureCssClassPresentIff)(isSelected, \"selected\", this.el, this.pageNoEl);\n    }\n\n    onClick() {\n        _model_data_js__WEBPACK_IMPORTED_MODULE_3__.data.selTracker.activatePage(this.pageNo);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnail.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnailBar.js":
/*!***********************************************************************!*\
  !*** ./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnailBar.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiThumbnailBar\": () => (/* binding */ UiThumbnailBar)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_VersionPdf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/model/VersionPdf.js */ \"./app/src/common/model/VersionPdf.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/EditorSelTracker.js */ \"./app/src/screens/editor/model/EditorSelTracker.js\");\n/* harmony import */ var _UiThumbnail_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UiThumbnail.js */ \"./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnail.js\");\n\n\n\n\n\n\n\nclass UiThumbnailBar {\n    constructor(screen) {\n        this.el = screen.el.querySelector(\".id-sidebar-left\");\n\n        if (_model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.hasPdf()) {\n            this.createThumbnails();\n        }\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.addEventListener(_model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_3__.EditorSelTracker.EVENT_ACTIVE_VERSION_CHANGED, () => this.onActiveVersionChanged(), this.listener);\n\n        this.uiThumbnails = [];\n    }\n\n    terminate() {\n        this.p_clearUiThumbnails();\n        this.listener.terminate();\n    }\n\n    onActiveVersionChanged() {\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.pdf.addEventListener(_common_model_VersionPdf_js__WEBPACK_IMPORTED_MODULE_1__.VersionPdf.EVENT_PDF_LOADED, () => this.createThumbnails(), this.listener);\n    }\n\n    // Responsible for creating all the little thumbnails.\n    // TODO: Remove old thumbnails once a new PDF is loaded?\n    createThumbnails() {\n        this.p_clearUiThumbnails();\n\n        let numPages = _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.pdf.numPages;\n        for (let i = 0; i < numPages; i++) {\n            let uiThumbnail = new _UiThumbnail_js__WEBPACK_IMPORTED_MODULE_4__.UiThumbnail(i + 1);\n\n            this.uiThumbnails.push(uiThumbnail);\n            this.el.appendChild(uiThumbnail.el);\n        }\n    }\n\n    p_clearUiThumbnails() {\n        this.el.innerHTML = \"\";\n        this.uiThumbnails.forEach(uiThumbnail => {\n            uiThumbnail.terminate();\n        });\n        this.uiThumbnails.length = 0;\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/thumbnail-sidebar/UiThumbnailBar.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/timeline/UiTimeline.js":
/*!**********************************************************!*\
  !*** ./app/src/screens/editor/ui/timeline/UiTimeline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiTimeline\": () => (/* binding */ UiTimeline)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/model/ObservableArray.js */ \"./app/src/common/model/ObservableArray.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _UiTimelineVersion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UiTimelineVersion.js */ \"./app/src/screens/editor/ui/timeline/UiTimelineVersion.js\");\n\n\n\n\n\nclass UiTimeline {\n    constructor(screen) {\n        this.el = screen.el.querySelector(\".id-version-list\");\n\n        this.addVersionButtonEl = screen.el.querySelector(\".id-add-version-button\");\n        this.addVersionButtonEl.addEventListener(\"click\", () => this.onAddButtonClicked());\n\n        // Hidden file input element, we only use this to open a file dialog box.\n        this.fileInputEl = screen.el.querySelector(\".id-file-input\");\n        this.fileInputEl.addEventListener(\"change\", () => this.onFileSelectorConcluded());\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.versionList.versions.addEventListener(_common_model_ObservableArray_js__WEBPACK_IMPORTED_MODULE_1__.ObservableArray.EVENT_ITEM_ADDED, e => this.onVersionAdded(e), this.listener);\n\n        this.timelineWindow = document.querySelector(\".id-bottom-bar\");\n        this.timelineHideButton = document.querySelector(\".timeline-hide-button\");\n        this.timelineHideButton.addEventListener(\"click\", () => this.timelineHideButtonClicked());\n        this.timelineHeader = document.querySelector(\".timeline-header\");\n        this.mainScreen = document.querySelector(\".main-screen\");\n        this.arrowUp = document.querySelector(\".timeline-arrow-up\");\n        this.arrowDown = document.querySelector(\".timeline-arrow-down\");\n    }\n\n    timelineHideButtonClicked() {\n        if(this.timelineWindow.style.display === \"none\") {\n            this.timelineWindow.style.display = \"block\";\n            this.timelineWindow.insertBefore(this.timelineHeader, this.el);\n            this.arrowUp.classList.add(\"hidden\");\n            this.arrowDown.classList.remove(\"hidden\");\n        }else{\n            this.timelineWindow.style.display = \"none\";\n            this.mainScreen.appendChild(this.timelineHeader);\n            this.arrowUp.classList.remove(\"hidden\");\n            this.arrowDown.classList.add(\"hidden\");\n        }\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    onVersionAdded(e) {\n        let version = e.data.item,\n            uiVersion = new _UiTimelineVersion_js__WEBPACK_IMPORTED_MODULE_3__.UiTimelineVersion(version);\n        this.el.insertBefore(uiVersion.el, this.addVersionButtonEl);\n    }\n\n    onAddButtonClicked() {\n        // Open a file dialog.\n        this.fileInputEl.click();\n    }\n\n    async onFileSelectorConcluded() {\n        let version = await _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.versionList.createVersion(_model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.presentationId, \"V\"+(_model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.versionList.versions.items.length+1), this.fileInputEl.files[0]);\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.activateVersion(version);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/timeline/UiTimeline.js?");

/***/ }),

/***/ "./app/src/screens/editor/ui/timeline/UiTimelineVersion.js":
/*!*****************************************************************!*\
  !*** ./app/src/screens/editor/ui/timeline/UiTimelineVersion.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiTimelineVersion\": () => (/* binding */ UiTimelineVersion)\n/* harmony export */ });\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../common/ui/dom-utils.js */ \"./app/src/common/ui/dom-utils.js\");\n/* harmony import */ var _model_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/data.js */ \"./app/src/screens/editor/model/data.js\");\n/* harmony import */ var _model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/EditorSelTracker.js */ \"./app/src/screens/editor/model/EditorSelTracker.js\");\n\n\n\n\n\n// An item in the timeline, representing a version of the presentation.\nclass UiTimelineVersion {\n    constructor(version) {\n        this.el = (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_1__.cloneDomTemplate)(\"#version-template\");\n\n        this.labelEl = this.el.querySelector(\".label\");\n        this.labelEl.textContent = version.label;\n\n        this.el.addEventListener(\"click\", () => this.onClick());\n\n        this.version = version;\n        this.updateSelectionState();\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_0__.Listener();\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.addEventListener(_model_EditorSelTracker_js__WEBPACK_IMPORTED_MODULE_3__.EditorSelTracker.EVENT_ACTIVE_VERSION_CHANGED, () => this.updateSelectionState(), this.listener);\n    }\n\n    terminate() {\n        this.listener.terminate();\n    }\n\n    onClick() {\n        _model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.activateVersion(this.version);\n    }\n    \n    // TODO(optimize): This is called for every version item, in theory we only need to call this twice.\n    updateSelectionState() {\n        let isSelected = (_model_data_js__WEBPACK_IMPORTED_MODULE_2__.data.selTracker.version === this.version);\n        (0,_common_ui_dom_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureCssClassPresentIff)(isSelected, \"selected\", this.el);\n    }\n}\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/editor/ui/timeline/UiTimelineVersion.js?");

/***/ }),

/***/ "./app/src/screens/import-screens.js":
/*!*******************************************!*\
  !*** ./app/src/screens/import-screens.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _login_ui_UiLoginScreen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login/ui/UiLoginScreen.js */ \"./app/src/screens/login/ui/UiLoginScreen.js\");\n/* harmony import */ var _create_account_ui_UiCreateAccountScreen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create-account/ui/UiCreateAccountScreen.js */ \"./app/src/screens/create-account/ui/UiCreateAccountScreen.js\");\n/* harmony import */ var _dashboard_ui_UiDashboardScreen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dashboard/ui/UiDashboardScreen.js */ \"./app/src/screens/dashboard/ui/UiDashboardScreen.js\");\n/* harmony import */ var _editor_ui_UiEditorScreen_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/ui/UiEditorScreen.js */ \"./app/src/screens/editor/ui/UiEditorScreen.js\");\n// Import to add the screens to the uiScreenRegistry.\n\n\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/import-screens.js?");

/***/ }),

/***/ "./app/src/screens/login/ui/UiLoginScreen.js":
/*!***************************************************!*\
  !*** ./app/src/screens/login/ui/UiLoginScreen.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UiLoginScreen\": () => (/* binding */ UiLoginScreen)\n/* harmony export */ });\n/* harmony import */ var _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/model/AccountSession.js */ \"./app/src/common/model/AccountSession.js\");\n/* harmony import */ var _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/model/Observable.js */ \"./app/src/common/model/Observable.js\");\n/* harmony import */ var _UiScreen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../UiScreen.js */ \"./app/src/screens/UiScreen.js\");\n/* harmony import */ var _uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../uiScreenRegistry.js */ \"./app/src/screens/uiScreenRegistry.js\");\n/* harmony import */ var _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../uiScreenSwapper.js */ \"./app/src/screens/uiScreenSwapper.js\");\n\n\n\n\n\n\nclass UiLoginScreen extends _UiScreen_js__WEBPACK_IMPORTED_MODULE_2__.UiScreen {\n    static NAME = \"login\";\n\n    constructor() {\n        super(\"#login-screen-template\");\n\n        this.listener = new _common_model_Observable_js__WEBPACK_IMPORTED_MODULE_1__.Listener();\n\n        this.loginFormEl = this.el.querySelector(\".id-login-form\");\n        this.emailInputEl = this.el.querySelector(\".id-email-input\");\n        this.passwordInputEl = this.el.querySelector(\".id-password-input\");\n        this.message = this.el.querySelector(\".id-message\");\n\n        this.loginFormEl.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n            this.onLogInButtonClicked();\n        });\n\n        this.createAccountButtonEl = this.el.querySelector(\".id-create-account-button\");\n        this.createAccountButtonEl.addEventListener(\"click\", () => this.onCreateAccountButtonClicked());\n\n        _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.addEventListener(\n            _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.AccountSession.EVENT_LOGIN_STATE_CHANGED,\n            () => this.onLoginStateChanged(),\n            this.listener,\n        );\n\n        this.navBarInfo = document.querySelector(\".id-info\");\n        this.navBarInfo.classList.add(\"hidden\");\n        this.copyLinkButton = document.querySelector(\"#copy-link-button\");\n        this.copyLinkButton.classList.add(\"hidden\");\n    }\n\n    terminate() {\n        super.terminate();\n        this.listener.terminate();\n    }\n\n    onLoginStateChanged() {\n        if (_common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.loginState === _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.LoginState.LOGGED_IN) {\n            _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_4__.uiScreenSwapper.loadScreen(\"dashboard\", {});\n        }\n    }\n\n    onLogInButtonClicked() {\n        let email = this.emailInputEl.value,\n            password = this.passwordInputEl.value;\n        _common_model_AccountSession_js__WEBPACK_IMPORTED_MODULE_0__.accountSession.logIn(email, password, this.message);\n    }\n\n    onCreateAccountButtonClicked() {\n        _uiScreenSwapper_js__WEBPACK_IMPORTED_MODULE_4__.uiScreenSwapper.loadScreen(\"create-account\", {});\n    }\n}\n\n_uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_3__.uiScreenRegistry.add(UiLoginScreen);\n\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/login/ui/UiLoginScreen.js?");

/***/ }),

/***/ "./app/src/screens/uiScreenRegistry.js":
/*!*********************************************!*\
  !*** ./app/src/screens/uiScreenRegistry.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"uiScreenRegistry\": () => (/* binding */ uiScreenRegistry)\n/* harmony export */ });\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.js */ \"./app/src/common/utils.js\");\n\n\nvar uiScreenRegistry;\n\nclass UiScreenRegistry {\n    constructor() {\n        this.screenClassesByName = [];\n        this.activeScreenName = null;\n    }\n\n    add(screenClass) {\n        (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.screenClassesByName[screenClass.NAME] === undefined);\n        this.screenClassesByName[screenClass.NAME] = screenClass;\n    }\n\n    getClass(screenName) {\n        return this.screenClassesByName[screenName];\n    }\n\n}\n\nuiScreenRegistry = new UiScreenRegistry();\n\n\n//# sourceURL=webpack://crity/./app/src/screens/uiScreenRegistry.js?");

/***/ }),

/***/ "./app/src/screens/uiScreenSwapper.js":
/*!********************************************!*\
  !*** ./app/src/screens/uiScreenSwapper.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"uiScreenSwapper\": () => (/* binding */ uiScreenSwapper)\n/* harmony export */ });\n/* harmony import */ var _UiScreen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UiScreen.js */ \"./app/src/screens/UiScreen.js\");\n/* harmony import */ var _uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uiScreenRegistry.js */ \"./app/src/screens/uiScreenRegistry.js\");\n\n\n\nvar uiScreenSwapper;\n\nclass UiScreenSwapper {\n    constructor() {\n        this.el = document.querySelector(\"#screen-swapper\");\n        this.screen = null;\n\n        window.onpopstate = e => this.onPopState(e);\n    }\n\n    // Called when the user navigates back in the browser.\n    onPopState(e) {\n        // Do not push, otherwise the forward-button won't work.\n        this.loadScreenFromUrl(false);\n\n        e.preventDefault();\n    }\n\n    loadScreenFromUrl(pushIntoBrowserHistory=true) {\n        // TODO: This is probably not the best place for URL parsing ...\n        let screen = (window.location.hash ? location.hash.substring(1) : \"login\"),\n            urlSearchParams = new URLSearchParams(window.location.search),\n            screenParameters = this.urlSearchParamsToObject(urlSearchParams);\n\n        this.loadScreen(screen, screenParameters, pushIntoBrowserHistory);\n    }\n\n    urlSearchParamsToObject(urlSearchParams) {\n        let result = {},\n            entries = urlSearchParams.entries();\n        for (let [key, value] of entries) {\n            result[key] = value;\n        }\n\n        return result;\n    }\n\n    // WARNING: For UiScreens, this will call the terminate function! Best idea is to not do anything after\n    // calling this!\n    loadScreen(screenToLoad, screenParameters, pushIntoBrowserHistory=true) {\n        this.el.innerHTML = \"\";\n\n        if (pushIntoBrowserHistory) {\n            let url = _UiScreen_js__WEBPACK_IMPORTED_MODULE_0__.UiScreen.formatUrl(screenToLoad, screenParameters);\n            window.history.pushState({}, \"\", url);\n        }\n\n        this.screen?.terminate();\n\n        let screenClass = _uiScreenRegistry_js__WEBPACK_IMPORTED_MODULE_1__.uiScreenRegistry.getClass(screenToLoad);\n        if (screenClass === undefined) {\n            // TODO: Proper error handling, e.g. redirect to an error screen and pass the bad screen name as a screenParameter?\n            console.error(`Tried to access bad screen ${screenToLoad}`);\n        } else {\n            this.screen = new screenClass(screenParameters);\n\n            this.el.appendChild(this.screen.el);\n    \n            this.screen.onScreenLoaded();\n        }\n    }\n}\n\nuiScreenSwapper = new UiScreenSwapper();\n\n\n\n//# sourceURL=webpack://crity/./app/src/screens/uiScreenSwapper.js?");

/***/ }),

/***/ "./node_modules/appwrite/dist/esm/sdk.js":
/*!***********************************************!*\
  !*** ./node_modules/appwrite/dist/esm/sdk.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Appwrite\": () => (/* binding */ Appwrite),\n/* harmony export */   \"Query\": () => (/* binding */ Query)\n/* harmony export */ });\n/* harmony import */ var isomorphic_form_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isomorphic-form-data */ \"./node_modules/isomorphic-form-data/lib/browser.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nclass AppwriteException extends Error {\n    constructor(message, code = 0, response = '') {\n        super(message);\n        this.name = 'AppwriteException';\n        this.message = message;\n        this.code = code;\n        this.response = response;\n    }\n}\nclass Appwrite {\n    constructor() {\n        this.config = {\n            endpoint: 'https://HOSTNAME/v1',\n            endpointRealtime: '',\n            project: '',\n            jwt: '',\n            locale: '',\n        };\n        this.headers = {\n            'x-sdk-version': 'appwrite:web:6.0.1',\n            'X-Appwrite-Response-Format': '0.12.0',\n        };\n        this.realtime = {\n            socket: undefined,\n            timeout: undefined,\n            url: '',\n            channels: new Set(),\n            subscriptions: new Map(),\n            subscriptionsCounter: 0,\n            reconnect: true,\n            reconnectAttempts: 0,\n            lastMessage: undefined,\n            connect: () => {\n                clearTimeout(this.realtime.timeout);\n                this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {\n                    this.realtime.createSocket();\n                }, 50);\n            },\n            getTimeout: () => {\n                switch (true) {\n                    case this.realtime.reconnectAttempts < 5:\n                        return 1000;\n                    case this.realtime.reconnectAttempts < 15:\n                        return 5000;\n                    case this.realtime.reconnectAttempts < 100:\n                        return 10000;\n                    default:\n                        return 60000;\n                }\n            },\n            createSocket: () => {\n                var _a, _b;\n                if (this.realtime.channels.size < 1)\n                    return;\n                const channels = new URLSearchParams();\n                channels.set('project', this.config.project);\n                this.realtime.channels.forEach(channel => {\n                    channels.append('channels[]', channel);\n                });\n                const url = this.config.endpointRealtime + '/realtime?' + channels.toString();\n                if (url !== this.realtime.url || // Check if URL is present\n                    !this.realtime.socket || // Check if WebSocket has not been created\n                    ((_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.readyState) > WebSocket.OPEN // Check if WebSocket is CLOSING (3) or CLOSED (4)\n                ) {\n                    if (this.realtime.socket &&\n                        ((_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.readyState) < WebSocket.CLOSING // Close WebSocket if it is CONNECTING (0) or OPEN (1)\n                    ) {\n                        this.realtime.reconnect = false;\n                        this.realtime.socket.close();\n                    }\n                    this.realtime.url = url;\n                    this.realtime.socket = new WebSocket(url);\n                    this.realtime.socket.addEventListener('message', this.realtime.onMessage);\n                    this.realtime.socket.addEventListener('open', _event => {\n                        this.realtime.reconnectAttempts = 0;\n                    });\n                    this.realtime.socket.addEventListener('close', event => {\n                        var _a, _b, _c;\n                        if (!this.realtime.reconnect ||\n                            (((_b = (_a = this.realtime) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.type) === 'error' && // Check if last message was of type error\n                                ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008 // Check for policy violation 1008\n                            )) {\n                            this.realtime.reconnect = true;\n                            return;\n                        }\n                        const timeout = this.realtime.getTimeout();\n                        console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1000} seconds.`, event.reason);\n                        setTimeout(() => {\n                            this.realtime.reconnectAttempts++;\n                            this.realtime.createSocket();\n                        }, timeout);\n                    });\n                }\n            },\n            onMessage: (event) => {\n                var _a, _b;\n                try {\n                    const message = JSON.parse(event.data);\n                    this.realtime.lastMessage = message;\n                    switch (message.type) {\n                        case 'connected':\n                            const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');\n                            const session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.config.project}`];\n                            const messageData = message.data;\n                            if (session && !messageData.user) {\n                                (_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({\n                                    type: 'authentication',\n                                    data: {\n                                        session\n                                    }\n                                }));\n                            }\n                            break;\n                        case 'event':\n                            let data = message.data;\n                            if (data === null || data === void 0 ? void 0 : data.channels) {\n                                const isSubscribed = data.channels.some(channel => this.realtime.channels.has(channel));\n                                if (!isSubscribed)\n                                    return;\n                                this.realtime.subscriptions.forEach(subscription => {\n                                    if (data.channels.some(channel => subscription.channels.includes(channel))) {\n                                        setTimeout(() => subscription.callback(data));\n                                    }\n                                });\n                            }\n                            break;\n                        case 'error':\n                            throw message.data;\n                        default:\n                            break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            },\n            cleanUp: channels => {\n                this.realtime.channels.forEach(channel => {\n                    if (channels.includes(channel)) {\n                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {\n                            return subscription.channels.includes(channel);\n                        });\n                        if (!found) {\n                            this.realtime.channels.delete(channel);\n                        }\n                    }\n                });\n            }\n        };\n        this.account = {\n            /**\n             * Get Account\n             *\n             * Get currently logged in user data as JSON object.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            get: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Account\n             *\n             * Use this endpoint to allow a new user to register a new account in your\n             * project. After the user registration completes successfully, you can use\n             * the [/account/verfication](/docs/client/account#accountCreateVerification)\n             * route to start verifying the user email address. To allow the new user to\n             * login to their new account, you need to create a new [account\n             * session](/docs/client/account#accountCreateSession).\n             *\n             * @param {string} userId\n             * @param {string} email\n             * @param {string} password\n             * @param {string} name\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            create: (userId, email, password, name) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof userId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"userId\"');\n                }\n                if (typeof email === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"email\"');\n                }\n                if (typeof password === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"password\"');\n                }\n                let path = '/account';\n                let payload = {};\n                if (typeof userId !== 'undefined') {\n                    payload['userId'] = userId;\n                }\n                if (typeof email !== 'undefined') {\n                    payload['email'] = email;\n                }\n                if (typeof password !== 'undefined') {\n                    payload['password'] = password;\n                }\n                if (typeof name !== 'undefined') {\n                    payload['name'] = name;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Delete Account\n             *\n             * Delete a currently logged in user account. Behind the scene, the user\n             * record is not deleted but permanently blocked from any access. This is done\n             * to avoid deleted accounts being overtaken by new users with the same email\n             * address. Any user-related resources like documents or storage files should\n             * be deleted separately.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            delete: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('delete', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Account Email\n             *\n             * Update currently logged in user account email address. After changing user\n             * address, the user confirmation status will get reset. A new confirmation\n             * email is not sent automatically however you can use the send confirmation\n             * email endpoint again to send the confirmation email. For security measures,\n             * user password is required to complete this request.\n             * This endpoint can also be used to convert an anonymous account to a normal\n             * one, by passing an email address and a new password.\n             *\n             *\n             * @param {string} email\n             * @param {string} password\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateEmail: (email, password) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof email === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"email\"');\n                }\n                if (typeof password === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"password\"');\n                }\n                let path = '/account/email';\n                let payload = {};\n                if (typeof email !== 'undefined') {\n                    payload['email'] = email;\n                }\n                if (typeof password !== 'undefined') {\n                    payload['password'] = password;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('patch', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Account JWT\n             *\n             * Use this endpoint to create a JSON Web Token. You can use the resulting JWT\n             * to authenticate on behalf of the current user when working with the\n             * Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes\n             * from its creation and will be invalid if the user will logout in that time\n             * frame.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createJWT: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account/jwt';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Account Logs\n             *\n             * Get currently logged in user list of latest security activity logs. Each\n             * log returns user IP address, location and date and time of log.\n             *\n             * @param {number} limit\n             * @param {number} offset\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getLogs: (limit, offset) => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account/logs';\n                let payload = {};\n                if (typeof limit !== 'undefined') {\n                    payload['limit'] = limit;\n                }\n                if (typeof offset !== 'undefined') {\n                    payload['offset'] = offset;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Account Name\n             *\n             * Update currently logged in user account name.\n             *\n             * @param {string} name\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateName: (name) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof name === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"name\"');\n                }\n                let path = '/account/name';\n                let payload = {};\n                if (typeof name !== 'undefined') {\n                    payload['name'] = name;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('patch', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Account Password\n             *\n             * Update currently logged in user password. For validation, user is required\n             * to pass in the new password, and the old password. For users created with\n             * OAuth and Team Invites, oldPassword is optional.\n             *\n             * @param {string} password\n             * @param {string} oldPassword\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updatePassword: (password, oldPassword) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof password === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"password\"');\n                }\n                let path = '/account/password';\n                let payload = {};\n                if (typeof password !== 'undefined') {\n                    payload['password'] = password;\n                }\n                if (typeof oldPassword !== 'undefined') {\n                    payload['oldPassword'] = oldPassword;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('patch', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Account Preferences\n             *\n             * Get currently logged in user preferences as a key-value object.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getPrefs: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account/prefs';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Account Preferences\n             *\n             * Update currently logged in user account preferences. You can pass only the\n             * specific settings you wish to update.\n             *\n             * @param {object} prefs\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updatePrefs: (prefs) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof prefs === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"prefs\"');\n                }\n                let path = '/account/prefs';\n                let payload = {};\n                if (typeof prefs !== 'undefined') {\n                    payload['prefs'] = prefs;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('patch', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Password Recovery\n             *\n             * Sends the user an email with a temporary secret key for password reset.\n             * When the user clicks the confirmation link he is redirected back to your\n             * app password reset URL with the secret key and email address values\n             * attached to the URL query string. Use the query string params to submit a\n             * request to the [PUT\n             * /account/recovery](/docs/client/account#accountUpdateRecovery) endpoint to\n             * complete the process. The verification link sent to the user's email\n             * address is valid for 1 hour.\n             *\n             * @param {string} email\n             * @param {string} url\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createRecovery: (email, url) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof email === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"email\"');\n                }\n                if (typeof url === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"url\"');\n                }\n                let path = '/account/recovery';\n                let payload = {};\n                if (typeof email !== 'undefined') {\n                    payload['email'] = email;\n                }\n                if (typeof url !== 'undefined') {\n                    payload['url'] = url;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Password Recovery (confirmation)\n             *\n             * Use this endpoint to complete the user account password reset. Both the\n             * **userId** and **secret** arguments will be passed as query parameters to\n             * the redirect URL you have provided when sending your request to the [POST\n             * /account/recovery](/docs/client/account#accountCreateRecovery) endpoint.\n             *\n             * Please note that in order to avoid a [Redirect\n             * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n             * the only valid redirect URLs are the ones from domains you have set when\n             * adding your platforms in the console interface.\n             *\n             * @param {string} userId\n             * @param {string} secret\n             * @param {string} password\n             * @param {string} passwordAgain\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateRecovery: (userId, secret, password, passwordAgain) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof userId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"userId\"');\n                }\n                if (typeof secret === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"secret\"');\n                }\n                if (typeof password === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"password\"');\n                }\n                if (typeof passwordAgain === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"passwordAgain\"');\n                }\n                let path = '/account/recovery';\n                let payload = {};\n                if (typeof userId !== 'undefined') {\n                    payload['userId'] = userId;\n                }\n                if (typeof secret !== 'undefined') {\n                    payload['secret'] = secret;\n                }\n                if (typeof password !== 'undefined') {\n                    payload['password'] = password;\n                }\n                if (typeof passwordAgain !== 'undefined') {\n                    payload['passwordAgain'] = passwordAgain;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('put', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Account Sessions\n             *\n             * Get currently logged in user list of active sessions across different\n             * devices.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getSessions: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account/sessions';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Account Session\n             *\n             * Allow the user to login into their account by providing a valid email and\n             * password combination. This route will create a new session for the user.\n             *\n             * @param {string} email\n             * @param {string} password\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createSession: (email, password) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof email === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"email\"');\n                }\n                if (typeof password === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"password\"');\n                }\n                let path = '/account/sessions';\n                let payload = {};\n                if (typeof email !== 'undefined') {\n                    payload['email'] = email;\n                }\n                if (typeof password !== 'undefined') {\n                    payload['password'] = password;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Delete All Account Sessions\n             *\n             * Delete all sessions from the user account and remove any sessions cookies\n             * from the end client.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            deleteSessions: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account/sessions';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('delete', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Anonymous Session\n             *\n             * Use this endpoint to allow a new user to register an anonymous account in\n             * your project. This route will also create a new session for the user. To\n             * allow the new user to convert an anonymous account to a normal account, you\n             * need to update its [email and\n             * password](/docs/client/account#accountUpdateEmail) or create an [OAuth2\n             * session](/docs/client/account#accountCreateOAuth2Session).\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createAnonymousSession: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/account/sessions/anonymous';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Magic URL session\n             *\n             * Sends the user an email with a secret key for creating a session. When the\n             * user clicks the link in the email, the user is redirected back to the URL\n             * you provided with the secret key and userId values attached to the URL\n             * query string. Use the query string parameters to submit a request to the\n             * [PUT\n             * /account/sessions/magic-url](/docs/client/account#accountUpdateMagicURLSession)\n             * endpoint to complete the login process. The link sent to the user's email\n             * address is valid for 1 hour. If you are on a mobile device you can leave\n             * the URL parameter empty, so that the login completion will be handled by\n             * your Appwrite instance by default.\n             *\n             * @param {string} userId\n             * @param {string} email\n             * @param {string} url\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createMagicURLSession: (userId, email, url) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof userId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"userId\"');\n                }\n                if (typeof email === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"email\"');\n                }\n                let path = '/account/sessions/magic-url';\n                let payload = {};\n                if (typeof userId !== 'undefined') {\n                    payload['userId'] = userId;\n                }\n                if (typeof email !== 'undefined') {\n                    payload['email'] = email;\n                }\n                if (typeof url !== 'undefined') {\n                    payload['url'] = url;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Magic URL session (confirmation)\n             *\n             * Use this endpoint to complete creating the session with the Magic URL. Both\n             * the **userId** and **secret** arguments will be passed as query parameters\n             * to the redirect URL you have provided when sending your request to the\n             * [POST\n             * /account/sessions/magic-url](/docs/client/account#accountCreateMagicURLSession)\n             * endpoint.\n             *\n             * Please note that in order to avoid a [Redirect\n             * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n             * the only valid redirect URLs are the ones from domains you have set when\n             * adding your platforms in the console interface.\n             *\n             * @param {string} userId\n             * @param {string} secret\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateMagicURLSession: (userId, secret) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof userId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"userId\"');\n                }\n                if (typeof secret === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"secret\"');\n                }\n                let path = '/account/sessions/magic-url';\n                let payload = {};\n                if (typeof userId !== 'undefined') {\n                    payload['userId'] = userId;\n                }\n                if (typeof secret !== 'undefined') {\n                    payload['secret'] = secret;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('put', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Account Session with OAuth2\n             *\n             * Allow the user to login to their account using the OAuth2 provider of their\n             * choice. Each OAuth2 provider should be enabled from the Appwrite console\n             * first. Use the success and failure arguments to provide a redirect URL's\n             * back to your app when login is completed.\n             *\n             * If there is already an active session, the new session will be attached to\n             * the logged-in account. If there are no active sessions, the server will\n             * attempt to look for a user with the same email address as the email\n             * received from the OAuth2 provider and attach the new session to the\n             * existing user. If no matching user is found - the server will create a new\n             * user..\n             *\n             *\n             * @param {string} provider\n             * @param {string} success\n             * @param {string} failure\n             * @param {string[]} scopes\n             * @throws {AppwriteException}\n             * @returns {void|string}\n             */\n            createOAuth2Session: (provider, success, failure, scopes) => {\n                if (typeof provider === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"provider\"');\n                }\n                let path = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);\n                let payload = {};\n                if (typeof success !== 'undefined') {\n                    payload['success'] = success;\n                }\n                if (typeof failure !== 'undefined') {\n                    payload['failure'] = failure;\n                }\n                if (typeof scopes !== 'undefined') {\n                    payload['scopes'] = scopes;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n                    window.location.href = uri.toString();\n                }\n                else {\n                    return uri;\n                }\n            },\n            /**\n             * Get Session By ID\n             *\n             * Use this endpoint to get a logged in user's session using a Session ID.\n             * Inputting 'current' will return the current session being used.\n             *\n             * @param {string} sessionId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getSession: (sessionId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof sessionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"sessionId\"');\n                }\n                let path = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Delete Account Session\n             *\n             * Use this endpoint to log out the currently logged in user from all their\n             * account sessions across all of their different devices. When using the\n             * option id argument, only the session unique ID provider will be deleted.\n             *\n             * @param {string} sessionId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            deleteSession: (sessionId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof sessionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"sessionId\"');\n                }\n                let path = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('delete', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Email Verification\n             *\n             * Use this endpoint to send a verification message to your user email address\n             * to confirm they are the valid owners of that address. Both the **userId**\n             * and **secret** arguments will be passed as query parameters to the URL you\n             * have provided to be attached to the verification email. The provided URL\n             * should redirect the user back to your app and allow you to complete the\n             * verification process by verifying both the **userId** and **secret**\n             * parameters. Learn more about how to [complete the verification\n             * process](/docs/client/account#accountUpdateVerification). The verification\n             * link sent to the user's email address is valid for 7 days.\n             *\n             * Please note that in order to avoid a [Redirect\n             * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),\n             * the only valid redirect URLs are the ones from domains you have set when\n             * adding your platforms in the console interface.\n             *\n             *\n             * @param {string} url\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createVerification: (url) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof url === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"url\"');\n                }\n                let path = '/account/verification';\n                let payload = {};\n                if (typeof url !== 'undefined') {\n                    payload['url'] = url;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Email Verification (confirmation)\n             *\n             * Use this endpoint to complete the user email verification process. Use both\n             * the **userId** and **secret** parameters that were attached to your app URL\n             * to verify the user email ownership. If confirmed this route will return a\n             * 200 status code.\n             *\n             * @param {string} userId\n             * @param {string} secret\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateVerification: (userId, secret) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof userId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"userId\"');\n                }\n                if (typeof secret === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"secret\"');\n                }\n                let path = '/account/verification';\n                let payload = {};\n                if (typeof userId !== 'undefined') {\n                    payload['userId'] = userId;\n                }\n                if (typeof secret !== 'undefined') {\n                    payload['secret'] = secret;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('put', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            })\n        };\n        this.avatars = {\n            /**\n             * Get Browser Icon\n             *\n             * You can use this endpoint to show different browser icons to your users.\n             * The code argument receives the browser code as it appears in your user\n             * /account/sessions endpoint. Use width, height and quality arguments to\n             * change the output settings.\n             *\n             * @param {string} code\n             * @param {number} width\n             * @param {number} height\n             * @param {number} quality\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getBrowser: (code, width, height, quality) => {\n                if (typeof code === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"code\"');\n                }\n                let path = '/avatars/browsers/{code}'.replace('{code}', code);\n                let payload = {};\n                if (typeof width !== 'undefined') {\n                    payload['width'] = width;\n                }\n                if (typeof height !== 'undefined') {\n                    payload['height'] = height;\n                }\n                if (typeof quality !== 'undefined') {\n                    payload['quality'] = quality;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get Credit Card Icon\n             *\n             * The credit card endpoint will return you the icon of the credit card\n             * provider you need. Use width, height and quality arguments to change the\n             * output settings.\n             *\n             * @param {string} code\n             * @param {number} width\n             * @param {number} height\n             * @param {number} quality\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getCreditCard: (code, width, height, quality) => {\n                if (typeof code === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"code\"');\n                }\n                let path = '/avatars/credit-cards/{code}'.replace('{code}', code);\n                let payload = {};\n                if (typeof width !== 'undefined') {\n                    payload['width'] = width;\n                }\n                if (typeof height !== 'undefined') {\n                    payload['height'] = height;\n                }\n                if (typeof quality !== 'undefined') {\n                    payload['quality'] = quality;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get Favicon\n             *\n             * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote\n             * website URL.\n             *\n             *\n             * @param {string} url\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getFavicon: (url) => {\n                if (typeof url === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"url\"');\n                }\n                let path = '/avatars/favicon';\n                let payload = {};\n                if (typeof url !== 'undefined') {\n                    payload['url'] = url;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get Country Flag\n             *\n             * You can use this endpoint to show different country flags icons to your\n             * users. The code argument receives the 2 letter country code. Use width,\n             * height and quality arguments to change the output settings.\n             *\n             * @param {string} code\n             * @param {number} width\n             * @param {number} height\n             * @param {number} quality\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getFlag: (code, width, height, quality) => {\n                if (typeof code === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"code\"');\n                }\n                let path = '/avatars/flags/{code}'.replace('{code}', code);\n                let payload = {};\n                if (typeof width !== 'undefined') {\n                    payload['width'] = width;\n                }\n                if (typeof height !== 'undefined') {\n                    payload['height'] = height;\n                }\n                if (typeof quality !== 'undefined') {\n                    payload['quality'] = quality;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get Image from URL\n             *\n             * Use this endpoint to fetch a remote image URL and crop it to any image size\n             * you want. This endpoint is very useful if you need to crop and display\n             * remote images in your app or in case you want to make sure a 3rd party\n             * image is properly served using a TLS protocol.\n             *\n             * @param {string} url\n             * @param {number} width\n             * @param {number} height\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getImage: (url, width, height) => {\n                if (typeof url === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"url\"');\n                }\n                let path = '/avatars/image';\n                let payload = {};\n                if (typeof url !== 'undefined') {\n                    payload['url'] = url;\n                }\n                if (typeof width !== 'undefined') {\n                    payload['width'] = width;\n                }\n                if (typeof height !== 'undefined') {\n                    payload['height'] = height;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get User Initials\n             *\n             * Use this endpoint to show your user initials avatar icon on your website or\n             * app. By default, this route will try to print your logged-in user name or\n             * email initials. You can also overwrite the user name if you pass the 'name'\n             * parameter. If no name is given and no user is logged, an empty avatar will\n             * be returned.\n             *\n             * You can use the color and background params to change the avatar colors. By\n             * default, a random theme will be selected. The random theme will persist for\n             * the user's initials when reloading the same theme will always return for\n             * the same initials.\n             *\n             * @param {string} name\n             * @param {number} width\n             * @param {number} height\n             * @param {string} color\n             * @param {string} background\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getInitials: (name, width, height, color, background) => {\n                let path = '/avatars/initials';\n                let payload = {};\n                if (typeof name !== 'undefined') {\n                    payload['name'] = name;\n                }\n                if (typeof width !== 'undefined') {\n                    payload['width'] = width;\n                }\n                if (typeof height !== 'undefined') {\n                    payload['height'] = height;\n                }\n                if (typeof color !== 'undefined') {\n                    payload['color'] = color;\n                }\n                if (typeof background !== 'undefined') {\n                    payload['background'] = background;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get QR Code\n             *\n             * Converts a given plain text to a QR code image. You can use the query\n             * parameters to change the size and style of the resulting image.\n             *\n             * @param {string} text\n             * @param {number} size\n             * @param {number} margin\n             * @param {boolean} download\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getQR: (text, size, margin, download) => {\n                if (typeof text === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"text\"');\n                }\n                let path = '/avatars/qr';\n                let payload = {};\n                if (typeof text !== 'undefined') {\n                    payload['text'] = text;\n                }\n                if (typeof size !== 'undefined') {\n                    payload['size'] = size;\n                }\n                if (typeof margin !== 'undefined') {\n                    payload['margin'] = margin;\n                }\n                if (typeof download !== 'undefined') {\n                    payload['download'] = download;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            }\n        };\n        this.database = {\n            /**\n             * List Documents\n             *\n             * Get a list of all the user documents. You can use the query params to\n             * filter your results. On admin mode, this endpoint will return a list of all\n             * of the project's documents. [Learn more about different API\n             * modes](/docs/admin).\n             *\n             * @param {string} collectionId\n             * @param {string[]} queries\n             * @param {number} limit\n             * @param {number} offset\n             * @param {string} cursor\n             * @param {string} cursorDirection\n             * @param {string[]} orderAttributes\n             * @param {string[]} orderTypes\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            listDocuments: (collectionId, queries, limit, offset, cursor, cursorDirection, orderAttributes, orderTypes) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof collectionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"collectionId\"');\n                }\n                let path = '/database/collections/{collectionId}/documents'.replace('{collectionId}', collectionId);\n                let payload = {};\n                if (typeof queries !== 'undefined') {\n                    payload['queries'] = queries;\n                }\n                if (typeof limit !== 'undefined') {\n                    payload['limit'] = limit;\n                }\n                if (typeof offset !== 'undefined') {\n                    payload['offset'] = offset;\n                }\n                if (typeof cursor !== 'undefined') {\n                    payload['cursor'] = cursor;\n                }\n                if (typeof cursorDirection !== 'undefined') {\n                    payload['cursorDirection'] = cursorDirection;\n                }\n                if (typeof orderAttributes !== 'undefined') {\n                    payload['orderAttributes'] = orderAttributes;\n                }\n                if (typeof orderTypes !== 'undefined') {\n                    payload['orderTypes'] = orderTypes;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Document\n             *\n             * Create a new Document. Before using this route, you should create a new\n             * collection resource using either a [server\n             * integration](/docs/server/database#databaseCreateCollection) API or\n             * directly from your database console.\n             *\n             * @param {string} collectionId\n             * @param {string} documentId\n             * @param {object} data\n             * @param {string[]} read\n             * @param {string[]} write\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createDocument: (collectionId, documentId, data, read, write) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof collectionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"collectionId\"');\n                }\n                if (typeof documentId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"documentId\"');\n                }\n                if (typeof data === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"data\"');\n                }\n                let path = '/database/collections/{collectionId}/documents'.replace('{collectionId}', collectionId);\n                let payload = {};\n                if (typeof documentId !== 'undefined') {\n                    payload['documentId'] = documentId;\n                }\n                if (typeof data !== 'undefined') {\n                    payload['data'] = data;\n                }\n                if (typeof read !== 'undefined') {\n                    payload['read'] = read;\n                }\n                if (typeof write !== 'undefined') {\n                    payload['write'] = write;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Document\n             *\n             * Get a document by its unique ID. This endpoint response returns a JSON\n             * object with the document data.\n             *\n             * @param {string} collectionId\n             * @param {string} documentId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getDocument: (collectionId, documentId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof collectionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"collectionId\"');\n                }\n                if (typeof documentId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"documentId\"');\n                }\n                let path = '/database/collections/{collectionId}/documents/{documentId}'.replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Document\n             *\n             * Update a document by its unique ID. Using the patch method you can pass\n             * only specific fields that will get updated.\n             *\n             * @param {string} collectionId\n             * @param {string} documentId\n             * @param {object} data\n             * @param {string[]} read\n             * @param {string[]} write\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateDocument: (collectionId, documentId, data, read, write) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof collectionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"collectionId\"');\n                }\n                if (typeof documentId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"documentId\"');\n                }\n                if (typeof data === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"data\"');\n                }\n                let path = '/database/collections/{collectionId}/documents/{documentId}'.replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n                let payload = {};\n                if (typeof data !== 'undefined') {\n                    payload['data'] = data;\n                }\n                if (typeof read !== 'undefined') {\n                    payload['read'] = read;\n                }\n                if (typeof write !== 'undefined') {\n                    payload['write'] = write;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('patch', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Delete Document\n             *\n             * Delete a document by its unique ID. This endpoint deletes only the parent\n             * documents, its attributes and relations to other documents. Child documents\n             * **will not** be deleted.\n             *\n             * @param {string} collectionId\n             * @param {string} documentId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            deleteDocument: (collectionId, documentId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof collectionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"collectionId\"');\n                }\n                if (typeof documentId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"documentId\"');\n                }\n                let path = '/database/collections/{collectionId}/documents/{documentId}'.replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('delete', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            })\n        };\n        this.functions = {\n            /**\n             * List Executions\n             *\n             * Get a list of all the current user function execution logs. You can use the\n             * query params to filter your results. On admin mode, this endpoint will\n             * return a list of all of the project's executions. [Learn more about\n             * different API modes](/docs/admin).\n             *\n             * @param {string} functionId\n             * @param {number} limit\n             * @param {number} offset\n             * @param {string} search\n             * @param {string} cursor\n             * @param {string} cursorDirection\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            listExecutions: (functionId, limit, offset, search, cursor, cursorDirection) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof functionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"functionId\"');\n                }\n                let path = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n                let payload = {};\n                if (typeof limit !== 'undefined') {\n                    payload['limit'] = limit;\n                }\n                if (typeof offset !== 'undefined') {\n                    payload['offset'] = offset;\n                }\n                if (typeof search !== 'undefined') {\n                    payload['search'] = search;\n                }\n                if (typeof cursor !== 'undefined') {\n                    payload['cursor'] = cursor;\n                }\n                if (typeof cursorDirection !== 'undefined') {\n                    payload['cursorDirection'] = cursorDirection;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Execution\n             *\n             * Trigger a function execution. The returned object will return you the\n             * current execution status. You can ping the `Get Execution` endpoint to get\n             * updates on the current execution status. Once this endpoint is called, your\n             * function execution process will start asynchronously.\n             *\n             * @param {string} functionId\n             * @param {string} data\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createExecution: (functionId, data) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof functionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"functionId\"');\n                }\n                let path = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n                let payload = {};\n                if (typeof data !== 'undefined') {\n                    payload['data'] = data;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Execution\n             *\n             * Get a function execution log by its unique ID.\n             *\n             * @param {string} functionId\n             * @param {string} executionId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getExecution: (functionId, executionId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof functionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"functionId\"');\n                }\n                if (typeof executionId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"executionId\"');\n                }\n                let path = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            })\n        };\n        this.locale = {\n            /**\n             * Get User Locale\n             *\n             * Get the current user location based on IP. Returns an object with user\n             * country code, country name, continent name, continent code, ip address and\n             * suggested currency. You can use the locale header to get the data in a\n             * supported language.\n             *\n             * ([IP Geolocation by DB-IP](https://db-ip.com))\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            get: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/locale';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * List Continents\n             *\n             * List of all continents. You can use the locale header to get the data in a\n             * supported language.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getContinents: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/locale/continents';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * List Countries\n             *\n             * List of all countries. You can use the locale header to get the data in a\n             * supported language.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getCountries: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/locale/countries';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * List EU Countries\n             *\n             * List of all countries that are currently members of the EU. You can use the\n             * locale header to get the data in a supported language.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getCountriesEU: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/locale/countries/eu';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * List Countries Phone Codes\n             *\n             * List of all countries phone codes. You can use the locale header to get the\n             * data in a supported language.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getCountriesPhones: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/locale/countries/phones';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * List Currencies\n             *\n             * List of all currencies, including currency symbol, name, plural, and\n             * decimal digits for all major and minor currencies. You can use the locale\n             * header to get the data in a supported language.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getCurrencies: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/locale/currencies';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * List Languages\n             *\n             * List of all languages classified by ISO 639-1 including 2-letter code, name\n             * in English, and name in the respective language.\n             *\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getLanguages: () => __awaiter(this, void 0, void 0, function* () {\n                let path = '/locale/languages';\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            })\n        };\n        this.storage = {\n            /**\n             * List Files\n             *\n             * Get a list of all the user files. You can use the query params to filter\n             * your results. On admin mode, this endpoint will return a list of all of the\n             * project's files. [Learn more about different API modes](/docs/admin).\n             *\n             * @param {string} search\n             * @param {number} limit\n             * @param {number} offset\n             * @param {string} cursor\n             * @param {string} cursorDirection\n             * @param {string} orderType\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            listFiles: (search, limit, offset, cursor, cursorDirection, orderType) => __awaiter(this, void 0, void 0, function* () {\n                let path = '/storage/files';\n                let payload = {};\n                if (typeof search !== 'undefined') {\n                    payload['search'] = search;\n                }\n                if (typeof limit !== 'undefined') {\n                    payload['limit'] = limit;\n                }\n                if (typeof offset !== 'undefined') {\n                    payload['offset'] = offset;\n                }\n                if (typeof cursor !== 'undefined') {\n                    payload['cursor'] = cursor;\n                }\n                if (typeof cursorDirection !== 'undefined') {\n                    payload['cursorDirection'] = cursorDirection;\n                }\n                if (typeof orderType !== 'undefined') {\n                    payload['orderType'] = orderType;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create File\n             *\n             * Create a new file. The user who creates the file will automatically be\n             * assigned to read and write access unless he has passed custom values for\n             * read and write arguments.\n             *\n             * @param {string} fileId\n             * @param {File} file\n             * @param {string[]} read\n             * @param {string[]} write\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createFile: (fileId, file, read, write) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof fileId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"fileId\"');\n                }\n                if (typeof file === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"file\"');\n                }\n                let path = '/storage/files';\n                let payload = {};\n                if (typeof fileId !== 'undefined') {\n                    payload['fileId'] = fileId;\n                }\n                if (typeof file !== 'undefined') {\n                    payload['file'] = file;\n                }\n                if (typeof read !== 'undefined') {\n                    payload['read'] = read;\n                }\n                if (typeof write !== 'undefined') {\n                    payload['write'] = write;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'multipart/form-data',\n                }, payload);\n            }),\n            /**\n             * Get File\n             *\n             * Get a file by its unique ID. This endpoint response returns a JSON object\n             * with the file metadata.\n             *\n             * @param {string} fileId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getFile: (fileId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof fileId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"fileId\"');\n                }\n                let path = '/storage/files/{fileId}'.replace('{fileId}', fileId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update File\n             *\n             * Update a file by its unique ID. Only users with write permissions have\n             * access to update this resource.\n             *\n             * @param {string} fileId\n             * @param {string[]} read\n             * @param {string[]} write\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateFile: (fileId, read, write) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof fileId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"fileId\"');\n                }\n                if (typeof read === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"read\"');\n                }\n                if (typeof write === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"write\"');\n                }\n                let path = '/storage/files/{fileId}'.replace('{fileId}', fileId);\n                let payload = {};\n                if (typeof read !== 'undefined') {\n                    payload['read'] = read;\n                }\n                if (typeof write !== 'undefined') {\n                    payload['write'] = write;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('put', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Delete File\n             *\n             * Delete a file by its unique ID. Only users with write permissions have\n             * access to delete this resource.\n             *\n             * @param {string} fileId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            deleteFile: (fileId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof fileId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"fileId\"');\n                }\n                let path = '/storage/files/{fileId}'.replace('{fileId}', fileId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('delete', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get File for Download\n             *\n             * Get a file content by its unique ID. The endpoint response return with a\n             * 'Content-Disposition: attachment' header that tells the browser to start\n             * downloading the file to user downloads directory.\n             *\n             * @param {string} fileId\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getFileDownload: (fileId) => {\n                if (typeof fileId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"fileId\"');\n                }\n                let path = '/storage/files/{fileId}/download'.replace('{fileId}', fileId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get File Preview\n             *\n             * Get a file preview image. Currently, this method supports preview for image\n             * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,\n             * and spreadsheets, will return the file icon image. You can also pass query\n             * string arguments for cutting and resizing your preview image.\n             *\n             * @param {string} fileId\n             * @param {number} width\n             * @param {number} height\n             * @param {string} gravity\n             * @param {number} quality\n             * @param {number} borderWidth\n             * @param {string} borderColor\n             * @param {number} borderRadius\n             * @param {number} opacity\n             * @param {number} rotation\n             * @param {string} background\n             * @param {string} output\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getFilePreview: (fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output) => {\n                if (typeof fileId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"fileId\"');\n                }\n                let path = '/storage/files/{fileId}/preview'.replace('{fileId}', fileId);\n                let payload = {};\n                if (typeof width !== 'undefined') {\n                    payload['width'] = width;\n                }\n                if (typeof height !== 'undefined') {\n                    payload['height'] = height;\n                }\n                if (typeof gravity !== 'undefined') {\n                    payload['gravity'] = gravity;\n                }\n                if (typeof quality !== 'undefined') {\n                    payload['quality'] = quality;\n                }\n                if (typeof borderWidth !== 'undefined') {\n                    payload['borderWidth'] = borderWidth;\n                }\n                if (typeof borderColor !== 'undefined') {\n                    payload['borderColor'] = borderColor;\n                }\n                if (typeof borderRadius !== 'undefined') {\n                    payload['borderRadius'] = borderRadius;\n                }\n                if (typeof opacity !== 'undefined') {\n                    payload['opacity'] = opacity;\n                }\n                if (typeof rotation !== 'undefined') {\n                    payload['rotation'] = rotation;\n                }\n                if (typeof background !== 'undefined') {\n                    payload['background'] = background;\n                }\n                if (typeof output !== 'undefined') {\n                    payload['output'] = output;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            },\n            /**\n             * Get File for View\n             *\n             * Get a file content by its unique ID. This endpoint is similar to the\n             * download method but returns with no  'Content-Disposition: attachment'\n             * header.\n             *\n             * @param {string} fileId\n             * @throws {AppwriteException}\n             * @returns {URL}\n             */\n            getFileView: (fileId) => {\n                if (typeof fileId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"fileId\"');\n                }\n                let path = '/storage/files/{fileId}/view'.replace('{fileId}', fileId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                payload['project'] = this.config.project;\n                for (const [key, value] of Object.entries(this.flatten(payload))) {\n                    uri.searchParams.append(key, value);\n                }\n                return uri;\n            }\n        };\n        this.teams = {\n            /**\n             * List Teams\n             *\n             * Get a list of all the teams in which the current user is a member. You can\n             * use the parameters to filter your results.\n             *\n             * In admin mode, this endpoint returns a list of all the teams in the current\n             * project. [Learn more about different API modes](/docs/admin).\n             *\n             * @param {string} search\n             * @param {number} limit\n             * @param {number} offset\n             * @param {string} cursor\n             * @param {string} cursorDirection\n             * @param {string} orderType\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            list: (search, limit, offset, cursor, cursorDirection, orderType) => __awaiter(this, void 0, void 0, function* () {\n                let path = '/teams';\n                let payload = {};\n                if (typeof search !== 'undefined') {\n                    payload['search'] = search;\n                }\n                if (typeof limit !== 'undefined') {\n                    payload['limit'] = limit;\n                }\n                if (typeof offset !== 'undefined') {\n                    payload['offset'] = offset;\n                }\n                if (typeof cursor !== 'undefined') {\n                    payload['cursor'] = cursor;\n                }\n                if (typeof cursorDirection !== 'undefined') {\n                    payload['cursorDirection'] = cursorDirection;\n                }\n                if (typeof orderType !== 'undefined') {\n                    payload['orderType'] = orderType;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Team\n             *\n             * Create a new team. The user who creates the team will automatically be\n             * assigned as the owner of the team. Only the users with the owner role can\n             * invite new members, add new owners and delete or update the team.\n             *\n             * @param {string} teamId\n             * @param {string} name\n             * @param {string[]} roles\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            create: (teamId, name, roles) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                if (typeof name === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"name\"');\n                }\n                let path = '/teams';\n                let payload = {};\n                if (typeof teamId !== 'undefined') {\n                    payload['teamId'] = teamId;\n                }\n                if (typeof name !== 'undefined') {\n                    payload['name'] = name;\n                }\n                if (typeof roles !== 'undefined') {\n                    payload['roles'] = roles;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Team\n             *\n             * Get a team by its ID. All team members have read access for this resource.\n             *\n             * @param {string} teamId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            get: (teamId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                let path = '/teams/{teamId}'.replace('{teamId}', teamId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Team\n             *\n             * Update a team using its ID. Only members with the owner role can update the\n             * team.\n             *\n             * @param {string} teamId\n             * @param {string} name\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            update: (teamId, name) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                if (typeof name === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"name\"');\n                }\n                let path = '/teams/{teamId}'.replace('{teamId}', teamId);\n                let payload = {};\n                if (typeof name !== 'undefined') {\n                    payload['name'] = name;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('put', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Delete Team\n             *\n             * Delete a team using its ID. Only team members with the owner role can\n             * delete the team.\n             *\n             * @param {string} teamId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            delete: (teamId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                let path = '/teams/{teamId}'.replace('{teamId}', teamId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('delete', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Team Memberships\n             *\n             * Use this endpoint to list a team's members using the team's ID. All team\n             * members have read access to this endpoint.\n             *\n             * @param {string} teamId\n             * @param {string} search\n             * @param {number} limit\n             * @param {number} offset\n             * @param {string} cursor\n             * @param {string} cursorDirection\n             * @param {string} orderType\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getMemberships: (teamId, search, limit, offset, cursor, cursorDirection, orderType) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                let path = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n                let payload = {};\n                if (typeof search !== 'undefined') {\n                    payload['search'] = search;\n                }\n                if (typeof limit !== 'undefined') {\n                    payload['limit'] = limit;\n                }\n                if (typeof offset !== 'undefined') {\n                    payload['offset'] = offset;\n                }\n                if (typeof cursor !== 'undefined') {\n                    payload['cursor'] = cursor;\n                }\n                if (typeof cursorDirection !== 'undefined') {\n                    payload['cursorDirection'] = cursorDirection;\n                }\n                if (typeof orderType !== 'undefined') {\n                    payload['orderType'] = orderType;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Create Team Membership\n             *\n             * Invite a new member to join your team. If initiated from the client SDK, an\n             * email with a link to join the team will be sent to the member's email\n             * address and an account will be created for them should they not be signed\n             * up already. If initiated from server-side SDKs, the new member will\n             * automatically be added to the team.\n             *\n             * Use the 'url' parameter to redirect the user from the invitation email back\n             * to your app. When the user is redirected, use the [Update Team Membership\n             * Status](/docs/client/teams#teamsUpdateMembershipStatus) endpoint to allow\n             * the user to accept the invitation to the team.\n             *\n             * Please note that to avoid a [Redirect\n             * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n             * the only valid redirect URL's are the once from domains you have set when\n             * adding your platforms in the console interface.\n             *\n             * @param {string} teamId\n             * @param {string} email\n             * @param {string[]} roles\n             * @param {string} url\n             * @param {string} name\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            createMembership: (teamId, email, roles, url, name) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                if (typeof email === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"email\"');\n                }\n                if (typeof roles === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"roles\"');\n                }\n                if (typeof url === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"url\"');\n                }\n                let path = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n                let payload = {};\n                if (typeof email !== 'undefined') {\n                    payload['email'] = email;\n                }\n                if (typeof roles !== 'undefined') {\n                    payload['roles'] = roles;\n                }\n                if (typeof url !== 'undefined') {\n                    payload['url'] = url;\n                }\n                if (typeof name !== 'undefined') {\n                    payload['name'] = name;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('post', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Get Team Membership\n             *\n             * Get a team member by the membership unique id. All team members have read\n             * access for this resource.\n             *\n             * @param {string} teamId\n             * @param {string} membershipId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            getMembership: (teamId, membershipId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                if (typeof membershipId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"membershipId\"');\n                }\n                let path = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('get', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Membership Roles\n             *\n             * Modify the roles of a team member. Only team members with the owner role\n             * have access to this endpoint. Learn more about [roles and\n             * permissions](/docs/permissions).\n             *\n             * @param {string} teamId\n             * @param {string} membershipId\n             * @param {string[]} roles\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateMembershipRoles: (teamId, membershipId, roles) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                if (typeof membershipId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"membershipId\"');\n                }\n                if (typeof roles === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"roles\"');\n                }\n                let path = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n                let payload = {};\n                if (typeof roles !== 'undefined') {\n                    payload['roles'] = roles;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('patch', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Delete Team Membership\n             *\n             * This endpoint allows a user to leave a team or for a team owner to delete\n             * the membership of any other team member. You can also use this endpoint to\n             * delete a user membership even if it is not accepted.\n             *\n             * @param {string} teamId\n             * @param {string} membershipId\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            deleteMembership: (teamId, membershipId) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                if (typeof membershipId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"membershipId\"');\n                }\n                let path = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n                let payload = {};\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('delete', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            }),\n            /**\n             * Update Team Membership Status\n             *\n             * Use this endpoint to allow a user to accept an invitation to join a team\n             * after being redirected back to your app from the invitation email received\n             * by the user.\n             *\n             * @param {string} teamId\n             * @param {string} membershipId\n             * @param {string} userId\n             * @param {string} secret\n             * @throws {AppwriteException}\n             * @returns {Promise}\n             */\n            updateMembershipStatus: (teamId, membershipId, userId, secret) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof teamId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"teamId\"');\n                }\n                if (typeof membershipId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"membershipId\"');\n                }\n                if (typeof userId === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"userId\"');\n                }\n                if (typeof secret === 'undefined') {\n                    throw new AppwriteException('Missing required parameter: \"secret\"');\n                }\n                let path = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n                let payload = {};\n                if (typeof userId !== 'undefined') {\n                    payload['userId'] = userId;\n                }\n                if (typeof secret !== 'undefined') {\n                    payload['secret'] = secret;\n                }\n                const uri = new URL(this.config.endpoint + path);\n                return yield this.call('patch', uri, {\n                    'content-type': 'application/json',\n                }, payload);\n            })\n        };\n    }\n    /**\n     * Set Endpoint\n     *\n     * Your project endpoint\n     *\n     * @param {string} endpoint\n     *\n     * @returns {this}\n     */\n    setEndpoint(endpoint) {\n        this.config.endpoint = endpoint;\n        this.config.endpointRealtime = this.config.endpointRealtime || this.config.endpoint.replace('https://', 'wss://').replace('http://', 'ws://');\n        return this;\n    }\n    /**\n     * Set Realtime Endpoint\n     *\n     * @param {string} endpointRealtime\n     *\n     * @returns {this}\n     */\n    setEndpointRealtime(endpointRealtime) {\n        this.config.endpointRealtime = endpointRealtime;\n        return this;\n    }\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setProject(value) {\n        this.headers['X-Appwrite-Project'] = value;\n        this.config.project = value;\n        return this;\n    }\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setJWT(value) {\n        this.headers['X-Appwrite-JWT'] = value;\n        this.config.jwt = value;\n        return this;\n    }\n    /**\n     * Set Locale\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setLocale(value) {\n        this.headers['X-Appwrite-Locale'] = value;\n        this.config.locale = value;\n        return this;\n    }\n    /**\n     * Subscribes to Appwrite events and passes you the payload in realtime.\n     *\n     * @param {string|string[]} channels\n     * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.\n     *\n     * Possible channels are:\n     * - account\n     * - collections\n     * - collections.[ID]\n     * - collections.[ID].documents\n     * - documents\n     * - documents.[ID]\n     * - files\n     * - files.[ID]\n     * - executions\n     * - executions.[ID]\n     * - functions.[ID]\n     * - teams\n     * - teams.[ID]\n     * - memberships\n     * - memberships.[ID]\n     * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.\n     * @returns {() => void} Unsubscribes from events.\n     */\n    subscribe(channels, callback) {\n        let channelArray = typeof channels === 'string' ? [channels] : channels;\n        channelArray.forEach(channel => this.realtime.channels.add(channel));\n        const counter = this.realtime.subscriptionsCounter++;\n        this.realtime.subscriptions.set(counter, {\n            channels: channelArray,\n            callback\n        });\n        this.realtime.connect();\n        return () => {\n            this.realtime.subscriptions.delete(counter);\n            this.realtime.cleanUp(channelArray);\n            this.realtime.connect();\n        };\n    }\n    call(method, url, headers = {}, params = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            method = method.toUpperCase();\n            headers = Object.assign(Object.assign({}, headers), this.headers);\n            let options = {\n                method,\n                headers,\n                credentials: 'include'\n            };\n            if (typeof window !== 'undefined' && window.localStorage) {\n                headers['X-Fallback-Cookies'] = (_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '';\n            }\n            if (method === 'GET') {\n                for (const [key, value] of Object.entries(this.flatten(params))) {\n                    url.searchParams.append(key, value);\n                }\n            }\n            else {\n                switch (headers['content-type']) {\n                    case 'application/json':\n                        options.body = JSON.stringify(params);\n                        break;\n                    case 'multipart/form-data':\n                        let formData = new FormData();\n                        for (const key in params) {\n                            if (Array.isArray(params[key])) {\n                                params[key].forEach((value) => {\n                                    formData.append(key + '[]', value);\n                                });\n                            }\n                            else {\n                                formData.append(key, params[key]);\n                            }\n                        }\n                        options.body = formData;\n                        delete headers['content-type'];\n                        break;\n                }\n            }\n            try {\n                let data = null;\n                const response = yield (0,cross_fetch__WEBPACK_IMPORTED_MODULE_1__.fetch)(url.toString(), options);\n                if ((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.includes('application/json')) {\n                    data = yield response.json();\n                }\n                else {\n                    data = {\n                        message: yield response.text()\n                    };\n                }\n                if (400 <= response.status) {\n                    throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data);\n                }\n                const cookieFallback = response.headers.get('X-Fallback-Cookies');\n                if (typeof window !== 'undefined' && window.localStorage && cookieFallback) {\n                    window.console.warn('Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.');\n                    window.localStorage.setItem('cookieFallback', cookieFallback);\n                }\n                return data;\n            }\n            catch (e) {\n                if (e instanceof AppwriteException) {\n                    throw e;\n                }\n                throw new AppwriteException(e.message);\n            }\n        });\n    }\n    flatten(data, prefix = '') {\n        let output = {};\n        for (const key in data) {\n            let value = data[key];\n            let finalKey = prefix ? `${prefix}[${key}]` : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(output, this.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\nclass Query {\n}\nQuery.equal = (attribute, value) => Query.addQuery(attribute, \"equal\", value);\nQuery.notEqual = (attribute, value) => Query.addQuery(attribute, \"notEqual\", value);\nQuery.lesser = (attribute, value) => Query.addQuery(attribute, \"lesser\", value);\nQuery.lesserEqual = (attribute, value) => Query.addQuery(attribute, \"lesserEqual\", value);\nQuery.greater = (attribute, value) => Query.addQuery(attribute, \"greater\", value);\nQuery.greaterEqual = (attribute, value) => Query.addQuery(attribute, \"greaterEqual\", value);\nQuery.search = (attribute, value) => Query.addQuery(attribute, \"search\", value);\nQuery.addQuery = (attribute, oper, value) => value instanceof Array\n    ? `${attribute}.${oper}(${value\n        .map((v) => Query.parseValues(v))\n        .join(\",\")})`\n    : `${attribute}.${oper}(${Query.parseValues(value)})`;\nQuery.parseValues = (value) => typeof value === \"string\" || value instanceof String\n    ? `\"${value}\"`\n    : `${value}`;\n\n\n//# sourceMappingURL=sdk.js.map\n\n\n//# sourceURL=webpack://crity/./node_modules/appwrite/dist/esm/sdk.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/src/index.js");
/******/ 	
/******/ })()
;